<!DOCTYPE html>
<html lang="en"><head>
  
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
         TeX: {
         equationNumbers: {
             autoNumber: "AMS"
         }
         },
         tex2jax: {
         inlineMath: [ ['$', '$'] ],
         displayMath: [ ['$$', '$$'] ],
         processEscapes: true,
     }
     });
     MathJax.Hub.Register.MessageHook("Math Processing Error",function (message) {
         alert("Math Processing Error: "+message[1]);
         });
     MathJax.Hub.Register.MessageHook("TeX Jax - parse error",function (message) {
         alert("Math Processing Error: "+message[1]);
         });
     </script>
<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
  

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <title>[ALG] 3.1. Sorting âœ± Kyuhwan Shim</title>

  <link rel="stylesheet" href="/assets/css/style.css">

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Barlow:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800&family=Noto+Sans+TC&display=swap" rel="stylesheet">

  <link href="/assets/fontawesome/all.min.css" rel="stylesheet">

  <!-- Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js'></script>

  <!-- GA -->
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VG8LB4J4EL"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VG8LB4J4EL');
</script>


  <!-- favicon -->
  <link rel="apple-touch-icon" sizes="57x57" href="/assets/images/main/favicon/favicon.ico">
  <link rel="apple-touch-icon" sizes="57x57" href="/assets/images/main/favicon/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/assets/images/main/favicon/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/assets/images/main/favicon/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/assets/images/main/favicon/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/assets/images/main/favicon/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/assets/images/main/favicon/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/assets/images/main/favicon/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/assets/images/main/favicon/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/main/favicon/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/assets/images/main/favicon/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/main/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/assets/images/main/favicon/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/main/favicon/favicon-16x16.png">
  <link rel="manifest" href="">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/assets/images/main/favicon/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <!-- Opengraph -->
  <meta property="og:type" content="website">
  <meta property="og:image" content="/assets/images/main/favicon/og.png%5BALG%5D-3.1.-Sorting.jpg">
  <meta property="og:title" content="[ALG] 3.1. Sorting | Kyuhwan Shim">
  <meta property="og:description" content="Paper overview of  et al., ">

  <!-- Google scholar -->
  
  <meta name="citation_title" content="[ALG] 3.1. Sorting">
  
  <meta name="citation_publication_date" content="">
  
  <meta name="citation_conference_title" content="">
  
  <meta name="citation_pdf_url" content="https://underthelights.github.io/assets/pdf/[ALG]-3.1.-Sorting.pdf">
  
</head>
<body><header class="page-content">
  <nav class="navbar navbar-expand-md navbar-light py-4">
    <div class="container-fluid">
      <button class="navbar-toggler ms-auto" type="button" data-bs-toggle="collapse" data-bs-target="#navbarTogglerDemo01" aria-controls="navbarTogglerDemo01" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarTogglerDemo01">
        <ul class="navbar-nav ms-auto mt-4 mt-lg-0 navbar-nav-scroll">
          <li class="nav-item">
            <a class="nav-link " aria-current="page" href="/">Home</a>
          </li>
          <li class="nav-item">
            <a class="nav-link " aria-current="page" href="/news">News</a>
          </li>
          <li class="nav-item">
            <a class="nav-link " aria-current="page" href="/project">Project</a>
          </li>
          <li class="nav-item">
            <a class="nav-link " aria-current="page" href="/oconnect">oconnect</a>
          </li>
          <li class="nav-item">
            <a class="nav-link " aria-current="page" href="/cv">CV</a>
          </li>
          <li class="nav-item dropdown">
              <a href="#" class="nav-link dropdown-toggle " data-bs-toggle="dropdown">fun</a>
              <div class="dropdown-menu">
                  <a href="/music" class="dropdown-item">music</a>
                  <a href="/artwork" class="dropdown-item">artwork</a>
              </div>
          </li>
          <li class="nav-item">
            <a class="nav-link " aria-current="page" target="_blank" rel="noopener noreferrer" href="https://underthelights.github.io/blog/">Blog<i class="fa-regular fa-arrow-up-right-from-square" style="padding-left: 5px;"></i></a>
          </li>
        </ul>
      </div>
    </div>
  </nav>
</header>

<style>
  .dropdown-toggle {
    background-color: transparent;
    border-color: #fff;
    border-style: solid;
    border-top: none;
    border-right: none;
    border-left: none;
    transition: color .15s ease-in-out, background-color .15s ease-in-out,border-color .15s ease-in-out;
  }
  .dropdown-toggle:hover {
    font-weight: 500
  }
  .dropdown:hover .dropdown-menu {
    display: block;
    margin-top: 0;
 }
 .dropdown-menu {
    --bs-dropdown-border-radius: 0 !important;
    padding-top: 0 !important;
    padding-bottom: 0 !important
 }
 .dropdown-item {
  font-size: .95rem !important;
  padding: .3rem .75rem !important;
 }
 .dropdown-item:active {
  background-color: #999 !important
 }
</style><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <style>
  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    
      font-family: 'Arial', sans-serif;
      /* Use a modern font */
      margin-top: 20px;
      margin-bottom: 10px;
  }
  /* í¬ìŠ¤íŠ¸ í—¤ë”ì— ì ìš©ë˜ëŠ” ì—¬ë°± ì œê±° */
  .post-header, h1, h2, h3, h4, h5, h6 {
      margin-left: 0 !important; 
      padding-left: 0 !important;
  }


  .post-title {
      font-size: 2em; /* í°íŠ¸ í¬ê¸° ì¦ê°€ */
      font-weight: bold; /* ë³¼ë“œì²´ */
      color: #333; /* ìƒ‰ìƒ ë³€ê²½ */
      box-shadow: inset 0 -20px 0 #bbb7e8;
      max-width: max-content;
    }

  /* Updated styling for h1 */
  h1 {
    font-size: 1.5em;
    /* Increase font size for main titles */
    box-shadow: inset 0 -10px 0 #bbb7e8;
    max-width: max-content; 
    font-weight: bold; /* ë³¼ë“œì²´ */
    border-bottom: none;
    /* Remove bottom border */
    padding-bottom: 0;
    /* Adjust padding if needed */
  }

  h2 {
    font-size: 1.2em;
    margin-left: none;
    font-weight: bold; /* ë³¼ë“œì²´ */
    max-width: max-content; 
    background-color: #cdcbe9;
  }

  h3 {
    font-size: 1.1em;
    max-width: max-content; 
    
    max-width: max-content; 
    background-color: #bbb7e8;
  }

  h4 {
    font-size: 0.75em;
    color: #888888;
  }

  h5 {
    font-size: 0.5em;
    color: #a6a6a6;
  }

  h6 {
    font-size: 1em;
    color: #bcbcbc;
  }

  /* Add some additional styling if needed */
  .post-content {
    margin-left: 20px; /* ì™¼ìª½ ì—¬ë°± ì¶”ê°€ */
    /* margin-right: 20px; ì˜¤ë¥¸ìª½ì— TOC ë„ˆë¹„ + ì—¬ë°± ë§Œí¼ ì¶”ê°€ */
    line-height: 1.6;/* Improve readability */
    color: #333;/* Dark grey color for text */
  }
  /* Category Chart Style */
  .category-chart {
    font-family: 'Arial', sans-serif;
    /* width: 100%; */
    /* height: 100px; Adjust as needed */
  }

  .category-list li {
    display: inline-block;
    margin-right: 20px;
  }
  /* ì´ë¯¸ì§€ ìŠ¤íƒ€ì¼ */
  img {
    display: block; /* ì´ë¯¸ì§€ë¥¼ ë¸”ë¡ ë ˆë²¨ë¡œ ì„¤ì • */
    width: 50%; /* ë˜ëŠ” ì›í•˜ëŠ” ë„ˆë¹„ */
    height: auto; /* ë¹„ìœ¨ ìœ ì§€ */
    margin-bottom: 5px; /* ì´ë¯¸ì§€ì™€ ìº¡ì…˜ ì‚¬ì´ì˜ ê°„ê²© */
    text-align: center;
  }

  /* ì´ë¯¸ì§€ ìº¡ì…˜ ìŠ¤íƒ€ì¼ë§ */
  .em {
    color: #757575;
    font-size: 0.8em;
    
    /* margin-top: 5px; */
    display: block; /* ìº¡ì…˜ì„ ë¸”ë¡ ìš”ì†Œë¡œ ì„¤ì •, ì´ë¯¸ì§€ ì•„ë˜ë¡œ ê°•ì œ ë°°ì¹˜ */
    text-align: center;
    margin-bottom: 5px;
  }
  /* Blockquote ìŠ¤íƒ€ì¼ */
  blockquote {
      margin-left: 20px;
      border-left: 1.5px solid #ccc; /* ì¢Œì¸¡ ì„  */
      border-top: 1.5px solid #ccc; /* ì¢Œì¸¡ ì„  */
      border-right: 1.5px solid #ccc; /* ì¢Œì¸¡ ì„  */
      border-bottom: 1.5px solid #ccc; /* ì¢Œì¸¡ ì„  */

      padding-left: 15px;
      color: #666; /* ê¸€ì ìƒ‰ìƒ */
  }



</style>

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <!-- Table of Contents Container -->
<div class="toc-container">
    <nav class="toc">
      <strong>Table of Contents</strong>
      <!--  -->
      <!-- Jekyll TOC Liquid Code -->
      <ul><li><a href="#alg-311-merge-sort-1">[ALG] 3.1.1. Merge Sort (1)</a></li></ul>

      <!-- <ul><li><a href="#alg-311-merge-sort-1">[ALG] 3.1.1. Merge Sort (1)</a></li></ul> -->
    </nav>
</div>

<style>
    /* TOC ìŠ¤íƒ€ì¼ */
.toc-container {
  position: fixed;
  right: 10px;
  top: 100px;
  z-index: 1000;
  /* max-width: 50px; ê°€ë¡œ ë„ˆë¹„ ì¡°ì •, í•„ìš”ì— ë”°ë¼ ê°’ì„ ë³€ê²½í•˜ì„¸ìš” */
  font-size: 0.75rem;
}

.toc {
  border: 1px solid #ddd;
  padding: 10px;
  border-radius: 5px;
  background-color: white;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  max-width: 200px; /* ê°€ë¡œ ë„ˆë¹„ ì¡°ì •, í•„ìš”ì— ë”°ë¼ ê°’ì„ ë³€ê²½í•˜ì„¸ìš” */
}


.toc strong {
  display: block;
  margin-bottom: 10px;
}

.toc ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.toc ul li a {
  text-decoration: none;
  color: #007bff;
  display: block;
  padding: 5px 0;
}

.toc ul li a:hover,
.toc ul li a.active { /* ì¶”ê°€ëœ active í´ë˜ìŠ¤ ìŠ¤íƒ€ì¼ */
  font-weight: bold;
  /* box-shadow: inset 0 -10px 0 #bbb7e8; */
  background-color: #bbb7e8;
}



  button {
    padding: 5px 10px;
    /* ìƒí•˜ 10px, ì¢Œìš° 20px íŒ¨ë”©ìœ¼ë¡œ í…ìŠ¤íŠ¸ ì£¼ë³€ ì—¬ìœ  ê³µê°„ ì¶”ê°€ */
    font-size: 0.87rem;
    /* ê¸€ì í¬ê¸° */
    color: white;
    /* ê¸€ì ìƒ‰ìƒ */
    background-color: #007bff;
    /* ë°°ê²½ ìƒ‰ìƒ */
    border: none;
    /* í…Œë‘ë¦¬ ì œê±° */
    border-radius: 5px;
    /* ëª¨ì„œë¦¬ ë‘¥ê¸€ê²Œ */
    cursor: pointer;
    /* ì»¤ì„œ ëª¨ì–‘ ë³€ê²½ */
    transition: background-color 0.3s;
    /* í˜¸ë²„ íš¨ê³¼ë¥¼ ìœ„í•œ ì „í™˜ ì„¤ì • */
    text-align: center;
    /* ê¸€ìë¥¼ ë²„íŠ¼ ì¤‘ì•™ì— ìœ„ì¹˜ */
    display: inline-block;
    /* ì¸ë¼ì¸ ë¸”ë¡ ìš”ì†Œë¡œ ì„¤ì •í•˜ì—¬ ìì—°ìŠ¤ëŸ½ê²Œ í…ìŠ¤íŠ¸ ì¤‘ì•™ ì •ë ¬ */
    line-height: normal;
    /* ê¸°ë³¸ ë¼ì¸ ë†’ì´ ì„¤ì • */
    vertical-align: middle;
    /* ìˆ˜ì§ ë°©í–¥ìœ¼ë¡œ ì¤‘ì•™ ì •ë ¬ */
    margin-top: 5px;
  }

  button:hover {
    background-color: #0056b3;
    /* í˜¸ë²„ ì‹œ ë°°ê²½ ìƒ‰ìƒ ë³€ê²½ */
  }


  /* reset base styles */
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  /* page header */
  header {
    margin-bottom: 2rem;
    padding-left: 6.5rem;
  }

  header h1 {
    font-size: 1.5rem;
  }

  header p {
    margin: .5rem 0;
    font-size: 1rem !important
  }

  main b {
    font-weight: 500
  }

  /* normal body content */
  h2 {
    font-size: 1.1rem;
    margin-bottom: 0.75rem;
    margin-left: 6.5rem;
    text-transform: uppercase;
  }

  h3 {
    border-bottom: 1px solid black;
    font-size: .9rem;
    margin: 1rem 0 .5rem 6.5rem
  }

  p {
    margin-bottom: 0.5rem;
  }

  a {
    color: inherit;
    /*#0000ee;*/
  }

  section {
    margin-bottom: 3rem;
  }

  /* misc */
  .pdf {
    font-size: .9rem !important;
    font-weight: 300;
    margin-left: 1.5rem;
    white-space: nowrap;
  }

  .pdf i {
    margin-right: .1rem;
  }

  .material {
    font-size: small;
    margin-left: .5rem;
  }

  :global(i) {
    padding-right: 4px !important
  }

  /* dated entries */
  .dated-entry {
    display: flex;
    flex-flow: row wrap;
    position: relative;
    margin-bottom: 1rem;
  }

  .dated-date {
    width: 6.5rem;
    text-align: right;
    padding-top: .15rem;
    padding-right: 1.5rem;
    font-size: .8rem
  }

  .dated-content {
    width: calc(100% - 6.5rem);
    font-size: .95rem
  }

  .oneline-entries {
    margin-bottom: 0.5rem;
  }

  .oneline-entries .dated-entry {
    margin-bottom: 0;
  }

  /* hide extra awards info for now, not sure what to include */
  #awards em {
    display: none;
  }

  .author-tooltip {
    font-weight: 400;
    font-size: .8rem !important;
    text-align: center;
  }

  /* on narrow displays, make the font smaller */
  @media (max-width: 480px) {
    html {
      font-size: 14px;
    }
  }

  /* when printing, make the font smaller and the page full-width */
  @media print {
    html {
      font-size: 12px;
    }

    main {
      margin-top: 0;
      max-width: 100%;
    }
  }

</style>

<script>
    document.addEventListener('scroll', function() {
      var sections = document.querySelectorAll('section'); // ì„¹ì…˜ ì„ íƒì ìˆ˜ì •
      var menu_links = document.querySelectorAll('.toc a'); // TOC ë§í¬ ì„ íƒì ìˆ˜ì •
    
      var fromTop = window.scrollY;
    
      sections.forEach(function(section) {
        if (section.offsetTop <= fromTop && section.offsetTop + section.offsetHeight > fromTop) {
          menu_links.forEach(function(link) {
            if (section.getAttribute('id') && link.getAttribute('href').includes(section.getAttribute('id'))) {
              link.classList.add('active');  // í˜„ì¬ ì„¹ì…˜ì˜ TOC ë§í¬ì— 'active' í´ë˜ìŠ¤ ì¶”ê°€
            } else {
              link.classList.remove('active'); // ë‹¤ë¥¸ ëª¨ë“  ë§í¬ì—ì„œ 'active' í´ë˜ìŠ¤ ì œê±°
            }
          });
        }
      });
    });
    </script>
    

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">[ALG] 3.1. Sorting</h1>
    <p class="post-meta"><time class="dt-published" datetime="2022-09-19T00:00:00+09:00" itemprop="datePublished">
        Sep 19, 2022
      </time></p>
    <!-- íƒœê·¸ì™€ ì¹´í…Œê³ ë¦¬ í‘œì‹œ -->
    <div class="post-categories">
      
      <strong><span>ğŸ“š Categories:</span></strong>
      
      <a href="blog-categories-notes">Notes</a>
      
      
    </div>

    <div class="post-tags">
      
      <strong><span>ğŸ·ï¸ Tags:</span></strong>
      
      <a href="blog-tags-algorithm">Algorithm</a>
      
      
    </div>


  </header>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="alg-311-merge-sort-1">[ALG] 3.1.1. Merge Sort (1)</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>divide and conquer ê´€ì ì—ì„œ - merge sortë¥¼ ë°”ë¼ë³´ë©´, ë§¨ ìœ„ ì„ì˜ë¡œ ì£¼ì–´ì§„ ë°°ì—´ dataë¥¼ ì•„ë˜ì²˜ëŸ¼ ì •ë ¬í•œë‹¤ê³  í•˜ì. 


divide and conqerê°€ ìì—°ìŠ¤ëŸ½ê²Œ ë“¤ì–´ì˜¤ë©´, ì´ì œë¶€í„° ëª‡ ì£¼ê°€ í¸í•˜ê²Œ ê°ˆ ê²ƒì´ë‹¤.


# 1. Merge Sort

- **Problem**: SortÂ _n_Â keys in nondecreasing sequence.
- **Inputs**: positive integerÂ _n_, array of keysÂ _S_Â indexed fromÂ 1Â toÂ _n_.
- **Outputs**: the arrayÂ _S_Â containing the keys in nondecreasing order. ë°°ì—´ SëŠ” ê°ì†Œí•˜ì§€ ì•ŠëŠ” ìˆœì„œë¡œ ì •ë ¬ëœ keyë¥¼ ê°–ëŠ”ë‹¤
	1. **Divide**Â the array into two subarrays each with $\frac n 2$Â items.
		1. ì „ë°˜ë¶€ í›„ë°˜ë¶€ í•œ ë©ì–´ë¦¬ì”© ë‚˜ëˆˆë‹¤ : ì ˆë°˜ìœ¼ë¡œ ë‚˜ëˆ„ì–´ì„œ
	2. **Conquer**Â each subarray by sorting it recursively.
		1. í•œ elementë§Œ ë‚¨ê²Œ ë˜ë©´ ì •ë ¬ ë
	3. **Combine**Â the solutions to the subarrays by merging them into a single sorted array.
		1. mergeì˜ ê²½ìš° í¬ê¸° ìˆœì„œëŒ€ë¡œ ë˜ì–´ ìˆëŠ”ë° ê° ë¶€ë¶„ì˜ solutionì„ ì ì ˆíˆ combineí•´ì„œ ì°¾ëŠ”ë‹¤
		2. ê° ê·¸ë£¹ì¤‘ì— ë¹„êµí•´ì„œ ë” ì‘ì€ ë†ˆ ë‚˜ì™€ í•´ì„œ sublistë“¤ì„ mergeí•˜ëŠ” ê³¼ì •. : recursiveí•˜ê²Œ sortí•˜ì—¬ ì •ë ¬ëœ listë¡œ mergeí•˜ì—¬ ê° ë°ì´í„°ë¥¼ ì´í•©í•˜ëŠ” ë°©ì‹

![0](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/0.png)

- A simple implementation

	```c
	// Sort a list from A[left] to A[right].
	// Should be optimized for higher efficiency!!!
	void merge_sort(item_type *A, int left, int right)
	{
	    int middle;
	    if (left &lt; right)
	    {
	        // divide : O(1)
	        middle = (left + right) / 2;
	
	        // conquer : 2T(n/2) - subprogramë“¤ì„ ê°™ì€ ë°©ì‹ìœ¼ë¡œ 
					merge_sort(A, left, middle);
	        merge_sort(A, middle + 1, right);
	
	        // combine : O(n)
					merge(A, left, middle, right);
	    }
	}
	
	item_type *buffer;
	// extra space for merge sort, allocated beforehand
	void merge(item_type *A, int left, int middle, int right)
	{
	    int i, i_left, i_right;
	    memcpy(buffer + left, A + left, 
						 sizeof(item_type) * (right - left + 1));
	    // O(r-l+1), O(n)
	    i_left = left;
	    i_right = middle + 1;
	    i = left;
	
	    while ((i_left &lt;= middle) &amp;&amp; (i_right &lt;= right))
	    {
	        if (buffer[i_left] &lt; buffer[i_right])
	            A[i++] = buffer[i_left++];
	        else
	            A[i++] = buffer[i_right++];
	    }
	    while (i_left &lt;= middle)
	        A[i++] = buffer[i_left++];
	    while (i_right &lt;= right)
	        A[i++] = buffer[i_right++];
	}
	```


	![1](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/1.png)


	![2](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/2.png)

- Space Complexity
	- order of në§Œí¼ì˜ working spaceë¥¼ ì•ˆ ì“°ê³ , input arrayì˜ në§Œ ì¨ì„œ í™œìš©í•  ë•Œ, ê·¸ëŸ° ì•Œê³ ë¦¬ì¦˜ì˜ ê²½ìš° O(n log n)ë§Œí¼ì˜ time complexity ì´ìƒì´ ì°í ìˆ˜ ìˆê² êµ¬ë‚˜.
	- ê°€ëŠ¥ì€ í•˜ë‹¤ : input array O, Working space X
		- inplace merge sortëŠ” êµ‰ì¥íˆ ë³µì¡í•œ ê²ƒìœ¼ë¡œ ì•Œê³  ìˆìŒ.
	- ì‹œê°„ ë³µì¡ë„ë¥¼ ì¦ê°€ì‹œí‚¤ì§€ ì•Šìœ¼ë©´ì„œ, working spaceì˜ ì¶”ê°€ì ì¸ memoryë¥¼ ì•ˆ ì“°ëŠ” ê²ƒ (ìƒìˆ˜ memory ì‚¬ìš©)
	- 
</code></pre></div></div>
<details>
  <summary>In-place merge sort</summary>


[bookmark](https://www.geeksforgeeks.org/in-place-merge-sort/)

- stableì„ ìœ ì§€í•˜ë©´ì„œ working spaceëŠ” linear spaceë§Œ ì“°ëŠ” ê²ƒ â†’ ì–´ë–¤ì‹ìœ¼ë¡œ ìƒê°í•´ì„œ ì ‘ê·¼í•  ê²ƒì¸ê°€? ì¤‘ìš”
- merge í•  ë•Œ ì¶”ê°€ì ì¸ working spaceëŠ” ì•ˆ ì“°ê³ , ìì—°ìŠ¤ëŸ½ê²Œ ìƒê°í•  ìˆ˜ ìˆëŠ” ê²ƒë“¤ :
	- ìì—°ìŠ¤ëŸ¬ìš´ ìƒê°ì´ ë“¤ ìˆ˜ ìˆê²Œ ê¸¸ë“¤ì—¬ì•¼ë§Œ ë³µì¡í•œ ê²ƒì„ í•˜ê³  í•˜ë‚˜í•˜ë‚˜ ìì—°ìŠ¤ëŸ½ê²Œ ìƒê°í•˜ëŠ” ìŠµê´€ ë“¤ì´ê¸°
- Maintain two pointers that point to the start of the segments which have to be merged.
- Compare the elements at which the pointers are present.
- IfÂ _element1 &lt; element2_Â thenÂ _element1_Â is at right position, simply increaseÂ _pointer1_.
- Else shift all the elements between element1 andÂ _element2(including element1 but excluding element2)_Â right by 1 and then place the element2 in the previous place_(i.e. before shifting right)_Â of element1. Increment all the pointers byÂ _1_.

![3](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/3.png)

<details>
  <summary>C++ Code </summary>


```c
// C++ program in-place Merge Sort
#include <iostream>
using namespace std;

// Merges two subarrays of arr[].
// First subarray is arr[l..m]
// Second subarray is arr[m+1..r]
// Inplace Implementation
void merge(int arr[], int start, int mid, int end)
{
	int start2 = mid + 1;

	// If the direct merge is already sorted
	if (arr[mid] &lt;= arr[start2]) {
		return;
	}

	// Two pointers to maintain start
	// of both arrays to merge
	while (start &lt;= mid &amp;&amp; start2 &lt;= end) {

		// If element 1 is in right place
		if (arr[start] &lt;= arr[start2]) {
			start++;
		}
		else {
			int value = arr[start2];
			int index = start2;

			// Shift all the elements between element 1
			// element 2, right by 1.
			while (index != start) {
				arr[index] = arr[index - 1];
				index--;
			}
			arr[start] = value;

			// Update all the pointers
			start++;
			mid++;
			start2++;
		}
	}
}

/* l is for left index and r is right index of the
sub-array of arr to be sorted */
void mergeSort(int arr[], int l, int r)
{
	if (l &lt; r) {

		// Same as (l + r) / 2, but avoids overflow
		// for large l and r
		int m = l + (r - l) / 2;

		// Sort first and second halves
		mergeSort(arr, l, m);
		mergeSort(arr, m + 1, r);

		merge(arr, l, m, r);
	}
}

/* UTILITY FUNCTIONS */
/* Function to print an array */
void printArray(int A[], int size)
{
	int i;
	for (i = 0; i &lt; size; i++)
		cout &lt;&lt;" "&lt;&lt; A[i];
	cout &lt;&lt;"\n";
}

/* Driver program to test above functions */
int main()
{
	int arr[] = { 12, 11, 13, 5, 6, 7 };
	int arr_size = sizeof(arr) / sizeof(arr[0]);

	mergeSort(arr, 0, arr_size - 1);

	printArray(arr, arr_size);
	return 0;
}

// This code is contributed by shivanisinghss2110
```



  &lt;/details&gt;

  &lt;/details&gt;	- 

	## Worst Case Copmlexity of merge sort

	- $O(n^2) $:
	- 
	- An example of merging two arrays
		- left, right ê°ê° $
		\frac n 2$ê°œ

	â†’ ê·¸ë¦¼ìœ¼ë¡œ ë°”ê¾¸ê¸°


		![4](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/4.png)


	## Worst-case time complexity


	![5](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/5.png)


	![6](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/6.png)


	![7](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/7.png)

	- í¸ì˜ìƒÂ $n=2m$ì´ë¼ í•  ê²½ìš° $(m \in Z^+ \cup \{0\}$)
		- $T(n) = 2T(\frac {n} {2}) + cn, n \geq 2$
			- 2 : Number of subproblems
			- $\frac n 2$Â : Subproblem size
		- $T(1)=1Â \rightarrow T(n) = O(nlogn)$
		- Merge Sort Complexity Analysis
	- nê°œì˜ ì›ì†Œë¥¼Â kê°œì™€Â lê°œë¡œ ë‚˜ëˆ„ì–´ ì§„í–‰í•œë‹¤ê³  ê°€ì •í•˜ë©´ ($n=k+l$),
		- $T(n) = T(k) + T(l) + cn (k \approx l)$
		- $n = 2^m$Â ì´ ì•„ë‹Œ ì¼ë°˜ì ì¸ ê²½ìš°ì—ë„ ê°™ì€ ì‹œê°„ ë³µì¡ë„ë¥¼ ê°€ì§ì„ ì¦ëª…í•  ìˆ˜ ìˆìŒ.

	## Solving Recurrence Equations

	- Solve the following recurrencesÂ $T(n)$Â for givenÂ $T(1)=1$
		1. $T(n) = aT(n-1) + bn$
		2. $T(n) = T(\frac n 2) + bn \log n$
		3. $T(n) = aT(n-1) + bn^2$
		4. $T(n) = aT(n/2) + bn^2$
		5. $T(n) = T(\frac n 2) + c \log n$
		6. $T(n) = T(\frac n 2) + cn$
		7. $T(n) = 2T(\frac n 2) + cn$
		8. $T(n) = 2T(\frac n 2) + cn \log n$
		9. $T(n) = T(n-1) + T(n-2)$, forÂ $T(1)=T(2)=1$
	- space complexity : embedded program ë“± ì‚¬ì‹¤ ì œì¼ ì¤‘ìš”í•œ ìš”ì†Œì¤‘ì— í•˜ë‚˜ë¡œì„œ, í˜„ì‹¤ ì‚¬íšŒì—ì„œë„ ë°˜ë“œì‹œ ê°œë°œí•  ë•Œ ê³ ë ¤í•´ì•¼ í•¨

	â†’ Space Complexity : $O(n)$

	- Space complexity : merge sort algorithmì„ êµ¬í˜„í•˜ëŠ”ë° lienar spaceë³´ë‹¤ ë” ì ê²Œ í• ìˆ˜ ìˆë‚˜?
		- ë¶ˆê°€ëŠ¥: ë°ì´í„° input nê°œë¥¼ ëª¨ë‘ ì €ì¥í•´ì•¼í•˜ë‹¤
		- input array O(n)ì´ í•„ìš”í•˜ê³ , ë” í•„ìš”í•œê±´ O(n)ì´ë‹ˆê°€ ì•Œê³ ë¦¬ì¦˜ ê´€ì ì—ì„œ ë¬¸ì œê°€ ë˜ì§€ëŠ” ì•ŠìŒ : O(n)
		- ì‹¤ì œ êµ¬í˜„í•œë‹¤ê³ í•  ë•Œ, ì‹¬ê°í•œ ë¬¸ì œê°€ ë  ìˆ˜ ìˆìŒ.
	- Time complexity : time complexityê°€ ë‚˜ì™”ì„ ë•Œ ì§„ì§œ ì•Œê³ ë¦¬ì¦˜ ì „ê³µí•˜ê±°ë‚˜ ì–´ëŠì •ë„ ìˆ˜ì¤€ì´ ë˜ë©´ ì´ê±°ë³´ë‹¤ ë” ë¹ ë¥¸ ì•Œê³ ë¦¬ì¦˜ì„ ë§Œë“¤ ìˆ˜ ìˆì„ê¹Œ ì‹¶ì„ ê²ƒì„. â†’ $O(n \log n)$ì„ ë„˜ì–´ì„¤ ìˆ˜ëŠ” ì—†ë‹¤.
		- alg - implementationì€ ì„œë¡œ ë‹¤ë¥¸ ì„¸ìƒì´ë‹¤.

	## Some Derivations

	1. T(n) = 2 T(n/2) + cn,Â T(1) = 1
		- assumeÂ $n=2^m$, i.e.,Â $m=\log_2m$Â for someÂ $m \geq 0, m \in \mathbb{Z}$
		- $T(2^m) 
		
		\\= 2T(2^{m-1})+c \cdot 2^mT(2m)
		\\ =2T(2mâˆ’1)+câ‹…2m\\=2{2T(2mâˆ’2)+câ‹…2mâˆ’1}+câ‹…2m
		\\=2^2â‹…T(2mâˆ’2)+2â‹…câ‹…2m\\=2^2{2â‹…T(2mâˆ’3)+câ‹…2mâˆ’2}+2â‹…câ‹…2m...\\=2mâ‹…T(20)+mâ‹…câ‹…2m=nâ‹…1+(\log 2n)â‹…câ‹…n=O(n \log n)$

			$\\= 2 \{2T(2^{m-2})+c \cdot 2^{m-1} \}+c \cdot 2^m$


			$\\=2^2 \cdot T(2^{m-2})+2 \cdot c \cdot 2^m$


			$\\= 2^2 \{2 \cdot T(2^{m-3})+c \cdot 2^{m-2} \}+2 \cdot c \cdot 2^m$


			$\\ ... \\= 2^m \cdot T(2^0) + m \cdot c \cdot 2^m$


			$\\= n \cdot 1 + (log_2 n) \cdot c \cdot n = O(n \log n )$


		![8](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/8.png)

	2. $T(n) = T(n-1) + cn,Â T(1) = 1$
	3. $T(n) = 2 T(n/2) + cn^2,Â T(1) = 1$
		- AssumeÂ $n=2^m$Â for someÂ $m \in \mathbb{Z} - \mathbb {Z^-}$
undefined		- $2 \cdot T (2^{m-1}) + c \cdot 2 ^2m2â‹…T(2mâˆ’1)+câ‹…22m=2$

			$\\ = 2 \{ 2 \cdot T(2^{m-2}) + c \cdot 2 ^{2(m-1)} \} + c \cdot 2 ^2m$


			$\\= 2^2 \cdot T(2^{m-2}) + c \{ 2^{2m-1} + 2 ^{2m}\}$


			$\\ = 2 \{ 2 \cdot T(2^{m-3}) + c \cdot 2 ^{2(m-2)} \} + c \{ 2^{2m-1} + 2^{2m} \}$


			$\\= 2^3 \cdot T(2^{m-3})+ c \{ 2^{2m-2} + 2^{2m-1} + 2 ^{2m}\}$


			$\\ â€¦ \\= 2^m + 2 \cdot c \cdot 2^{2m} - 2 \cdot c \cdot 2^m$


			$\\ =2 \cdot c \cdot n^2 - (2 \cdot c -1) n = O(n^2)$


	## Another Implementation of Merge Sort

	- ref. [Horowitz 7.6.3]

		```c
		typedef struct {
		  int key;
		  int link;
		} element;
		```


		![9](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/9.png)

	- `rmerge`Â returns an integer that points to the start of the sorted list. start = rmerge(list, 0, n-1);

		```c
		int rmerge(element list[], int lower, int upper)
		{
		    /*sort the list, list[lower], ..., list[upper]. 
				// the link field in each record is initially set to -1*/ 
				// list[lower], â€¦, list[upper]ê¹Œì§€ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬.
				// ê° ë ˆì½”ë“œì˜ link filedëŠ” ì´ˆê¸°ì— -1ë¡œ ì„¤ì •int middle;
		    if (lower &gt;= upper)
		        return lower;
		    else
		    {
		        middle = (lower + upper) / 2;
		        return listmerge(list, rmerge(list, lower, middle), rmerge(list, middle + 1, upper));
		    }
		}
		```

	- `listmerge`Â takes two sorted chains, first and second, and returns an integer that points to the start of a new sorted chain that includes the first and second chains.

		```c
		int listmerge(element list[], int first, int second)
		{
		    // firstì™€ secondê°€ ê°€ë¦¬í‚¤ëŠ” ì„œë¸Œë¦¬ìŠ¤íŠ¸ë“¤ì„ í•©ë³‘int start = n;
		    while (first != -1 &amp;&amp; second != -1)
		    {
		        if (list[first].key &lt;= list[second].key)
		        {
		            list[start].link = first;
		            start = first;
		            first = list[first].link;
		        }
		        else
		        {
		            list[start].link = second;
		            start = second;
		            second = list[second].link;
		        }
		    }
		    if (first == -1)
		        list[start].link = second;
		    else
		        list[start].link = first;
		    return list[n].link;
		    // í•©ë³‘ëœ ë¦¬ìŠ¤íŠ¸ì˜ ì‹œì‘ ì¸ë±ìŠ¤ë¥¼ return
		}
		```

		- `listmerge`Â í•¨ìˆ˜ ìˆ˜í–‰ ì˜ˆ start

			![10](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/10.png)


# [ALG] 3.1.2. Quick Sort (1)


	## 3.1.2. Quick Sort

	- comparison sort ì¤‘ í•˜ë‚˜
		- merge sortë³´ë‹¤ worst case  : O(n^2)
		- ì¼ë°˜ì ìœ¼ë¡œ quick sortì˜ ë³€í˜•ì´ ì œì¼ ë¹ ë¥´ë‹¤ê³  ì‹¤í—˜ì„ í†µí•´ ì•Œë ¤ì ¸ ìˆìŒ
	- Pivot strategy
		1. **Divide**
			- Select aÂ **pivot element**, and then divide the array into two subarrays such that ....
				- ì›ì†Œ ì¤‘ í•˜ë‚˜ë¥¼ ë½‘ìŒ
			- ë¹„ìš© : $O(n)$ - ìƒìˆ˜ì‹œê°„ ì•ˆì— ë½‘ê³  ì­‰ nê°œë¥¼ ë³´ë©´ì„œ 15ë³´ë‹¤ í¬ë©´ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ê°€ê³  15ë³´ë‹¤ ì‘ìœ¼ë©´ ì™¼ìª½ ê·¸ë£¹ì— ë°°ì¹˜í•˜ì—¬ ëª¨ìœ¼ëŠ” ì‘ì—… - í•˜ë‚˜ ì”© ê±´ë“œë¦¬ëŠ” ì‘ì—…ì´ë¯€ë¡œ n-1ê°œë¥¼ ë³´ì•„ì•¼ í•¨.
		2. **Conquer**
			- sort each subarray recursively.
			- $T(n_1) + T(n_2)  (n_1 + n_2+1 = n)$
		3. **Combine**
			- do nothing.
			- conquer ê²°ê³¼ë¥¼ ê°–ê³  ì „ì²´ ê²°ê³¼ë¥¼ ë§Œë“¤ì–´ ëƒ„.
			- merge sort: ê° subproblemì„ í•´ê²°í•´ì„œ í•©ì³ ì›ë˜ ë¬¸ì œì˜ í•´ë‹µì„ ì–»ëŠ” ë‹¨ê³„
			- quick sort : ì´ë¯¸ ë‹¤ ì •ë ¬ëœ ì¼€ì´ìŠ¤

		![11](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/11.png)


	![12](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/12.png)

	- merge sort : ê³„ì‚° ê³¼ì •ì—ì„œ binary treeê°€ ë§Œë“¤ì–´ì§€ëŠ”ë°, well-balanced binary treeê°€ ë§Œë“¤ì–´ì§.
		- quick sortì˜ ê²½ìš° well-balenced treeê°€ ì•ˆë  ìˆ˜ë„ìˆê³ , skewed (í•œ ìª½ìœ¼ë¡œ ì¹˜ìš°ì³ì§„) tree
		- worst caseì˜ ê²½ìš° : ë†’ì´ëŠ” $O(n)$ + stack overflowì˜ ê°€ëŠ¥ì„±
			- ì™„ì „ ì •ë ¬ëœ ê²½ìš° ë§¨ ì™¼ìª½ ê²ƒì„ pivotìœ¼ë¡œ ì‚¼ì•˜ì„ ë•Œ
			- ê±°ê¾¸ë¡œ ì •ë ¬ëœ ê²½ìš°
		- ì‹œê°„ë³µì¡ë„ ë“± ì—¬ëŸ¬ ì¸¡ë©´ì—ì„œ well-balancedê°€ skewedë³´ë‹¤ ë‚«ë‹¤.
		- í‰ê· ì ìœ¼ë¡œ ì„ì˜ì˜ ë°ì´í„°ê°€ ë“¤ì–´ì™”ì„ ë•Œ quick sortê°€ ë¹ ë¥´ë‹¤.
	- Quick sort worst case Time Complexity : $O(n^2)$
		- $T(n) = T(n-1) + cn (n\geq 2)$
			- cn : divide cost
			- í•œ ìª½ìœ¼ë¡œë§Œ skewedëœ tree
			- â†’ $T(n) = O(n^2)$
		- $T(n) = 1 (n =1)$
	- average T.c. $O(n \log n)$, worst t.c. : $O(n^2)$
		- ì¼ë°˜ì ìœ¼ë¡œ quick sortê°€ êµ¬í˜„í•˜ëŠ”ë° ìˆì–´ì„œ ë¹ ë¥´ë‹¤
		- merge sort : average, worst - $O(n \log n)$
	- A simple implementation
		- $r-l&gt;0 â†’ r-l+1 &gt;1$
			- 2ê°œ ì´ìƒì˜ ê°œìˆ˜ íŒë³„

		![13](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/13.png)


		```c
		// Sort a list from A[left] to A[right].
		// Should be optimized for higher efficiency!!!
		void quick_sort(item_type *A, int left, int right)
		{
		    int pivot;
		    if (right - left &gt; 0)
		    {
		        // divide
		        pivot = partition(A, left, right);
		        // conquer
						quick_sort(A, left, pivot - 1);
		        quick_sort(A, pivot + 1, right);
		    }
		}
		```


		```c
		#define SWAP(a, b) {
			item_type tmp;
			tmp = a;
			a = b;
			b = tmp;
		}
		
		int partition(item_type *A, int left, int right)
		{
		    int i, pivot;
		    pivot = left; //ì œì¼ ì™¼ ìª½ì— ìˆëŠ” elementë¥¼ pivotìœ¼ë¡œ ì„¤ì •
		    for (i = left; i &lt; right; i++)
		    {
		        if (A[i] &lt; A[right])
		        {
		            SWAP(A[i], A[pivot]);
		            pivot++;
		            // How is the pivot element chosen in this function?
		        }
		    }
		    SWAP(A[right], A[pivot]);
		    return (pivot);
		}
		```


		![14](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/14.png)

		- â†’ ìŠ¤ìŠ¤ë¡œ ì´í•´í•´ë³¼ ê²ƒ

		&gt; â˜€ï¸ ì²« ë²‰ì¬ í”„ë¡œê·¸ë˜ë° ê³¼ì œ  
		&gt; - êµ¬í˜„ê³¼ ì´ë¡  ì‚¬ì´ ê°„ê·¹, ì„±ëŠ¥ ê²€ì •


	# ì§ê´€ì ì¸ ì‹œê°„ ë³µì¡ë„ ì¶”ì •

	- skewedë³´ë‹¤ëŠ” well-balancedê°€ ë” ë‚˜ìŒ
	- $T(n) = T(m_1) + T(m_2) + cn (m_1 + m_2 = n-1)$ if $n&gt;1$
	- $T(1) = 1$
	- â†’ $O(n \log n) \leq T(n) \leq O(n^2)$

	![15](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/15.png)

	- nodeì— ë¶™ì€ ê²ƒì„ ë‹¤ ë”í•˜ë©´ n^2
	- log n *n í•´ì„œ n \log n
	- í‰ê· ì ìœ¼ë¡œ ë´¤ì„ ë•Œ n log n

	# Cost Analysis

	- worst case : $O(n^2) &lt;&lt; $merge, quick sort

	![16](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/16.png)

	- Cost
		- $T(n) = T(m_1) + T(m_2) + cn (m_1 + m_2 = n-1)$ ifÂ $n&gt;1$
	- Analysis
		- Divide : $O(n)$
		- Conquer : $T(m_1)+T(m_2)$
		- Combine : $O(1)$
	- Worst-case time complexity
		- ë§¤ ë‹¨ê³„ì—ì„œ ì„ íƒí•œ pivot elementê°€ ê°€ì¥ í¬ê±°ë‚˜ ê°€ì¥ ì‘ì„ ê²½ìš°,
		- $T(n) = T(0) + T(n-1) + cn, T(1)=1$Â thenÂ $T(n)=O(n^2)$
		- $T(1) = 1$
		- $T(n) = O(n^2)$
		- Skewed vs well-balanced trees
			- 

			![17](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/17.png)

	- Average-case time complexity
		- $T(n) = \sum_{p=1}^n {T(p-1) + T(n-p)} + cn$
		- $T(0) = 1 \rightarrow$
		- $\therefore T(n) = O(n log n)$
		- 

			![18](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/18.png)

	- mathematical induction

		![19](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/19.png)


		![20](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/20.png)


	# Average Case Time Complexity


	### ì²« ë²ˆì§¸ ì‚¬ì‹¤

	- $n \leq 0, \forall n \in \mathbb{Z}, T_{ave}(n)$Â ì„Â nê°œì˜ ì›ì†Œë¥¼ ê°€ì§€ëŠ” ë°°ì—´ì„ í€µ ì •ë ¬ ë°©ë²•ì„ ì‚¬ìš©í•˜ì—¬ ì •ë ¬í•˜ëŠ”ë° ê±¸ë¦¬ëŠ” í‰ê·  ìˆ˜í–‰ì‹œê°„ì´ë¼ê³  í•˜ì. ê·¸ëŸ¬ë¨¼ ì–´ë–¤ ì–‘ì˜ ì •ìˆ˜ bì™€ cì— ëŒ€í•´ ë‹¤ìŒê³¼ ê°™ì€ ì¬ê·€ ê´€ê³„ ì¡´ì¬
		- $T_{ave} (n) \geq cn + \frac {1}{n} \sum_{p=1}^{n} \{ T_{ave} (p-1) + T_{ave} (n-p) \}$
		- $\\= cn + \frac{2}{n} {\sum_{p=0}^{n-1} {T_{ave}(p)}}$
		- $\forall n \geq 2$
	- $T_{ave} (1) \leq b$
	- $T_{ave} (0) \leq b$
	- $Cost_{ave} = \sum_{p=1}^n {P_r (p) \cdot Cost(p)} = \frac {1}{n} \sum_{p=1}^n {... + ...}$

	### ë‘ ë²ˆì§¸ ì‚¬ì‹¤

	- $k=2(b+c)$Â ë¼ í•  ë•Œ, 2ë³´ë‹¤ ê°™ê±°ë‚˜ í° ëª¨ë“  ì •ìˆ˜Â nÂ ì— ëŒ€í•˜ì—¬Â $T_{ave} (n) \leq kn \log_e n$ê³¼ ê°™ì€ ê´€ê³„ ì¡´ì¬
	- ì¦ëª…: ìœ„ì˜ ë¶€ë“±ì‹ì„ ìˆ˜í•™ì  ê·€ë‚©ë²•ì„ ì‚¬ìš©í•˜ì—¬ ì¦ëª…í•˜ì.
		1. $n=2$
			- ì²« ë²ˆì§¸ ì‚¬ì‹¤ë¡œë¶€í„° ë‹¤ìŒê³¼ ê°™ì€ ê´€ê³„ ì„±ë¦½
				- $T_{ave}(2) \leq 2c + T_{ave} (0) + T_{ave} (1) \leq 2(b+c) \leq k \cdot 2 \ log_e 2$
			- âˆ´Â ë”°ë¼ì„œ ë‘ ë²ˆì§¸ ì‚¬ì‹¤ ì„±ë¦½
		2. 3ë³´ë‹¤ ê°™ê±°ë‚˜ í° ì„ì˜ì˜Â n_n_Â ì´ given
			- Assume that :Â m&lt;n_m_&lt;_n_Â ì¸ ëª¨ë“ Â m_m_Â ì— ëŒ€í•˜ì—¬ ë‘ ë²ˆì§¸ ì‚¬ì‹¤ ì„±ë¦½í•œë‹¤ê³  ê°€ì •í•˜ì.
			- ê·¸ëŸ¬ë©´ ì²« ë²ˆì§¸ ì‚¬ì‹¤ê³¼ ì´ ê³¼ì •ì„ ì‚¬ìš©í•˜ì—¬ ë‹¤ìŒê³¼ ê°™ì€ ê´€ê³„ ìœ ë„ ê°€ëŠ¥
			- $T_{ave} (n) \leq cn + \frac {2} {n} \sum_{m=0}^{n-1} {T_{ave} (m)}$
				- $\\ = cn + \frac 2 m \{ T_{ave} (0)+T_{ave} (1) \} + \frac {2} {n} \sum_{m=2}^{n-1} {T_{ave}(m)}$
				- $\\ \leq cn + \frac {4b} n + \frac {2k} n \sum_{m=2}^{n-1} {m log_e m}$
			- ê·¸ëŸ¬ë¯€ë¡œÂ $T_{ave} (n) \leq cn + \frac {2} {n} \sum_{p=0}^{n-1} {T_{ve} (p)}âˆ€nâ‰¥2$
			- $\frac 2 n \Sigma_{m=2}^{n-1} T_{ave} (m) : T_{ave}(m) \leq km \log _e m \leq \frac {2k}{n} \Sigma _{m=2}^{n-1} m \log_e n$
		- í•¨ìˆ˜Â $x \log_e x$ê°€Â x_x_ì— ëŒ€í•˜ì—¬ ì•„ë˜ë¡œ ë³¼ë¡í•œ í•¨ìˆ˜ì´ì–´ì„œÂ $m log_e m \leq \int_m^{m+1} x \log_e x dx$ë¼ëŠ” ì‚¬ì‹¤ì„ ì´ìš©í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì€ ê´€ê³„ì‹ì„ ì–»ëŠ”ë‹¤.
			- $T_{ave} (n)= cn + \frac {4b}n + \frac {2k}n \int_2^n x log_e x dx$
			- $â‰¤cn+n4b+n2k{2n2 \log_enâˆ’4n^2}=kn \log_e n+{cn+n^4bâˆ’2kn}$

				$\\ \leq cn + \frac {4b}{n} + \frac{2k}{n} \{ \frac{n^2 log_e n}{2} - \frac {n^2} 4 \}$


				$\\= knlog_e n + \{ cn + \frac{4b} n - \frac {kn} 2\}$


			&gt; $\int_2^n x log_e x dx =[\frac 1 2 x^2 log_e x - \frac {x^2} 4]_2^n$


				$= (\frac {n^2} 2) log_e n - \frac {n^2} 4 - (2log_e 2 - 1) \leq \frac {n^2} {2} {log_e n} - \frac {n^2} {4}$

		- ì´ ë•Œ,Â $cn + \frac{4b} n - \frac {kn} 2 = (c-\frac k 2 )n + \frac {4b} n = b(\frac 4 n -n)$ ê³¼ ê°™ê³  ì´ ê°’ì€ 2ë³´ë‹¤ ê°™ê±°ë‚˜ í° nì— ëŒ€í•´ í•­ìƒ 0ë³´ë‹¤ ê°™ê±°ë‚˜ ì‘ìœ¼ë¯€ë¡œ $Â T_{ave} (n) \leq kn log_e n$ì´ ë˜ì–´ 3ë³´ë‹¤ ê°™ê±°ë‚˜ í° ì„ì˜ì˜ nì— ëŒ€í•´ì„œë„ ë‘ ë²ˆì§¸ ì‚¬ì‹¤ì´ ì„±ë¦½í•œë‹¤. ë”°ë¼ì„œ 2ë³´ë‹¤ ê°™ê±°ë‚˜ í° ëª¨ë“  ì •ìˆ˜ nì— ëŒ€í•´ ë‹¤ìŒê³¼ ê°™ì€ ë‘ ë²ˆì§¸ ì‚¬ì‹¤ì´ ì„±ë¦½í•œë‹¤.

		![21](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/21.png)


		![22](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/22.png)


		![23](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/23.png)


	## Another Implementation


	&gt; ğŸï¸ ì¤‘ê°„ê³ ì‚¬ ë¹ˆì¹¸ .??? ì½”ë“œê°€ í¸í•´ì§ˆ ë•Œ ê¹Œì§€!


	```c
	void quicksort(element list[], int left, int right)
	{
	    // list[left], â€¦, list[right]ê¹Œì§€ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬.
	    // list[left].keyë¥¼ ì¤‘ì¶” í‚¤(pivot key)ë¡œ ì„ ì •
	    // list[left].key â‰¤ list[right + 1].key ë¼ê³  ê°€ì •
	    int pivot, i, j;
	    element temp;
	    if (left &lt; right)
	    {
	        i = left;
	        j = right + 1;
	        pivot = list[left].key;
	        do
	        {
	            // pivotì„ ì¤‘ì‹¬ìœ¼ë¡œ ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ ë¦¬ìŠ¤íŠ¸ ìƒì„±
	            // ì™¼ìª½ ë¦¬ìŠ¤íŠ¸: pivotë³´ë‹¤ ì ì€ í‚¤ë“¤ì„ ì €ì¥, ì˜¤ë¥¸ìª½ì€ ë°˜ëŒ€do
	            // ì™¼ìª½ë¶€í„° pivotë³´ë‹¤ í° í‚¤ë¥¼ ê²€ìƒ‰
	            i++;
	            while (list[i].key &lt; pivot);
	            do // ì˜¤ë¥¸ìª½ë¶€í„° pivotë³´ë‹¤ ì‘ì€ í‚¤ë¥¼ ê²€ìƒ‰
	                j--;
	            while (list[j].key &gt; pivot);
	            if (i &lt; j)
	                // ê° ë¦¬ìŠ¤íŠ¸ì˜ ì†ì„±ì„ ë§Œì¡±í•˜ë„ë¡ ë°ì´í„° êµí™˜
	                SWAP(list[i], list[j], temp);
	        } while (i &lt; j);
	        SWAP(list[left], list[j], temp);
	        quicksort(list, left, j â€“ 1);
	        // ì™¼ìª½ ë¦¬ìŠ¤íŠ¸ë¥¼ ë‹¤ì‹œ ì •ë ¬
	        quicksort(list, j + 1, right);
	        // ì˜¤ë¥¸ìª½ ë¦¬ìŠ¤íŠ¸ë¥¼ ë‹¤ì‹œ ì •ë ¬
	    }
	}
	
	//code ì•½ê°„ ë‹¤ë¥´ë‹ˆ ìˆ˜ì •
	```


	## Comparison Sorts

	- source: WikiPedia

		![24](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/24.png)

	- ëª»ë‚œì´ ì‚¼í˜•ì œ sort : $O(n^2)$
		- insertion, select, bubble
		- n log n ë°©ë²•ë“¤ì´ ìˆìŒì—ë„ n^2ë¥¼ ê³µë¶€ : ì¥ì ì€ êµ¬í˜„í•˜ê¸° ì‰½ë‹¤. ê·¸ë¦¬ê³  n log n, n^2ëŠ¬ ì°¨ì´ëŠ” nì´ ì»¤ì§ˆ ë•Œ ì°¨ì´ê°€ ë‚˜ëŠ” ê²ƒì´ì§€, 10ê°œ ì¦ˆìŒì´ë©´ ë³µì¡í•˜ê²Œ function callí•˜ë©´ì„œ ì“¸ í•„ìš”ê°€ ì—†ëŠ” ê²ƒì´ë‹¤. ë„ˆë¬´ êµ¬í˜„ì´ ë‹¨ìˆœí•´ì„œ ì˜¤íˆë ¤ ë” ë¹ ë¥¼ìˆ˜ë„ ìˆë‹¤.
		- insertion : ì´ë¥¼ ì´ìš©í•˜ì—¬ quick sortë¥¼ ë” ë¹ ë¥´ê²Œ í•  ìˆ˜ ìˆë‹¤.

	cost comparison


	![25](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/25.png)


	---


	## Improving the Performance of Quick Sort


	<ì²« ë²ˆì§¸="" technique="">

	- How can you select a â€œgoodâ€ pivot element? : pivot elementë¥¼ ì˜ ì„ íƒí•˜ëŠ” ê²ƒì´ ì¤‘ìš”
		- Choose a <u>random</u> element in the list.
		- ê°€ì¥ ì´ìƒì ì¸ ì¼€ì´ìŠ¤ : ChooseÂ **the** <u>**median**</u> **of the first, middle, and final**Â elements in the list.
			- ì„¸ ê°œë§Œ ë³´ì, ë‹¤ì„¯ ê°œë§Œ ë³´ì : constant time
				- ë°ì´í„°ê°€ 11ê°œ ìˆëŠ”ë° ê·¸ ì¤‘ í¬ê¸° ìˆœìœ¼ë¡œë¶€í„° 5ë²ˆì§¸ ê²ƒì„ ì°¾ì•„ë¼ â†’ linear timeì— ë ê¹Œ?
					- linear timeì— ë‹¹ì—°íˆ ëœë‹¤.
					- medianì´ ì•„ë‹ˆë¼ ì„ì˜ì˜ kth elementë¥¼ ì°¾ëŠ” ë¬¸ì œë„ ë‚˜ì¤‘ì— divide and conquerì— ë‚˜ì˜¤ê³ , ë‹¹ì—°íˆ median ì°¾ëŠ” ê²ƒë„ ê°€ëŠ¥
		- ChooseÂ **the** <u>**median**</u> **of the entire elements**Â in the list. (bad idea)
			- ë‹¤ ë³´ì : ìƒìˆ˜ ì‹œê°„ì—ì„œ lienar time (to pick pivot element)
		- ì´ë¡ ì ìœ¼ë¡œëŠ” ì•„ë¬´ ë¬¸ì œ ì—†ìŒ
			- ê·¸ëŸ¬ë‚˜ ê·¸ë§Œí¼ì˜ linear time ë§Œí¼ì´ ì¶”ê°€ë˜ëŠ” ê²ƒì´ê¸° ë•Œë¬¸ì— êµ¬í˜„ ì¸¡ë©´ì—ì„œ ì¢‹ì§€ ì•ŠìŒ
		- Etc.

	![26](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/26.png)

	- Program 7.4. improved quicksort
		- Choosing the median of the first, middle, and final elements as the partitioning element and cutting off the recursion for small subfiles can significantly improve the performance of quicksort.
		- This implementation partitions on the median of the first, middle, and final elements in the array (otherwise leaving these elements out of the partitioning process).
		- Files of size 11 or smaller are ignored during partitioning; then, insertion from is used to finish the sort.

	<ë‘ ë²ˆì§¸="" technique="">

	- if (r - l &lt;= M)  // r-l+1 &lt;= M + 1
		- compilerê°€ ë‹¤ ì—†ì• ì¤Œ : compilerì˜ ìµœì í™”
	- merge sort:
		- í•¨ìˆ˜ì˜ ì‘ë™ ê¸°ì‘ : ì²˜ìŒì— ì „ì²´ì— ëŒ€í•´ì„œ í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ê³ , recursively 1/2ë¡œ ë‚˜ëˆ„ì–´ì§€ë©° ì›ì†Œê°€ 1ê°œì¼ ë•Œ ê¹Œì§€ splitë˜ë©° controlì´ ì™”ë‹¤ê°”ë‹¤í•œë‹¤.
		- stackì— ê° ì •ë³´ë¥¼ ì €ì¥í•´ ë‘ê³  ë‚´ë ¤ê°„ë‹¤.
		- quick sort â†’ insertion
			- ì´ë¹¨ ë¹ ì§€ë“¯ ì¤‘ê°„ì— quicksortê°€ ì´ë£¨ì–´ì§€ì§€ ì•Šì€ ë¶€ë¶„ì— ëŒ€í•´ì„œ

		```c
		#define M
		
		void quicksort(ITEM[] a, int l, int r)
		{
		//ì²« ë²‰ì¬ technique : ì–´ë–»ê²Œ í•˜ë©´ pivotì„ ë” ì¢‹ì€ ê²ƒì„ ë½‘ì„ê°€?
		//ë‘ ë²ˆì§¸ technique : 
		// ì •ë ¬í•˜ë ¤ëŠ” ê°œìˆ˜ r-l+1ì¸ë° ì´ë¥¼ r-l+1 &lt;= M+1 
		// í•´ë‹¹ ë¬¸ì¥ì´ ì˜ë¯¸í•˜ëŠ” ë°” : ì •ë ¬í•˜ê³ ì í•˜ëŠ” ì›ì†Œì˜ ê°œìˆ˜ê°€ ì£¼ì–´ì§„ ìƒìˆ˜ê°’ m+1ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ìœ¼ë©´ ì •ë ¬í•˜ì§€ ë§ê³  ë„˜ì–´ê°€ë¼. m=5, 7, 10, .. ì‚¬ìš©í•˜ëŠ” computing systemì—ì„œ ì‹¤í—˜ì„ í†µí•´ ì–»ì–´ì•¼ í•˜ëŠ” ê°’ (ì ë‹¹íˆ ì‘ì€ ê°’)
		// ì›ì†Œìœ¼ã… ê°œìˆ˜ê°€ 5-6ê°œ ì •ë„ ë˜ë©´ ê·¸ëƒ¥ ë¹ ì ¸ë‚˜ì™€ë¼ : ì •ë ¬ì´ ì•ˆ ëœ ê²½ìš° -&gt;ê±´ë„ˆë›´ ë¶€ë¶„ ìƒê¹€
		// insertion sortë¥¼ ì ìš©í•˜ë©´ ì´ë¡ ì ìœ¼ë¡œëŠ” n^2ì´ì§€ë§Œ ì •ë ¬ ì•ˆ í•˜ê³  ê±´ë„ˆ ë›´ ë¶€ë¶„ë“¤ì´ ìˆì„ ë•Œ ì „ì²´ì ìœ¼ë¡œ sortingì´ ë˜ì–´ ìˆëŠ”ë° ë¶€ë¶„ ë¶€ë¶„ ì •ë ¬ë˜ì§€ ì•Šì€ ë¶€ë¶„ -&gt; linear timeì— ëˆ ë¶€ë¶„
		
		// ì™œ ë¹¨ë¼ì§€ëŠ”ì§€ ìƒê°í•´ ë³´ê³  ì˜¬ ê²ƒ.
		    if (r - l &lt;= M)
		        return;
				// r-l+1 &lt;= M + 1
		
		    exch(a, (l + r) / 2, r - 1);
		    compExch(a, l, r - 1);
		    compExch(a, l, r);
		    compExch(a, r - 1, r);
		    int i = partition(a, l + 1, r - 1);
		//medianì„ ì°¾ì•„ divideí•˜ëŠ” ë‹¨ê³„
		    quicksort(a, l, i - 1);
		    quicksort(a, i + 1, r);
		//ì–‘ ìª½ì— ëŒ€í•˜ì—¬ quick sort
		}
		
		void sort(ITEM a[], int l, int r)
		{
		    quicksort(a, l, r);
		    insertion(a, l, r);
		}
		```

	- How can you minimize the bookkeeping cost involved in the recursive calls?
		- Much of the pushing and popping of the frame stack is unnecessary.
		- Lists of size smaller than M are ignored during quick sort, then do a single sorting pass at the end.
		- depthë§Œí¼ì˜ stack í•„ìš”í•¨
		- í•œì—†ì´ ì¤„ì¤„ ë‚´ë ¤ê°€ëŠ” recursive function call : skewedë˜ì–´ì„œ ì¤„ì¤„ì´ ë‚´ë ¤ê°€ëŠ” ì¼€ì´ìŠ¤ì˜ ê²½ìš° systemì—ì„œ stack overflow

	![27](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/27.png)

	- How can you minimize the bookkeeping cost involved in the recursive calls?
		- pivot element: ì œì¼ ì™¼ ìª½ì— ìˆëŠ” ê²ƒì„ ê°–ê³  ì‹¶ë‹¤
		- ì‘ì€ ìª½ì— ëŒ€í•´ì„œëŠ” recursivesy
			- í° ìª½ : ì†ë„ë³´ë‹¤ëŠ” í° ë°ì´í„°ì— ì•Œë§ê²Œ
		- Avoid making the recursive call on the larger subrange.
		- The depth of recursion $\leq O(\log n)$

	```c
	quicksortTRO(E, first, last)
	{
	  int first1, last1, first2, last2;
	  first2 = first;
	  last2 = last;
	  while (last2 - first2 &gt; 1)
	  {
	
	      pivotElement = E[first];
	      pivot = pivotElement.key;
	      int splitPoint = partition(E, pivot, first2, last2);
	      E[splitPoint] = pivotElement;
	      if (splitPoint &lt; (first2 + last2) / 2)
	      {
	          first1 = first2;
	          last1 = splitPoint - 1;
	          first2 = splitPoint + 1;
	          last2 = last2;
	      }
	      else
	      {
	          first1 = splitPoint + 1;
	          last1 = last2;
	          first2 = first2;
	          last2 = splitPoint - 1;
	      }
	      quicksortTro(E, first1, last1);
	// continue loop for fist2, last2.
	  }
	  return;
	}
	
	
	```


	![28](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/28.png)


	## Example: Quick Sort


	By courtesy of David R. Musser

	- Average-case: $O(n \log n)$
	- Worst-case:Â $O(n^2)$

		![29](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/29.png)

	- ì½”ë“œ ìƒì—ì„œëŠ” ë³„ ì°¨ì´ ì—†ì§€ë©´ simulationì—ì„œëŠ” ì—ëŸ¬ê°€ ë‚  ìˆ˜ë„ ìˆë‹¤.
		- tech 1,2, 3

	## Performance Comparisons

	- 

	![30](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/30.png)


	## Quicksort: Implementation 2 [K. Loudon]


	```c
	#include <stdlib.h>
	#include <string.h>
	#include "sort.h"
	static int compare_int(const void *int1, const void *int2)
	{
	    // Compare two integers (used during median-of-// three partitioning
			if (*(const int *)int1 &gt; *(const int *)int2)
		    return 1;
	
	    else if (*(const int *)int1 &lt; *(const int *)int2) 
			return -1;
	
	    else return 0;
	}
	
	static int partition(void *data, int esize, int i, int k, int (*compare)(const void *key1, const void *key2))
	{
	    char *a = data;
	    void *pval, *temp;
	    int r[3];
	    /*  Allocate storage for the partition value and swapping. */
	    if ((pval = malloc(esize)) == NULL)
	        return -1;
	    if ((temp = malloc(esize)) == NULL)
	    {
	        free(pval);
	        return -1;
	    }
	    /* Use the median-of-three method to find the partition value.  */
	    r[0] = (rand() % (k - i + 1)) + i;
	    r[1] = (rand() % (k - i + 1)) + i;
	    r[2] = (rand() % (k - i + 1)) + i;
	    issort(r, 3, sizeof(int), compare_int);
	    memcpy(pval, &amp;a[r[1] * esize], esize);
	    /* Create two partitions around the partition   value.  */
	    i--;
	    k++;
	    while (1)
	    {
	        /* Move left until an element is found in the wrong partition. */
	        *do { k--; }
	        while (compare(&amp;a[k * esize], pval) &gt; 0)
	            ;
	        /* Move right until an element is found in the wrong partition. */ do
	        {
	            i++;
	        } while (compare(&amp;a[i * esize], pval) &lt; 0);
	
	        if (i &gt;= k)
	        {
	            break;
	        }
	        /* Stop partitioning when the left and right counters cross. */ else
	        {
	            /* Swap the elements now under the left and   right counters.  */ memcpy(temp, &amp;a[i * esize], esize);
	            memcpy(&amp;a[i * esize], &amp;a[k * esize], esize);
	            memcpy(&amp;a[k * esize], temp, esize);
	        }
	    }
	
	    /* Free the storage allocated for
	         partitioning. */
	    free(pval);
	    free(temp);
	    /* Return the position dividing the two partitions. */ return k;
	}
	
	int qksort(void *data, int size, int esize, int i, int k, int (*compare)(const void *key1, const void *key2))
	{
	    int j;
	    /* Stop the recursion when it is not possible
	         to partition further. */
	    if (i &lt; k)
	    {
	        // Determine where to partition the elements
	        if ((j = partition(data, esize, i, k, compare)) &lt; 0)
	            return -1;
	        // Recursively sort the left partition
	        if (qksort(data, size, esize, i, j, compare) &lt; 0)
	            return -1;
	
	        // Recursively sort the right partition
	        if (qksort(data, size, esize, j + 1, k, compare) &lt; 0)
	            return -1;
	    }
	
	    return 0;
	}
	```


# [ALG] 3.1.3. Insertion Sort (1)


	## Insertion Sort: Example 1


	ë§¤ë²ˆ for loopì´ ëŒ ë•Œë§ˆë‹¤ ì •ë ¬ëœ stackì´ ë‹¤ì‹œ ì •ë ¬ë¨


	![31](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/31.png)

	- ì •ë ¬ëœ ë°°ì—´ì´ ëì— ê°€ì„  ë‹¤ ì •ë¦¬ë¨.
	- comparison sort : nlog në³´ë‹¤ ë” ë¹¨ë¦¬ í• ìˆ˜ ì—†ë‹¤ê³  ì¦ëª…ë˜ì–´ ìˆìŒ.
	- $O(n^2)$ : worst case time complexity
		- $1+2+3+ ... + (n-1)$
		- ì²˜ìŒì— 15 ë¹„êµ â†’ 10, 15 ë¹„êµ, â€¦
		- ì œì¼ ì˜¤ë¥¸ìª½ì• ë‘ë¹„êµí•˜ì—¬ ë‚˜ë³´ë‹¤ í¬ë©´ì˜¤ë¥¸ìª½ìœ¼ë¡œ ê°€ë¼, ì‘ìœ¼ë©´ ì™¼ìª½ìœ¼ë¡œ ê°€ë¼
	- best case time complexity
		- 1 + 1 + â€¦ + 1 = n-1 = O(n) - linear time
	- inp place algorithm

	## Insertion Sort: Example 2


	![32](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/32.png)

	- ì „ì²´ì ìœ¼ë¡œëŠ” ì •ë ¬ ì˜ ëœ ê²ƒì²˜ëŸ¼ ë³´ì´ì§€ë§Œ ì¤‘ê°„ì— ì˜ ì•ˆëœ ì¼€ì´ìŠ¤ ì¡´ì¬
		- worst caseëŠ” o(n^2)ì´ì§€ë§Œ linearì²˜ëŸ¼ ëŒì•„ê°€ê²Œ ë¨.
			- nì´ 100ë§Œ ì¼ ë•Œ ì—„ì²­ë‚˜ê²Œ í° ì°¨ì´ ì¡´ì¬
	- Insertion :Â $O(n+d)$ in the worst case over sequences that have d inversions
	- When does the insertion sort run fast?
	- ì´ëŸ¬í•œ insertion sortì˜ ì„±ì§ˆì„ quick sortì˜ ì„±ëŠ¥ í–¥ìƒì— í™œìš©í•˜ì.
		- ì´ëŸ¬í•œ insertion sortì˜ ì„±ì§ˆì„ ì´ìš©í•´ì„œ quick sortë¥¼ ë” ë¹ ë¥´ê²Œ ì–´ë–»ê²Œ í•  ê²ƒì¸ê°€? (practical êµ¬í˜„ ê´€ì )
			- 

	## Implementation


	```c
	void insertion_sort(int *A, int n)
	{
	    int i, j, tmp;
	    for (i = 1; i &lt; n; i++)
	    {
	        tmp = A[i];
	        j = i;
	        while ((j &gt; 0) &amp;&amp; (tmp &lt; A[j - 1]))
	        {
	            A[j] = A[j - 1];
	            j--;
	        }
	        A[j] = tmp;
	    }
	}
	```

	- Sort a list of elements by iteratively inserting a next element in a progressively growing sorted array.

		```c
		#include <stdlib.h>
		#include <string.h>
		#include "sort.h"
		int issort(void *data, int size, int esize, int (*compare)(const void *key1, const void *key2))
		{
		    char *a = data;
		    void *key;
		    int i, j; // Allocate storage for the key element.
		    if ((key = (char *)malloc(esize)) == NULL)
		        return -1;
		    // Repeatedly insert a key element among the sorted elements.
		    for (j = 1; j &lt; size; j++)
		    {
		        memcpy(key, &amp;a[j * esize], esize);
		        i = j - 1;
		        // Allocate storage for the key element.
		        if ((key = (char *)malloc(esize)) == NULL)
		            return -1;
		        // Repeatedly insert a key element among the sorted elements.
		        for (j = 1; j &lt; size; j++)
		        {
		            memcpy(key, &amp;a[j * esize], esize);
		            i = j - 1;
		            /* Determine the position at which to insert the key element. */ while (i &gt;= 0 &amp;&amp; compare(&amp;a[i * esize], key) &gt; 0)
		            {
		
		                memcpy(&amp;a[(i + 1) * esize], &amp;a[i * esize], esize);
		                i--;
		            }
		            memcpy(&amp;a[(i + 1) * esize], &amp;a[i * esize], esize);
		            i--;
		        }
		        memcpy(&amp;a[(i + 1) * esize], key, esize);
		    }
		    // Free the storage allocated for sorting.free(key);
		    return 0;
		}
		```


	## Run-Time Analysis

	- Worst case
		- No. of comparisons:
			- $1+2+ ...+n-1 = O(\frac {n^2}{2})$ : ì™„ì „íˆ ë’¤ì§‘í˜€ì§„ ê²½ìš° ìµœì•…
		- No. of record assignments:
			- $1+2+ ...+n-1 = O(\frac {n^2}{2})+2(n-1)$
				- ì™œ 2ê°€ ë¶™ëŠ”ê°€ :

		![33](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/33.png)


		![34](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/34.png)

	- Average case
		- No. of comparisons

			$\sum_{i=1}^{n-1} {\frac{1+2+...+i+i}{i+1} } =\sum_{i=1}^{n-1} {(\frac{i}{2}+1-\frac{1}{i+1})}$


			$\approx \frac{(n-1)(n+4)}{4} - \ln n = O(\frac{n^2} 4)$

		- No. of record assignments

			$\sum_{i=1}^{n-1} {\frac{0+1+2+...+i}{i+1} +2} = \frac{n(n-1)}{4}+2(n-1) = O(\frac{n^2}4)$

			- 0ë²ˆìœ¼ë¡œ ì‹œì‘í•´ì„œ 8ë²ˆì§¸ì— insert : í™•ë¥ ì ìœ¼ë¡œ ìœ„ì¹˜ëŠ”

			![35](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/35.png)


	## Example (skip)


	![36](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/36.png)


# [ALG] 3.1.4. Selection Sort (1)


	## Implementation

	- $T(n) = O(n^2)$

		```c
		#define SWAP(a, b) {
		    item_type tmp;
		    tmp = a;
		    a = b;
		    b = tmp;
		}
		
		void selection_sort(item_type *A, int n)
		{
		    int i, j, cur;
		
		    for (i = 0; i &lt; n - 1; i++)
		    {
		        cur = i;
		        for (j = i + 1; j &lt; n; j++)
		            if (A[j] &lt; A[cur])
		                cur = j;
		        SWAP(A[i], A[cur]); // what if i == cur? }
		    }
		}
		```


	## Example


	![37](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/37.png)


	## Run-Time Analysis

	- Worst case
		- No. of comparisons

			$\sum_{i=0}^{n-2} (n-i-1) = \frac {n(n-1)} 2 = O (\frac {n^2} {2})$

		- No. of record assignments

			$3(n-1) = O(3n)$

	- Average case
		- No. of comparisons

			$\sum_{i=0}^{n-2} (n-i-1) = \frac {n(n-1)} 2 = O (\frac {n^2} {2})$

		- No. of record assignments

			$3(n-1) = O(3n)$

	- [ìƒê°í•´ë³´ê¸°] If we code like â€œif (i != cur) SWAP(A[i], A[cur]);â€, what is the average cost?

# [ALG] 3.1.5. Bubble Sort (1)


	## Example


	![38](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/38.png)


	## Implementation


	```c
	#define SWAP(a, b) {
			item_type tmp;
			tmp = a;
			a = b;
			b = tmp;
	}
	
	void bubble_sort(item_type *A, int n)
	{
	    int i, j;
	
	    for (i = 0; i &lt; n - 1; i++)
	    {
	        for (j = n - 1; j &gt; i; j--)
	        {
	            if (A[j] &lt; A[j - 1])
	                SWAP(A[j], A[j - 1]);
	        }
	    }
	}
	```


	![39](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/39.png)


	## Run-Time Analysis

	- Refer to The Art of Computer Programming (Vol. 3)
	- Worst Case
		- No. of comparisons

			$\sum_{i=1}^{n-1} (n-1-i) = \frac {n(n-1)} 2 = O (\frac {n^2} {2})$

		- No. of record assignments

			$\sum_{i=1}^{n-1} 3i = \frac 3 2 n(n-1)= O (\frac {3} {2} n^2)$

	- Average case
		- No. of comparisons

			$\sum_{i=1}^{n-1} (n-1-i) = \frac {n(n-1)} 2 = O (\frac {n^2} {2})$

		- No. of record assignments

			$\frac 1 2 \sum_{i=1}^{n-1} 3i = \frac 3 2 n(n-1)= O (\frac {3} {4} n^2)$


# [ALG] 3.1.6. Cost Comparison (1)

	- 

	![40](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/40.png)

	- # of comparisons
		- Insertion
			- (average) $\frac {n^2} 4$
			- (worst) $\frac{n^2} 2$
		- Bubble
			- (average) $\frac{n^2}{2} $
			- (worst) $\frac{n^2}2$
		- selection : $\frac{n^2}2$
	- # of record assignments
		- Insertion
			- (average) $\frac{3n^2} 4$
			- (worst) $\frac{n^2}2$
		- Bubble
			- (average) $\frac 4 3n^2$
			- (worst) $\frac{3n^2}2$
		- selection : $3n$

	## Comparison Sorts


	[https://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms](https://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms)


	![41](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/41.png)


	## Performance Comparisons

	- By courtesy of David R. Musser
	- 

		![42](/assets/img/2022-09-19-[ALG]-3.1.-Sorting.md/42.png)

</string.h></stdlib.h></string.h></stdlib.h></ë‘></ì²«></iostream></details></details>

  </div><a class="u-url" href="/ALG-3.1.-Sorting" hidden></a>
</article>


      </div>
    </main><footer>
  <hr style="margin-left: 15px; color: #000 !important; background-color: #000 !important; opacity: 1 !important; width: 40px; height: .5px !important; margin-bottom: 2rem !important;">
  <div class="row m-0">
    <div class="col-12 col-md-3 col-sm-4 mb-4 mb-sm-0">
      <p>
        <a href="https://github.com/underthelights/underthelights.github.io" style="font-weight: 300">Kyuhwan Shim</a>
        <br>Up-to-date as of <span id="date">loading...</span></p>
      <i class="fas fa-location-dot mr-1"></i> Seoul is <img style="width: auto; height: 23px;" id="weather_icon">
      <span id="weather">Loading...</span>
    </div>
    <div class="col-12 col-md-9 col-sm-8">
      <p>
        <a style="font-weight: 300" href="https://linkedin.com/in/kyuhwan-shim"><i class="fab fa-linkedin" style="margin-right: 10.5px"></i>LinkedIn</a><br>
        <a style="font-weight: 300" href="https://fb.com/s.kyuhwn"><i class="fab fa-facebook" style="margin-right: 8px"></i>Facebook</a><br>
        <a style="font-weight: 300" href="https://www.instagram.com/s.kyuhwn"><i class="fab fa-instagram" style="margin-right: 10.5px"></i>Instagram</a><br>
        <a style="font-weight: 300" href="https://github.com/underthelights"><i class="fab fa-github" style="margin-right: 10.5px"></i>GitHub</a><br>
      </p>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.18.1/moment.min.js"></script>

<script src="/assets/js/weather.js"></script>
<script src="/assets/js/github_date.js"></script>
</body>

</html>

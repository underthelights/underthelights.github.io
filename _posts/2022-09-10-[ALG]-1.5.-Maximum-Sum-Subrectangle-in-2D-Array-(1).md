---
layout: post
date: 2022-09-10
title: "[ALG] 1.5. Maximum Sum Subrectangle in 2D Array (1)"
tags: [Algorithm, ]
categories: [Notes, ]
---


# Maximum Sum Subrectangle in 2D Array


= max sum submatrix


2ì°¨ì› arrayê°€ ìˆì„ ë•Œ í•©ì„ ì œì¼ ìµœëŒ€ë¡œ ë§Œë“¤ê²Œ í•˜ëŠ” subrectangleì„ ì°¾ì•„ë¼.

- empty subrectangle í—ˆìš©
	- ëª¨ë‘ ìŒìˆ˜ë©´ 0
- empty subrectangle ë¹„í—ˆìš©
	- ëª¨ë‘ ìŒìˆ˜ë¼ë©´ ì ˆëŒ“ê°’ì´ ì œì¼ ì‘ì€ ê²ƒ ì„ íƒ
- í–‰ì´ mê°œ, ì—´ì´ nê°œ :
	- nììŠ¹ê°œê°€ ì¡´ì¬í•œë‹¤ê³  í–‡ëŠ”ë°, orderë¡œ subrectangleì´ ëª‡ ê°œ ì¡´ì¬í•  ê²ƒì¸ê°€?
	- 
- Problem
	- Given an mxn array of integers, find a subrectangle with the largest sum. (In this problem, we assume that a subrectangle isÂ **any contiguous sub-array of size 1x1 or greater**Â located within the whole array.)
- Note
	- What is the input size of this problem?
		- $(m, n)$
		- If $m = nâ†’n$
		- problem sizeë¥¼ (n,n) í• ìˆ˜ë„ ìˆê³ 
	- How many subrectangles are there in an mxn array?
	- For the case of $m = n$,
		- Design anÂ $O(n^6)$Â algorithm.
		- Design anÂ $O(n^5)$Â algorithm.
		- Design anÂ $O(n^4)$Â algorithm.
		- Design anÂ _O_(_n_3)Â algorithm.

			O(n^3)

- ê°ê°ì˜ $(i,j,k,l)$ì— ì˜í•´ í•˜ë‚˜ê°€ ì •ì˜ :
- How many subrectangles are there in an mxn array?
	- [1D case] for anÂ m * n_m_âˆ—_n_Â rectangle,

		$\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} \sum_{k=0}^{m-1} \sum_{l=k}^{m-1} 1$


		$= (\sum_{k=0}^{m-1} \sum_{l=k}^{m-1} 1)(\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} 1)$


		$= { \sum_{k=0}^{m-1}(m-k)}{\sum_{i=0}^{n-1}{(n-i)}}$


		$= \frac {m(m+1)} {2} \frac {n(n+1)} {2} = O(m^2 n^2) = O(n^4)$Â ifÂ $m=n$


## A NaiÌˆve Approach

- For each subrectangle, find its sum.
- [ê°€ì •]Â $n=m$

	$\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} \sum_{k=0}^{m-1} \sum_{l=k}^{m-1} (j-i+1)(l-k+1) = \sum_{i=0}^{n-1} \sum_{j=i}^{n-1} {(j-i+1)} \sum_{k=0}^{m-1} \sum_{l=k}^{m-1} {(l-k+1)}$


	âˆ‘_i_=0_n_âˆ’1âˆ‘_j_=_in_âˆ’1âˆ‘_k_=0_m_âˆ’1âˆ‘_l_=_km_âˆ’1(_j_âˆ’_i_+1)(_l_âˆ’_k_+1)=âˆ‘_i_=0_n_âˆ’1âˆ‘_j_=_in_âˆ’1(_j_âˆ’_i_+1)âˆ‘_k_=0_m_âˆ’1âˆ‘_l_=_km_âˆ’1(_l_âˆ’_k_+1)


	letÂ $A =\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} {(j-i+1)}$


	$A = 1*n + 2*(n-1) +3(n-2) + ... + n*1A=1âˆ—n+2âˆ—(nâˆ’1)+3(nâˆ’2)+...+nâˆ—1 = \sum_{i=1}^{n} {i(n-i+1)} = n \sum_{i=1}^n i - \sum_{i=1}^n i^2 + \sum_{i=1}^n i = \frac{1}{6} n^3$

	- soÂ $O(\frac{1}{36} n^6 )$
undefined- Time Complexity :Â $O(n^6)$
- inefficient algorithm

## MSS : Summed Area Table

- memory ìì²´ë„ resourceì´ê¸° ë•Œë¬¸ì— í•­ìƒ ë§ì´ ì“°ëŠ” ê²ƒì´ ì¢‹ì€ ê±´ ì•„ë‹ˆì§€ë§Œ, summed area tableì´ë¼ëŠ” memoryë¥¼ í•˜ë‚˜ ì¨ì„œ ë¬¸ì œë¥¼ í’€ê²Œ ëœë‹¤.
- Table construction:Â $O(n^2)$
	- ê° ì›ì†ŒëŠ” ëŒ€ì‘ë˜ëŠ” ì˜ì—­ì˜ í•©ì´ ê° ëŒ€ì‘ë˜ëŠ” ìœ„ì¹˜ì— ì§€ì •í•œë‹¤ : ìˆœì„œëŒ€ë¡œ ì­‰ ì›ì†Œë“¤ì„ í›‘ìœ¼ë©° ê³„ì‚°í•œë‹¤. ì´ë¥¼ ê³„ì‚°í•˜ë©´ ë‚´ê°€ í›‘ì–´ì•¼ í•˜ëŠ” ì›ì†Œì˜ ê°œìˆ˜ê°€ n^2ë§Œí¼ ìˆë‹¤. ê°ê°ì˜ ì›ì†ŒëŠ” ìƒìˆ˜ ì‹œê°„ì— ê³„ì‚°ë˜ì–´ì•¼ í•œë‹¤.
	- n^2ì— ëŒ€í•´ì„œ ê³„ì‚°í•˜ë ¤ê³  í•˜ëŠ”ë°, ê°ê°ì„ ìƒìˆ˜ ì‹œê°„ ì•ˆì— ê³„ì‚°í•˜ì—¬ì•¼ í•œë‹¤.
	- 
- Sum comparisons:$O(n^4)$
- Time Complexity :Â $O(n^4)$

	![0](/assets/img/2022-09-10-[ALG]-1.5.-Maximum-Sum-Subrectangle-in-2D-Array-(1).md/0.png)

	- preprocessë¥¼ í†µí•´ tableì˜ ë‚´ìš©ì„ ì±„ìš¸ ê²ƒì´ë‹¤.
	- $(i,j,k,l)$ì— í•´ë‹¹í•˜ëŠ” ê²ƒì´ $n^4$ê°œë§Œí¼ ë‚˜ì˜¤ëŠ”ë°, ê·¸ ì˜ì—­ì— ëŒ€í•œ í•©ì„ ê³„ì‚°í•´ì„œ ì‚¬ê°í˜•ì˜ í•© ì¤‘ ì œì¼ í° ê²ƒì„ ì„ íƒí•˜ë©´ ë¨.
	- $S(i,j,k,l) = T(l,j) - T(k-1, j) + T(k, j-1) + T (k-1. i-1)$
		- constant time : ê° ì‚¬ê°í˜•ì— ëŒ€í•œ ê³„ì‚°
		- ì‚´í´ë´ì•¼ í•  ê²ƒë“¤ì€ $n^4$ê°œ ì¡´ì¬í•˜ë‹ˆê¹Œ.
- ë¬¸ì œ : ì§€ê¸ˆê¹Œì§€ëŠ” time complexityë¥¼ ë”°ì¡Œì§€ë§Œ ë¬¸ì œëŠ” space complexity
	- input data : @n^2 ë§Œí¼ì˜ ìë¦¬ë¥¼ ì°¨ì§€í•¨.
		- â†’ ëª¨ë°”ì¼ SWë¥¼ ê°œë°œí•œë‹¤ : input data ë§ê³ ë„ ì„±ëŠ¥ì´ ë‚®ê±°ë‚˜ memory size ì‘ê±°ë‚˜ access ëŠë¦° cpuì— ëŒ€í•´ì„œëŠ” ì•ˆ ì¢‹ì„ìˆ˜ ìˆë‹¤. ì‹œìŠ¤í…œ ë¶€ë‹´ì´ ë˜ëŠ” ìƒí™© ë°œìƒ ê°€ëŠ¥
	- time complexity : nì¸ ë¬¸ì œë¥¼ í‘¸ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„
	- space complexity : ë¬¸ì œ í‘¸ëŠ”ë° ê±¸ë¦¬ëŠ” ë©”ëª¨ë¦¬
		- ë¬¸ì œ ì‚¬ì´ì¦ˆ nì— ëŒ€í•´ì„œ $n^4$
	- 

### Maximum Sum Subrectangle: Kadane Algo.-Based


> ğŸ’¡ n^3ì— í•´ë³´ì

- ë¶„ëª…íˆ MSSì¸ rectangleì´ ì¡´ì¬í•˜ëŠ”ë°, iì—ì„œ ì‹œì‘í•´ì„œ jë¡œ ëë‚¨ : ê·¸ëŸ¬ë©´ ì´ì œ ì–´ë–¤ ì‹ìœ¼ë¡œ ë¬¸ì œë¥¼ ë°”ë¼ë³¼ ê²ƒì´ëƒ : $0 \leq i \leq j \leq n-1$ì´ ê°€ëŠ¥í•œ pair
	- ië²ˆì§¸ ì—´ì—ì„œ jë²ˆì§¸ë¡œ ëë‚˜ëŠ” ëª¨ë“  ê°€ëŠ¥í•œ rectangleì„ ì‚´í´ë³´ì.
	- ê°€ëŠ¥í•œ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” i,j â†’ n^2ë§Œí¼ ì¡´ì¬í•¨.
	- ëª¨ë“  ê°€ëŠ¥í•œ i, jì— ëŒ€í•´ì„œ ií–‰ì—ì„œ ì‹œì‘í•˜ê³  jì—´ì—ì„œ ëë‚˜ëŠ” mssë¥¼ ì°¾ì•„ë³´ì.
	- columnì´ i, jë²ˆì§¸ì— ëë‚˜ëŠ” : í•©ì´ ì œì¼ í° ê²ƒì„ ì°¾ì. ë¼ê³  ì ‘ê·¼
	- ë§Œì•½
		- temp arrayë¥¼ ë§Œë“¤ì–´ì„œ ì„ì˜ì˜ ì£¼ì–´ì§„ i, jì— ëŒ€í•´ì„œ ì²« ë²ˆì¬ ì›ì†ŒëŠ” 1 í–‰, 2ë²ˆì§¸ ì›ì†ŒëŠ” 2í–‰, â€¦ ì„ ëª¨ë‘ ì €ì¥í•´ ë†“ì€ ê°’ì„ ì €ì¥í•´ ë‘ì—ˆë‹¤ê³  í•˜ì.
		- ì£¼ì–´ì§„ i, jì— ëŒ€í•´ì„œ í–‰ ì—´ì´ iì—ì„œ ì‹œì‘í•´ì„œ jë¡œ ëë‚˜ëŠ” subrectangle ì¤‘ ì œì¼ í° ê²ƒì€ ì–´ë–»ê²Œ ì°¾ì„ ìˆ˜ ìˆì„ê¹Œ.
		- 1ì°¨ì› sequenceì—ì„œ í•©ì„ ì œì¼ í¬ê²Œ í•˜ëŠ” mssë¥¼ ì°¾ìœ¼ë©´ ëœë‹¤.

	> ğŸ’¡ ëª¨ë“  ê°€ëŠ¥í•œ (i,j) pairì— ëŒ€í•´ì„œ ë³¼ ê²ƒì´ë‹¤.  
	> ë°”ê¹¥ì—ì„œ for loopì´ ëŒ ë•Œ ì €ë§Œí¼ ì¡´ì¬í•œë‹¤.  
	> ê° í–‰ì— ìˆëŠ” ê²ƒë“¤ì„ ë‹¤ ë”í•´ë‘ë©´ (temp) â†’ iì—´ì—ì„œ ì‹œì‘í•´ì„œ jë¡œ ëë‚˜ëŠ” ê°€ëŠ¥í•œ rectangleì„ ë§Œë“ ë‹¤. í•©ì´ ì œì¼ í° ê²ƒì€ tempê°€ ìˆê¸° ë•Œë¬¸ì—, linear timeì— í•©ì´ ì œì¼ í° subsequenceë¥¼ ì°¾ìœ¼ë©´ ë°”ë¡œ kí–‰ë¶€í„° lí–‰ê¹Œì§€ ì •ì˜ë˜ëŠ” ì‚¬ê°í˜•ì´ Maximum sumì´ ë˜ë”ë¼.

	- ë‹¤ì‹œ ì´ì–‘ê¸°í•˜ì§€ë§Œ, ì¡°ê±´ ë§Œì¡±í•˜ëŠ” ìŒì´ i,jê°œ ì¡´ì¬í•˜ë‹ˆê¹Œ linear timeì— ê³„ì‚°í•  ìˆ˜ ìˆìœ¼ë©´
	- ê°ê°ì„ nì— ëŒ€í•´ì„œ ê³„ì‚°í•˜ë©´ $n^3$ì´ ë‚˜ì˜¨ë‹¤.
- Idea
	- ref.Â [geeksforgeeks](https://www.geeksforgeeks.org/maximum-sum-rectangle-in-a-2d-matrix-dp-27/)
	- MSS(2D)ì˜ í•´ë‹¹ ì—´ì€ ì–´ë””ì´ê±´ iì—ì„œ jê¹Œì§€ ì„.
	- ê°€ëŠ¥í•œ ëª¨ë“  (i, j) ì¡°í•©ì— ëŒ€í•˜ì—¬ MSS(1D)ë¥¼ Kadane ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ì°¾ìŒ.
	- ê·¸ë ‡ê²Œ í•˜ê¸° ìœ„í•˜ì—¬, ...

		![1](/assets/img/2022-09-10-[ALG]-1.5.-Maximum-Sum-Subrectangle-in-2D-Array-(1).md/1.png)

- ì–´ë–¤ ì‹ìœ¼ë¡œ êµ¬í˜„í• ì§€ ë³´ì—¬ì•¼ êµ¬í˜„í•  ê²ƒì¸ë° ìê¾¸ ê²½í—˜ì„ í†µí•´ì„œ ëª¸ì— ë°°ë©´ êµ¬êµ¬ë‹¨ ì™¸ìš°ë“¯ì´ ê°„ë‹¤.
- C Implementation
	- left, right : $n^2$ë§Œí¼ ëˆë‹¤
	- 

	```c
	// Program to find maximum sum subarray
	// in a given 2D array
	#include <stdio.h>
	#include <iostream>
	#include <string.h>
	using namespace std;
	#define INT_MAX 2147483647
	#define INT_MIN 2147483648
	#define ROW 4
	#define COL 5
	
	// Implementation of Kadane's algorithm for
	// 1D array. The function returns the maximum
	// sum and stores starting and ending indexes
	// of the maximum sum subarray at addresses
	// pointed by start and finish pointers
	// respectively.
	int kadane(int *arr, int *start, int *finish, int n)
	{
	    // initialize sum, maxSum and
	    int sum = 0, maxSum = INT_MIN, i;
	
	    // Just some initial value to check
	    // for all negative values case
	    *finish = -1;
	
	    // local variableint
	    local_start = 0;
	
	    for (i = 0; i < n; ++i)
	    {
	        sum += arr[i];
	        if (sum < 0)
	        {
	            sum = 0;
	            local_start = i + 1;
	        }
	        else if (sum > maxSum)
	        {
	            maxSum = sum;
	            *start = local_start;
	            *finish = i;
	        }
	    }
	
	    // There is at-least one
	    // non-negative number
	    if (*finish != -1)
	        return maxSum;
	
	    // Special Case: When all numbers
	    // in arr[] are negative
	    maxSum = arr[0];
	    *start = *finish = 0;
	
	    // Find the maximum element in array
	    for (i = 1; i < n; i++)
	    {
	        if (arr[i] > maxSum)
	        {
	            maxSum = arr[i];
	            *start = *finish = i;
	        }
	    }
	    return maxSum;
	}
	
	// The main function that finds
	// maximum sum rectangle in M[][]
	void findMaxSum(int M[][COL])
	{
	    // Variables to store the final output
	    int maxSum = INT_MIN,
	        finalLeft,
	        finalRight,
	        finalTop,
	        finalBottom;
	
	    int left, right, i;
	    int temp[ROW], sum, start, finish;
	
	    // Set the left column
	    for (left = 0; left < COL; ++left)
	    {
	        // Initialize all elements of temp as 0
	        memset(temp, 0, sizeof(temp));
	
	        // Set the right column for the left
	        // column set by outer loop
	        for (right = left; right < COL; ++right)
	        {
	
	            // Calculate sum between current left
	            // and right for every row 'i'
	            for (i = 0; i < ROW; ++i)
	                temp[i] += M[i][right];
	
	            // Find the maximum sum subarray in temp[].
	            // The kadane() function also sets values
	            // of start and finish. So 'sum' is sum of
	            // rectangle between (start, left) and
	            // (finish, right) which is the maximum sum
	            // with boundary columns strictly as left
	            // and right.
	            sum = kadane(temp, &start, &finish, ROW);
	
	            // Compare sum with maximum sum so far.
	            // If sum is more, then update maxSum and// other output values
	            if (sum > maxSum)
	            {
	                maxSum = sum;
	                finalLeft = left;
	                finalRight = right;
	                finalTop = start;
	                finalBottom = finish;
	            }
	        }
	    }
	
	    // Print final values
	    cout << "(Top, Left) ("
	         << finalTop << ", "
	         << finalLeft
	         << ")" << endl;
	    cout << "(Bottom, Right) ("
	         << finalBottom << ", "
	         << finalRight << ")" << endl;
	    cout << "Max sum is: " << maxSum << endl;
	}
	
	// Driver Codeint
	main()
	{
	    int M[ROW][COL] = {{1, 2, -1, -4, -20},
	                       {-8, -3, 4, 2, 1},
	                       {3, 8, 10, 1, 3},
	                       {-4, -1, 1, 7, -6}};
	
	    // Function call
	    findMaxSum(M);
	
	    return 0;
	}
	```

- ê²°ê³¼ëŠ” ì•„ë˜ì™€ ê°™ë‹¤.

	```c
	(Top, Left) (1, 1)
	(Bottom, Right) (3, 3)
	Max sum is: 29
	
	
	```


## Mathematical Induction & Proof of Correctness

- Proof by Induction

	![2](/assets/img/2022-09-10-[ALG]-1.5.-Maximum-Sum-Subrectangle-in-2D-Array-(1).md/2.png)

- Proof of Correctness : MSS (1D)

	```c
	int ThisSum = MaxSum = 0;
	
	for (j = 0; j < N; j++)
	{
	    ThisSum += A[j];
	
	    if (ThisSum > MaxSum)
	        MaxSum = ThisSum;
	    else if (ThisSum < 0)
	        ThisSum = 0;
	}
	
	return MaxSum;
	```

	- P(j)Â : for-loopê°€ jë²ˆ ìˆ˜í–‰í•œ ì§í›„ì— ThisSum ë³€ìˆ˜ëŠ” ( )ê°’ì„, MaxSum ë³€ìˆ˜ëŠ” ( )ê°’ì„ ê°€ì§€ê³  ìˆë‹¤.

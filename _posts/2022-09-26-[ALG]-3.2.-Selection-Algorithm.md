---
layout: post
date: 2022-09-26
title: "[ALG] 3.2. Selection Algorithm"
tags: [Algorithm, ]
categories: [Notes, ]
use_math: true
---


# 1. Selection of Both Maximum and Minimum Elements

- **Problem**
	- Find both the maximum and the minimum elements of a set containing n elements (assumeÂ $n = 2m$Â for some integerÂ $m$).
- [Aho 2.6]

	```c
	  begin
	    MAX <- any element in S;
	    for all other elements x in S do
	      if x>MAX then MAX<- x
	  end
	```

	- $T(n) = (n-1) + (n-2) = 2n-3$Â comparisons

	$T(n) = 2T(n/2) + 2$Â forÂ $n > 2$,Â $T(n) = 1$ forÂ $n=2$


	$â†’Â T(n) = (3/2)n - 2$Â comparisons

	- This is the minimum!

```c
procedure MAXMIN(S):
	if |S| = 2 then	
		begin	
			let S = {a, b};	
			return (MAX(a,b), MIN(a,b))	
		end
	else	
		begin	
			divide S into two subset S1,S2, each with the half of elements	
			(max1, min1) <- MAXMIN(S1);	(max2, min2) <- MAXMIN(S2);	
			return(MAX(max1, max2), MIN(min1, min2))	
		end
```


# 2. Multiplication of Two n-bit Numbers


![0](/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/0.png)

- The traditional method requiresÂ $O(n^2)$Â bit operations.
- A divide-and-conquer approach

![1](/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/1.png)

- $n=2m$
	- $xy = (a2^{\frac n 2} + b)(c2^{\frac n 2} + d) = ac2^n + (ad+bc)2^\frac n 2 + bd$
	- divideí•˜ë©´ ì—¬ê¸°ê¹Œì§€ëŠ” ìì—°ìŠ¤ëŸ½ê²Œ ê°

	```text
	u = (a+b)*(c+d);
	v = a*c, w = b*d;
	z = v * pow(2,n) + (u-v-w) * pow(2, n/2) + w;
	```

- [Aho 2.6]
	- $T(n) = 1$ forÂ $n=1$
	- $T(n) = 3T( \frac n 2) + cnT(n)=3T(\frac n 2)+cn$forÂ $n>1 â†’ T(n)=O(n\log3)$
	- $O(n^2) â†’ O(n^{1.59})$
- Read [Neapolitan 2.6].

![2](/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/2.png)


# [ALG] 3.2.2. Selection of the k-th Smallest Element (1)


# Selection of the k-th Smallest Element

- _ref_.Â [A. Aho, J. Hopcroft, and J. Ullman, Design and Analysis of Algorithms, Addison-Wesley, 1974. 3.6]
- Problem
	- Given a <u>sequence of</u>Â <u>_S_</u>Â ofÂ _n_Â elements and an integerÂ $k (1 <= k <= n)$, find theÂ $k^{th}$Â smallest element ofÂ _S_.

ë‹¹ì¥ í•´ê²°í•˜ë¼ê³  í•˜ë©´ ì–´ë–»ê²Œ í•´ê²°í•˜ë ¤ê³  í• ê¹Œ?

- **Solution 1:**
	- Choose the smallest element repeatedly k times.
	ë°˜ë³µì ìœ¼ë¡œ 1, 2, â€¦ kë²ˆì§¸ë¡œ ì‘ì€ ìˆ˜ë¥¼ ì°¾ëŠ”ë‹¤.
		- íš¨ìœ¨ì„±ì„ ë– ë‚˜ì„œ ê°€ì¥ ë¹ ë¥´ê²Œ ìƒê°ë‚˜ëŠ” í’€ì´ ë°©ë²•
		- $C = c(n-1)+c(n-2)+c(n-3)+...+c(n-k) = c \cdot k \cdot n - c \cdot \frac {k(k+1)} 2$
			- 1ë²ˆì§¸ ì‘ì€ê²ƒ ë½‘ëŠ” ì‹œê°„, 2ë²ˆì§¸, â€¦, kë²ˆì§¸ ì‘ì€ ê²ƒ ë½‘ëŠ” ì‹œê°„ì˜ í•© â†’ Linear Time Algorithm
			- $O(n) ?$ : ì•„ë‹˜
				- input size : n, k
				- k : ì–´ë–¤ ê°’ì´ëŠëƒì— ë”°ë¼ì„œ ì²œì°¨ë§Œë³„ì¸ time complexity
					- k = 1 â†’ linear time (n-1ë²ˆ ë¹„êµ)
					- n = 100, k = 100
		- ifÂ $k= \frac n 2$ thenÂ $C = c \cdot \frac {n^2} 2 - c \cdot \frac {n^2 + 2n} 8 = O(n^2)$
			- ì‹œê°„ ë³µì¡ë„ê°€ k=1ì—ì„œ nê¹Œì§€ ê°€ëŠ”ë° $O(c) \rightarrow O(n) \rightarrow O(n^2)$

![3](/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/3.png)

- **Solution 2:**
	- Build a min-heap, and then extract the smallest element repeatedlyÂ _k_Â times.
		- ì„ì˜ì˜ ë°ì´í„° nê°œì˜ sequenceë¡œë¶€í„° min(max) heapì„ êµ¬ì„±í•  ë•Œ Linear Time ì†Œìš”
		- $C = c \cdot n + d \cdot k \cdot log nÂ $
		- ifÂ $k= \frac n 2$Â thenÂ $C = c \cdot n + d \cdot \frac n 2 \cdot \log n = O(n \log n)$

![4](/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/4.png)

- **Can we design an**Â $O(n)$**-time algorithm?**

ì–´ë–»ê²Œ linear time algorithmì„ ë§Œë“¤ê¸° ìœ„í•´ì„œ ë…¸ë ¥í–ˆì„ê¹Œ?

- ìƒê°ì˜ íë¦„ì— ë”°ë¥¸ ì¶”ì 

# 1. Observation


divide and conquer : ì§€ê¸ˆê¹Œì§€ ë°°ìš´ ê²ƒ

- At leastÂ $O(n)$Â time is necessary.
- If we use a divide-and-conquer scheme like the merge sort,
- $T(n) = 2T(\frac n 2) + cn => O( n\log n)$
	- nê°œ ì§œë¦¬ì˜ ë¬¸ì œë¥¼ 2ê°œë¡œ ë‚˜ëˆ„ê³  linear timeì˜ boundê°€ ë˜ëŠ” ê·¸ëŸ° ìƒí™©
	- nê°œ ì§œë¦¬ ë¬¸ì œê°€ $\frac n 2$ê°œ ë‘ ê°œë¡œ ë‚˜ëˆ„ì–´ì§€ê³  ì´ê²ƒì´ ë˜ $\frac n 4$ë¡œ ë‚˜ëˆ„ì–´ì§
	- ë‘ ê°œë¥¼ ìª¼ê°œì„œ, ì•Œì•„ì„œ conquerí•´ì„œ ì°¾ì•„ì™€ë¼
	- â†’ levelë§ˆë‹¤ $cn$ ê°œì˜ stage, binary treeì˜ height $cn \cdot \log n$

![5](/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/5.png)

- What aboutÂ $T(n) = 3T(\frac n 3) + cn$?
	- $n \rightarrow \frac n 3+\frac n 3+\frac n 3$
	- subproblemë“¤ì˜ í•©
- What aboutÂ $T(n) = 100T(\frac n {100}) + cn$?
	- $n \rightarrow \frac n {100} \cdot  100$
	- subproblemë“¤ì˜ í•©
- $T(n) = T(0.4n) + T(0.6n) + cn \rightarrow T(n) = O (n \log n)$
	- subproblem í•©ì´ ì›ë˜ ë¬¸ì œ
	- cnì´ linear timeì¼ ë•Œ ì´ ì‹œê°„ë³µì¡ë„ëŠ” $O (n \log n)$
- $T(n) = T(0.39n) + T(0.6n) + cn \rightarrow T(n) = O (n)$
	- $n > (0.39 + 0.6)n$
	- $n = 2^{20} = 1048576$ ì˜ ê²½ìš° ìœ ì˜ë¯¸í•œ ì°¨ì´ê°€ ì¡´ì¬í•¨
- Can we design an O(n)-time algorithm for this selection problem?
	- What aboutÂ $T(n) = T(an) + T(bn) + cn$ withÂ $a + b < 1$?

		nê°œì§œë¦¬ ë¬¸ì œë¥¼ ë‘ ê°œë¡œ í‘¸ëŠ”ë° 

			- ê·¸ ë•Œ subproblemì˜ í•©ì´ ì›ë˜ ê²ƒë³´ë‹¤ ì‘ê³ 
			- ë‚˜ë¨¸ì§€ ë¶€ê°€ë¹„ìš©ì€ $cn$
	- ex. $a = 0.43, b=0.37 \rightarrow?$ã…‰
undefined	- Pascalâ€™s Triangle
		- ë¬´í•œë“±ë¹„ìˆ˜ì—´

		![6](/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/6.png)


		![7](/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/7.png)

- cost :Â $cn\{1+(a+b)+(a+b)^2+...\} \leq cn \frac 1 {1-a+b}$
	- soÂ $O(n)$

# 2. Algorithm

- Step 1: Divide S intoÂ $\lfloor \frac {|S|} 5 \rfloor$Â sequence of 5 elements each with up to four leftover elements.

	![8](/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/8.png)

	- ì •ë ¬ì´ ì•ˆ ëœ ì„ì˜ì˜ ë°ì´í„°ë“¤ì„ 5ê°œì”© ë¬¶ìŒ
- Step 2: Sort each 5-element sequence.
	- ë‹¤ì„¯ê°œ ë¬¶ìŒê¹Œì§€ë§Œ í•˜ëŠ”ê²ƒ ê°™ì€ë° ë‚˜ë¨¸ì§€ ì„¸ê°œì— ëŒ€í•´ì„œëŠ” ì–´ë–»ê²Œ í• ê¹Œ?
		- ex. T(43) : 43ê°œê°€ ì­‰ ìˆëŠ”ë° ê±°ê¸°ì— ë‘ ê°œ ì§‘ì–´ë„£ìŒ. ë¬´í•œëŒ€ ë‘ê°œ ë„£ì–´ë„ ë˜‘ê°™ìŒ

	![9](/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/9.png)


	![10](/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/10.png)

- Step 3: Let M be the sequence of medians of the 5-element sets. Then, let m be the median of the elements inÂ _M_.
	- $|M| = \frac n 5$

		![11](/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/11.png)

- Step 4: LetÂ _S_1,_S_2, andÂ _S_3Â be the sequences of elements in S less than, equal to, and greater than m, respectively.
Së¥¼ ì„¸ ë¶€ë¶„ì§‘í•©ìœ¼ë¡œ ë‚˜ëˆˆ í›„ : ì‘ê±°ë‚˜ / ê°™ê±°ë‚˜ / í¬ê±°ë‚˜
	- IfÂ $|S1| >= k$, then find the k-th smallest element of S1.
	- else ifÂ $(|S1| + |S2| >= k)$, then m is theÂ $k^{th}$Â smallest element of S.
	- else find theÂ $(k â€“ |S1| - |S2|)^{th}$Â smallest element ofÂ _S_3.

	![12](/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/12.png)


	![13](/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/13.png)


> ğŸ’¡ - size nì¸ ë°°ì—´ì—ì„œ ëª‡ ë²ˆì§¸ë¡œ ì‘ì€ elementì¸ì§€ ì°¾ì•„ë¼ :

	- size nì¸ ë°°ì—´ì—ì„œ ëª‡ ë²ˆì§¸ë¡œ ì‘ì€ elementì¸ì§€ ì°¾ì•„ë¼ :
		- step 3ì—ì„œ mì§‘í•©ì„ êµ¬ì„±í•œ ë‹¤ìŒ medianì„ ì°¾ì•„ë¼
		- $|M| = \frac n 5$ : divide and conquer
- 27ê°œë³´ë‹¤ ë” ì‘ì€ ê²ƒì„ ì°¾ìœ¼ë‹ˆê¹Œ s1ì—ì„œ ì‘ì€ ê²ƒì„ ì°¾ìœ¼ë©´ ë¨
	- ì–´ë–¤ më³´ë‹¤ ì‘ì€ ì• ë“¤ ë‹¤ êµ¬í•´ë…¼ ê²ƒ, ê°™ì€ ê²ƒ, ë” í° ê²ƒì„ êµ¬í•´ë‘” ê²ƒ
	- if) s1 = 100, s2 = 5, s3 = 200ì¼ ë•Œ
		- 27ë²ˆì§¸ ì‘ì€ ê²ƒì„ ì°¾ê³ ì í•œë‹¤ë©´, S1ì— ì¡´ì¬
		- 103ë²ˆì„ ì°¾ê³ ì í•œë‹¤ë©´, S2ì— ì¡´ì¬
			- 103 - 100 = 3 â†’
		- 120ë²ˆì§¸ ì‘ì€ ê²ƒì„ ì°¾ëŠ”ë‹¤ë©´, S3ì— ì¡´ì¬
			- 120 - 100 - 5 = 15ë²ˆì§¸ë¡œ ì‘ì€ ì›ì†Œ ì„ íƒ
- ê° subproblemì—ì„œ ë˜‘ê°™ì€ ë°©ì‹ìœ¼ë¡œ í’€ì–´ë³´ë ¤ê³  í•œë‹¤. ì •ë§ ì ˆì‹¤í•˜ê²Œ subproblemì˜ tcê°€ ì›ë˜ ë¬¸ì œ ì‚¬ì´ì¦ˆ në³´ë‹¤ ì‘ê²Œ í•˜ë ¤ê³  í•˜ëŠ”ë°, ì–´ë–¤ ë¬¸ì œë¥¼ í‘¸ëŠ”ê°€
	- ë‚´ê°€ í’€ê³ ì í•˜ëŠ” ë¬¸ì œì™€ ë˜‘ê°™ì€ ë°©ì‹ìœ¼ë¡œ í’€ê³ ì í•¨
	- $T(n) \rightarrow T(\frac n 5)$ :
- ì™œ $T(\frac 3 4 n)$ë¡œ boundê°€ ë˜ëŠ”ê°€ ìƒê°í•´ë³´ì : mì„ ì˜ ì„ íƒí•´ì„œ â†’ sizeê°€ ì ë‹¹
	- ì•ì„œ ì •ë ¬í•œ ë‹¤ìŒ ê°€ìš´ë° ê²ƒì„ ëª¨ì•„ì„œ mì„ ì°¾ì•„ëƒ„
	- më³´ë‹¤ ì‘ì€ ì• ë“¤, ê°™ì€ ì• ë“¤, í° ì• ë“¤ì„ ë¬¶ìŒ â†’ mì„ ì˜ ì„ íƒí–ˆê¸° ë•Œë¬¸ì— S1, S2, S3 ê°ê°ì— ì–´ëŠ ì •ë„ ì›ì†Œê°€ ì¡´ì¬í•˜ë„ë¡ ìª¼ê°  ê²ƒ
	- $T(|S_1|) $ or $T(|S_3|) $
		- $|S_1| \leq \frac 3 4 n$
		- ë„ëŒ€ì²´ ì–´ë–»ê²Œ í–ˆê¸¸ë˜ ê°ê° ì‘ê±°ë‚˜ ê°™ì€ ê²ƒì´ ì ë‹¹íˆ ë½‘íŒ ê²ƒì¸ê°€ : mì„ ì ë‹¹íˆ ì˜ ì„ íƒí–ˆê¸°ì—!

## pseudocode


```c
procedure SELECT(k,s):
if |S|<50 then
	begin
		sort S;
		return kth smallest element in S
	end
else
	begin
		divide S into |S|/5 sequences of 5 elements each with up to four leftover elements;
		sort each 5-element sequence;
		let M be the sequence of medians of the 5-element sets;
		m <- SELECt (M/2, M);
		let s1, s2 and s3 be the sequences of elements in S less than, equal to, and greater than m, respectively;
		if |s1|>= k
			then return m
		else
			return SELECT (k-|s1|-|s2|, s3)
	end


```

- Pseudocode Analysis

	![14](/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/14.png)

- A divide-and-conquer strategy

## Facts

- (A) At least one-fourth of the elements of S are less than or equal toÂ _m_.
- (B) At least one-fourth of the elements of S are <u>greater than or equal to</u>Â <u>_m_</u><u>.</u>
	- më³´ë‹¤ ê°™ê±°ë‚˜ í° ì• ë“¤
	- $|S_1| <= \frac {3n} 4$
	- $|S_3| <= \frac {3n} 4$
- S1: the set of all elements less than m
- S2: the set of all elements equal to m
- S3: the set of all elements greater than m

![15](/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/15.png)


![16](/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/16.png)


# 3.3. Time Complexity

- Input sizeÂ $n = |S|$
- $|M| <= \lceil( \frac n 5)\rceil$
- $|S_1| <= \frac {3n} 4$
- $|S_3| <= \frac {3n} 4$
- for $n \leq 49$
- 7ì´ ì•„ë‹ˆë¼ 5, 7, 9, 100001
- në³´ë‹¤ ë” ì‘ì•„ì§€ë‹ˆê¹Œ ë” ì¢‹ì„ ê²ƒ ê°™ì€ë°, ì´ ê°’ì´ ì»¤ì§€ë‹¤ ë³´ë©´, ëŒ€ëµ n/100ì´ ëœë‹¤.
	- 5ê°œë³´ë‹¤ëŠ” 7ê°œê°€ ë” ì¢‹ê³ , â€¦ :$n/1001 + 3n/4$<<nì´ë©´ ë” ì¢‹ìœ¼ë¯€ë¡œ
	- â†’ 10001ê°œ ì§œë¦¬ë¥¼ sortingí•˜ëŠ”ë° ê³¼ì—° ì´ 10001ê°œ sortingí•˜ëŠ” ì‹œê°„ì´ ìƒìˆ˜ ì‹œê°„ì´ëƒ : ê·¸ë ‡ê²Œ ë³¼ ìˆœ ì—†ë‹¤.
- ì´ ì‹œê°„ì´ ìƒìˆ˜ì‹œê°„ì´ ì•ˆ ëœë‹¤.
	- nì´ ì–´ëŠì •ë„ ë³€í•´ë„ ë³€í•˜ì§€ ì•ŠëŠ”, n/100ê³¼ëŠ” ì–´ëŠì •ë„ í° ê²ƒì´ê¸° ë•Œë¬¸ì— ë¯¸ë¬˜í•œ ì°¨ì‰ê°€ ìˆìŒì„ ëª…ì‹¬í•˜ì.

```c
procedure SELECT(k,s):
if |S|<50 then
	begin
		sort S;
		return kth smallest element in S
	end
else
	begin
		divide S into |S|/5 sequences of 5 elements each with up to four leftover elements;
		sort each 5-element sequence;
		let M be the sequence of medians of the 5-element sets;
		m <- SELECt (M/2, M);
		let s1, s2 and s3 be the sequences of elements in S less than, equal to, and greater than m, respectively;
		if |s1|>= k
			then return m
		else
			return SELECT (k-|s1|-|s2|, s3)
	end

```


![17](/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/17.png)


## Complexity Analysis


![18](/assets/img/2022-09-26-[ALG]-3.2.-Selection-Algorithm.md/18.png)


# [ALG] 3.2.3. Selection Algorithm: Complexity Analysis (1)

- Theorem
	- $\forall c, d \in \mathbb{R^+}$, if the following recurrence relation holds:
	- $T(n) \leq d$Â forÂ $nâ‰¤49$
	- $T(n) \leq T(\frac n 5) + T (\frac {3n} 4) + cn, n \geq 50$
	- thenÂ $T(n) = O(n)$
- Proof
	- We want to prove thatÂ $T(n) \leq kn$Â for some constantÂ $k,âˆ€nâ‰¥1$
		1. Base case
			- $T(n) \leq d \leq dn, âˆ€nâ‰¥1$
			- Therefore,Â $T(n)â‰¤knÂ âˆ€1â‰¤nâ‰¤49Â $ if we select k such that $k \geq d$
		2. Inductive step
			- assume thatÂ $nâ‰¥5$Â andÂ $T(m) \leq km, \forall m < n$
				- Then,Â $T(n) \leq T(\frac n 5) + T (\frac {3n} 4) + cn$
			- $T(n)\leq k \frac n 5 + k \frac {3n} 4+ cn = \frac {19}{20}kn +cn$
			- $T(n)= kn + (c-\frac k {20})n \leq kn$
				- ifÂ $k \geq 20c$
	- So if we chooseÂ _k_Â s.t.Â $k=\max(d,20c),Â T(n)â‰¤kn$Â for allÂ $nâ‰¥50.$

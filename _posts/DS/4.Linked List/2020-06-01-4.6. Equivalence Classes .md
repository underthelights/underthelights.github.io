---
title: "Equivalence Classes (Chapter 4.6)"
excerpt: "Chap 4."
slug: "4-6-classes"

category: "data-structure"
lang: en
use_math: true
tags: ["CS", "data-structure"]
date: 2021-04-16T22:26:09-05:00
draft: false
---
## Equivalence Classes (Chapter 4.6)

### Equivalence Classes

- Definition from Wikipedia
  - In mathematics, when the elements of some set S have a notion of equivalence (equivalence relation) defined on them, then one may naturally split the set S into equivalence classes.

  
  
- Equivalence relation

  - An equivalence relation on a set X is a binary relation ~ on $X$ satisfying the three properties
  - $a ~ a$ for all $a \in X$ (reflexivity)
  - $a ~ b$ implies $b ~ a$ for all $a$ and $b \in X$(symmetry)
  - if $a ~ b$ and $b ~ c$ then $a ~ c$ for all a, b, and c in X (transitivity)

  

- Examples
  - If $X$ is the set of all cars, and ~ is the equivalence relation "has the same color as", then on particular equivalence class consists of all green cars.



- Suppose we have the following set of items, numbered from 0 to 11.
  - $S = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\}$

- According to some equivalence relation, the following pairs of items are equivalent.
  - $(0, 4), (3, 1), (6, 10), (8, 9), (7, 4), (6, 8), (3, 5), (2, 11), (11, 0)$

- Then we can we can partition set S into the following equivalence classes.
  - $\{0, 2, 4, 7, 11\}$
  - $\{1, 3, 5\}$
  -  $\{6, 8, 9, 10\}$



- We are going to write a program that finds the equivalence classes from a set of items

- Input - number of items 
  - ex) 12 , 
  
  
- pairs of equivalent items
  - ex) $(0, 4), (3, 1), (6, 10), (8, 9), (7, 4), (6, 8), (3, 5), (2, 11), (11, 0)$

- Output - equivalence classes
  -  $0 2 4 7 11 / 1 3 5 / 6 8 9 10$

#### Algorithm for finding equivalence classes

- Input: 
- $(0, 4), (3, 1), (6, 10), (8, 9), (7, 4), (6, 8), (3, 5), (2, 11), (11, 0)$
- First Phase
  - For each item i, we store all items j that have direct equivalence relationship given by the input.

<img width="427" alt="image-20211003163947067" src="https://user-images.githubusercontent.com/46957634/135752318-ecfda215-df52-40b0-8fe0-3f5e1dc7022a.png">

- Second Phase

  - For 0, we search for all items equivalent with 0. 

  - Since 4 and 11 are equivalent with 0, we need to also search for all items equivalent with 4 and 11 as well.

  - Since 7 is equivalent with 4, we need to also search for items equivalent with 7.

  - If we find all items equivalent to 0, then we have found one equivalence class.

  - Then we go to the next item which is not chosen in any equivalence class yet, and do the samething.

#### Implementation

- We are going to use an array of linked lists.
  - One linked list for each item.
- After the first phase, we will have the following structure.

<img width="427" alt="image-20211003164006712" src="https://user-images.githubusercontent.com/46957634/135752321-e6a24a59-9a3f-4e9e-aacb-8afca99bca55.png">

- In the second phase, we need to find all equivalent items of item 0.

- Then, we should search for equivalent classes of 11 and 4.

- For this purpose, we are going to use a stack.

  - When processing the linked list of item 0, we put 11 and 4 into the stack.

  - After we are done with 0, we pop an item from the stack. We get 11.

  - We process equivalent items of 11. 

  - Since 0 is already processed, we skip 0.

  - Since 2 is not processed yet, we include 2 in the equivalence class and also put 2 into the stack.

  - When the stack is empty, we have completed an equivalence class.

  - Then we go to the next item that is not processed yet.

#### Equivalence Class[ex034]

<script src="https://gist.github.com/underthelights/894363c37b773fac8d4c49fac837c979.js"></script>


#### Analysis

- $m$ : number of pairs in the input.
- $n$ : number of items.

- Phase 1

  - Initialization of seq and out takes O(n) time.
- Inputting equivalence pairs takes O(m) time.
  - Total time in phase 1 : O(m + n)

  

- Phase 2

  - The outer for loop is repeated n times. $O(n)$.
  - Inside, each node in the array of linked list structure is processed once.Since there are 2m nodes, the time required is $O(m)$.
  - Total time in phase 2 : $O(m + n)$

  

- The time complexity of the program for finding equivalence classes : $O(m + n)$



- Space complexity : $O(m + n)$

  - $n$ entries in the array of node pointers

  - $2m$ nodes in the linked list structure

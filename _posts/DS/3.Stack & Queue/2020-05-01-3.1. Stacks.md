---
title: "Stacks (Chapter 3.1)"
excerpt: "Chap 3."
slug: "3-1-stacks"

category: "data-structure"
lang: en
use_math: true
tags: ["CS", "data-structure"]
date: 2021-03-20T22:26:09-05:00
draft: false
---
## Stacks (Chapter 3.1)

### Definition of Stack

- Stack is a specialized type of an ordered list.
- One end is called top.
- The other end is called bottom.
- Additions to and removals from the top end only.

<img width="225" alt="image-20211003151005422" src="https://user-images.githubusercontent.com/46957634/135750339-7a5715b4-f4a0-4cd5-ac32-da04182a0ffd.png">

### Analogy 

- A stack of cups
  - We can only put (add) a cup to the top of the stack
  - We can only remove the cup on the top of the stack
  - This type of behavior is called Last-In-First-Out (LIFO) 
    - The last cup inserted to the stack is removed first.

<img width="366" alt="image-20211003151138083" src="https://user-images.githubusercontent.com/46957634/135750389-5998d677-5b17-4a22-918f-50bfe8c7aa63.png">

### Stack: LIFO behavior

- Inserting to the stack is called "push".
- Removing from the stack is called "pop".

<img width="366" alt="image-20211003151151863" src="https://user-images.githubusercontent.com/46957634/135750409-243d8008-052e-4f35-982f-86bd94f11421.png">



### Stack: Example Usage

- Function call stack: 
  - when a function is called in a program, the function data is inserted into the call stack. When the function returns, the function data is removed from the stack.

<img width="381" alt="image-20211003151218932" src="https://user-images.githubusercontent.com/46957634/135750418-9c1457e7-2d47-484c-a09e-2b073f3b47fd.png">

### Stack: Abstract Data Type

<script src="https://gist.github.com/underthelights/66044e762cd2c16f493d60d5d5785e0d.js"></script>

### Ordered Lists

- One of the simplest abstract data types.

- Object: list of items (of the same type) that have a certain order

  ```c
  (item1, item2, item3, ..., itemn)
  ```

- Functions
  - Finding the length, reading an item from the list, retrieving an item from the list, replacing an item in the list, inserting a new item to the list, deleting an item from the list, etc.

  
  
- Chronologically ordered list

  -  In a chronologically ordered list, elements are ordered according to time.

  -  Examples: round robin, stack, queue

  -  Stack: elements are in reverse chronological order
     -  The first element deleted is the last element (top) in the stack
     -  The last element deleted is the first element (bottom) in the stack

     
     
  -  Stack is a special type of an ordered list with restricted operations.
     -  Can only access the item at the top.

### Implementation of a stack

 - We can implement a stack using a one-dimensional array.

```c
#define MAX_STACK_SIZE 100 /* maximum stack size */
typedef struct {
  int key;
  /* other fields if necessary */
} element;
element stack[MAX_STACK_SIZE];
int top = -1; /* if top is -1, it means the stack is empty */
```

### Implementing push and pop [ex018] 

- push: insert an element to the stack
  
  <script src="https://gist.github.com/underthelights/6ad024c0e827bfce7ee36342f6a95f37.js"></script>

- pop: delete and return an element from the stack

  <script src="https://gist.github.com/underthelights/f5300df95bc08afe02807fe537231d18.js"></script>



### Example: Tower of Hanoi

- 64 gold disks to be moved from tower A to tower C
- Each tower operates as a stack
- Cannot place a bigger disk on top of a smaller one

<img width="373" alt="image-20211003151432027" src="https://user-images.githubusercontent.com/46957634/135750440-2292a8a0-5bea-4ec9-98bf-7219ac80a584.png">

 - Simple case: let us assume we only have 3 disks to move from A to C.

<img width="373" alt="image-20211003151543035" src="https://user-images.githubusercontent.com/46957634/135750429-229f9d88-259e-42a5-b72b-74d44f112dda.png">

- Step 1: move disk 3 to C.

<img width="373" alt="image-20211003151549893" src="https://user-images.githubusercontent.com/46957634/135750445-36e4045c-4cfb-4153-80ac-c7c77350c3a1.png">

- Step 2: move disk 2 to B.

<img width="373" alt="image-20211003151556363" src="https://user-images.githubusercontent.com/46957634/135750454-b3b23088-de4a-4eda-95a5-885ce232182c.png">

- Step 3: move disk 3 to B.

<img width="373" alt="image-20211003151604814" src="https://user-images.githubusercontent.com/46957634/135750463-5d0ba02d-2bba-4f10-baf3-d328df52daf6.png">

- Step 4: move disk 1 to C.

<img width="373" alt="image-20211003151610447" src="https://user-images.githubusercontent.com/46957634/135750468-d8032a21-2f6e-4f99-8c62-954154bc52b1.png">

- Step 5: move disk 3 to A.

<img width="373" alt="image-20211003151618523" src="https://user-images.githubusercontent.com/46957634/135750471-2dfeffb9-7fc3-4781-808b-86484a6afea1.png">

- Step 6: move disk 2 to C.

<img width="373" alt="image-20211003151624739" src="https://user-images.githubusercontent.com/46957634/135750478-f54f7c9a-0034-4b0c-bb21-eb675116d439.png">

 - Step 7: move disk 3 to C. Done. Total 7 disk moves required.

<img width="373" alt="image-20211003151635900" src="https://user-images.githubusercontent.com/46957634/135750488-b65f807d-9955-49dc-a047-e47694ce3e24.png">

 - General case: moving n disks from A to C (using B).

<img width="373" alt="image-20211003151643592" src="https://user-images.githubusercontent.com/46957634/135750494-55362405-95f1-44ce-a6a0-531cb51e5593.png">

 - First, move the top n-1 disks from A to B (using C).

<img width="373" alt="image-20211003151650239" src="https://user-images.githubusercontent.com/46957634/135750500-6b8502a6-bd88-47eb-8d10-48dd0d5c6549.png">

- Then, move disk 1 to C.

<img width="373" alt="image-20211003151705173" src="https://user-images.githubusercontent.com/46957634/135750501-17c3f71b-1648-49f8-8a4a-4203c04dbb54.png">


 - Then, move the top n-1 disks to C. Done.

<img width="373" alt="image-20211003151719289" src="https://user-images.githubusercontent.com/46957634/135750516-3240ded0-9f65-461b-84f1-40662c4bf0cb.png">

- A recursive solution: Moving n disks from A to C 
  - Move top n-1 disks to B
   - Move disk 1(thebiggest disk) to C
   - Move top n-1 disks to C
  
  
  
- Using the recursive solution, we are converting the problem with input size n to a problem with input size n-1.

- What is the number of moves required to move n disks to C?
  - Let us denote T(n) to be the number of moves required to move n disks.

  
  
- Steps 
  - Move top n-1 disks to B → T(n-1) 
  - Move disk 1 to C→1
  - Move top n-1disks to C→T(n-1)

  
  
- $T(n)=2xT(n-1)+1$

- $T(n)=2n-1$



- How many times do we need to move disks to move 64 disks from one tower to another?
  - T(64) = 264 - 1 = 1.8 * 1019 (approximately)
  
  
  
- If a computer performs 109 moves/second, it would take about 570 years to complete this task.

- If a monk moves 1 disk per minute, it will take him about 3.4 * 1013 years.

### Example: Rat in a Maze

- A rat enters a maze and needs to find its way to the exit.

  -  The rat cannot step on the blue blocks.

  -  The rat can move in four directions: up, down, left, right

- How can we program so that the rat will eventually find the exit if there exists a path from entrance to exit?

- We can program the rat so that it has a rule for movement.
  - The move order is right, down, left, up
     - If the rat can move right, it will. If not, it will try moving down, left, and then up.
     
     
  - If the rat has nowhere to move, it will backtrack its path until it can move again. 
    - The rat should remember the blocks it went in the past to avoid revisiting.

<img width="259" alt="image-20211003151917373" src="https://user-images.githubusercontent.com/46957634/135750525-9fc07c52-93d1-4182-8291-96c992ff436c.png">

- Example run: the rat will move right as long as it can.

  <img width="263" alt="image-20211003152009233" src="https://user-images.githubusercontent.com/46957634/135750527-9b809148-1b94-4fdb-ae77-6a7beec5f3ee.png">

- Since the rat can move nowhere from there, it will backtrack until it can move again.

<img width="263" alt="image-20211003152015064" src="https://user-images.githubusercontent.com/46957634/135750530-eb9b0ab2-2f6b-40dc-ba63-da18b725dddc.png">

- The rat moves down.

<img width="263" alt="image-20211003152022903" src="https://user-images.githubusercontent.com/46957634/135750531-a454f999-2a62-4a4e-833d-0b9a3da04553.png">

- The rat moves left.

<img width="263" alt="image-20211003152030020" src="https://user-images.githubusercontent.com/46957634/135750534-c04576bf-bfd6-4fe8-b5c6-a4be7ef09cc5.png">

- The rat moves down.

<img width="263" alt="image-20211003152036576" src="https://user-images.githubusercontent.com/46957634/135750535-922903cb-00d1-475e-b8b6-e1b2b27c47f3.png">


 - The rat backtracks until it can move to a new block.

<img width="263" alt="image-20211003152042749" src="https://user-images.githubusercontent.com/46957634/135750537-a52b15e6-717f-4f98-91bb-1a97ca9d5a43.png">


 - The rat backtracks until it can move to a new block.

<img width="263" alt="image-20211003152050590" src="https://user-images.githubusercontent.com/46957634/135750538-28386a50-9e38-44b7-b5b0-9789f56a4e46.png">

- The rat moves according to the order of movement and backtracks whenever it bumps into a dead end.

<img width="423" alt="image-20211003152103984" src="https://user-images.githubusercontent.com/46957634/135750579-7c7e054f-70c4-425f-92e8-b5025baebd84.png">

- The rat moves according to the order of movement and backtracks whenever it bumps into a dead end.

<img width="423" alt="image-20211003152116133" src="https://user-images.githubusercontent.com/46957634/135750582-440e97db-eafd-4fff-aed1-6ae810347c9d.png">

- The rat moves according to the order of movement and backtracks whenever it bumps into a dead end.

<img width="423" alt="image-20211003152126420" src="https://user-images.githubusercontent.com/46957634/135750584-17017acb-dff5-4a20-a504-681ccec8daf5.png">

#### Programming - Representation of a maze

-  Two-dimensional array in which 0's represent the open paths and 1's the barriers.
-  To avoid checking for the border conditions we can surround the maze by a border of 1's. Then, an m x p maze will require an (m+2) x (p+2) array.

- The entrance is at position[1][1] and the exit at [m][p]

<img width="423" alt="image-20211003152153718" src="https://user-images.githubusercontent.com/46957634/135750606-20cf3c22-359f-4cd1-9c58-e5c2a82f63fd.png">

- In the previous example, the rat could move in four directions.

- This time we will let the rat move in eight directions 

  - N,NE,E,SE,S,SW,W,NW

  <img width="367" alt="image-20211003152214646" src="https://user-images.githubusercontent.com/46957634/135750607-4694e449-6604-48e1-941b-e812a4942838.png">

```c
typedef struct {
  short int vert;
  short int horiz;
} offsets;
offsets move[8]; /* array of moves for each direction */
```

- Table of moves

<img width="214" alt="image-20211003152233113" src="https://user-images.githubusercontent.com/46957634/135750609-9b82c8b2-6bbb-49ae-a452-b036697562e5.png">

- If we are at position maze[row][col], we can find the position after next move, maze[nextRow][nextCol], by setting
  - nextRow = row + move[dir].vert
  - nextCol = col + move[dir].horiz
  
  
- To record the maze positions already visited, we can maintain a second two- dimensional array.
- A stack is used to store the positions on the path from the entrance to the current position.

#### A pseudocode for the maze program

```pseudocode
initialize a stack to the maze's entrance coordinates and direction to north; 

while (stack is not empty) {
	/* move to position at the top of stack */
	<row,col,dir> = delete from top of stack;
  while (there are more moves from current position) {
  	<nextRow, nextCol> = coordinates of next move;
    dir = direction of move;
    if ((nextRow==EXIT_ROW) &&(nextCol==EXIT_COL))
    	success;
    if ((maze[nextRow][nextCol]==0) &&(mark[nextRow][nextCol]==0)) {
    	/* legal move and haven't been there */ mark[nextRow][nextCol] = 1;
      /* save current position and direction */
      add <row,col,dir> to the top of the stack; 
      row = nextRow; 
      col = nextCol; 
      dir = north;
      } 
	}
}
printf("No path found");
```



- Defining the stack for the program

```c
#define MAX_STACK_SIZE 100
typedef struct {
  short int row;
  short int col;
  short int dir;
} element;
element stack[MAX_STACK_SIZE];
```

- Need to determine a reasonable bound for the stack size.

[Figure 3.11] Simple maze with a long path

<img width="65" alt="image-20211003152411739" src="https://user-images.githubusercontent.com/46957634/135750610-3574cb02-880c-4e53-a59b-c21faa15e40a.png">

#### [ex019] - Maze search function

- we assume that arrays maze, mark, move, stack, and constants EXIT_ROW, EXIT_COL, TRUE, FALSE, and variable top are declared as global.

<script src="https://gist.github.com/underthelights/07a5ea8726ef3d958cd09c4f4e61a2b6.js"></script>

##### Analysis of function path

- Since each position within the maze is visited no more than once, the worse case time complexity of the algorithm is O(mp) where m and p are, respectively, the number of rows and columns of the maze.
- A position may be pushed and popped multiple times due to backtracking, but this number cannot exceed number of directions, which is 8 in this case.


---
layout: post
date: 2022-09-08
title: "[ALG] 1.4. MSS (1)"
tags: [Algorithm, ]
categories: [Notes, ]
---


> ìµœëŒ€ ë¶€ë¶„ ìˆ˜ì—´ì˜ í•© Maximum Subsequence Sum

- ì–´ë– í•œ ì•Œê³ ë¦¬ì¦˜ì„ ì„¤ê³„í•˜ëŠëƒì— ë”°ë¼ì„œ ì–´ë–»ê²Œ ê²°ê³¼ê°€ ë‹¬ë¼ì§€ëŠ”ì§€.

# Maximum Subsequence Sum (MSS) Problem

- _Ref_.Â **[M. Weiss,**Â **Data Structure and Algorithm Analysis in C (2nd ed.), Pearson, 1997. 2.4.3]**
	- GivenÂ $N$Â (possiblly negative)Â $A_0, A_1, ..., A_{N-1} \in \mathbb{Z}$
	- find the maximum value ofÂ $\sum_{k=i}^{j} {A_k }$Â forÂ $0 \leq i \leq j \leq N-1$
	- for convenience, the max subseuqence sum is 0 if all the integers 're <0
- Example
	- $(-2, 11, -4, 13, -5, -2). â†’ MSS = 20$
	- $(a_1, ..., a_6)$ : ìˆ˜ì—´ì˜ ëª¨ë“  ê°€ëŠ¥í•œ ë¶€ë¶„ìˆ˜ì—´ ì¤‘ $\Sigma_{k=i}^j {A_k}$ ì„ì˜ì˜ iì—ì„œ ì‹œì‘í•´ì„œ jì—ì„œ ëë‚˜ëŠ” ê²ƒë“¤ì„ ë”í–ˆëŠ”ë° ê·¸ëŸ° ê²ƒë“¤ ì¤‘ ì œì¼ í° ê²ƒì„ ì°¾ì•„ë¼.
		- sequence elementë“¤ì€ ì •ìˆ˜ì¼ ë•Œ subsequenceë¥¼ ì°¾ëŠ”ë‹¤.: subsequenceì˜ í•©ì´ ìµœëŒ€ê°€ ë˜ê²Œí•˜ëŠ” ìˆ˜ì—´.
		- ì£¼ì–´ì§„ ìˆ˜ì—´ì˜ ì •ìˆ˜ê°€ ëª¨ë‘ ìŒìˆ˜ì´ë©´ mss=0 ê°„ì£¼
	- length = 0, 1, 2ë¡œ ì‹œì‘í•˜ê±°ë‚˜,,
		- ì•„ë¬´ë¦¬ ë¹¨ë¼ë„ $n^2$ë³´ë‹¤ ë¹ ë¥´ê²ŒëŠ” ëª» ë§Œë“¤ê² ë‹¤ëŠ” ìƒê°ì´ ë“¤ ìˆ˜ ìˆë‹¤.
			- nê°œ data ì¤‘ ê°€ì¥ ì‘ì€ ê²ƒ ë½‘ê¸° : í•œ ë²ˆì”© sequential searchë¥¼ í•´ì•¼ í•˜ë¯€ë¡œ n
			- n^2ê°œì˜ ê²½ìš°ëŠ” n^2ê°€ ë  ê²ƒ ê°™ì€ë°,
			- divide n conquer : $O(N \log N), $ DP : $O(n)$
		- â†’ $n + (n-1) + (n-2) + ... + 2 + 1 = \frac {n(n+1)}{2} = O(n^2)$
	- ì´ ì•ˆì— ëª¨ë“  ì¡´ì¬í•˜ëŠ” subsequence ì¤‘ì— í•©ì„ ê°€ì¥ í¬ê²Œ í•˜ëŠ” subsequenceë¥¼ ì°¾ì•„ë¼.

		![0](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/0.png)

- Maximum Subarray Problem
- Maximum Positive Sum Subarray Problem
- Max. Sum Subsequence versus Max. Subsequence Sum

# Alg of Maximum Subsequence Sum

- ê¸¸ì´Â nì¸ ì •ìˆ˜ì˜ ìˆ˜ì—´Â $a_0, a_1, ..., a_{n-1}$ì´ ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì ¸ ìˆë‹¤.
- ì—¬ê¸°ì„œ ë¶€ë¶„ ìˆ˜ì—´ $[i, j]$ ë¼ëŠ” ê²ƒì€ $Â a_i, a_{i+1}, a_{i+2}..., , a_{j}$ë¥¼ ë§í•œë‹¤.
- aì˜ ìµœëŒ€ê°’ì„ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤.
	- (ì´ë•Œ ì£¼ì–´ì§„ ìˆ˜ì—´ì˜ ì •ìˆ˜ê°€ ëª¨ë‘ ìŒìˆ˜ì´ë©´ ìµœëŒ€ ë¶€ë¶„ ìˆ˜ì—´ì˜ í•©ì€ 0 ì´ë¼ê³  ê°„ì£¼í•œë‹¤)
	- ì˜ˆë¥¼ ë“¤ì–´ ë‹¤ìŒê³¼ ê°™ì€ ìˆ˜ì—´ì´ ì£¼ì–´ì¡Œì„ ë•Œ,Â $+ 31, âˆ’41, +59, +26, âˆ’53, +58, +97, âˆ’93, âˆ’23, +84$ Â ìµœëŒ€ ë¶€ë¶„ ìˆ˜ì—´ì€Â [2,6]ì´ë©° ìˆ˜ì—´ì˜ í•©ì€Â 187Â ì´ ëœë‹¤.

	![1](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/1.png)

- ì´ ë¬¸ì œëŠ” ìµœëŒ€ ë¶€ë¶„ ìˆ˜ì—´ì˜ í•©ì„ êµ¬í•˜ëŠ” ê²ƒì´ì§€ë§Œ, ì•ìœ¼ë¡œ ì†Œê°œí•  ì•Œê³ ë¦¬ì¦˜ì„ ì¡°ê¸ˆë§Œ ìˆ˜ì •í•˜ë©´ ìµœëŒ€ ë¶€ë¶„ ìˆ˜ì—´ë„ ì‰½ê²Œ êµ¬í•  ìˆ˜ ìˆë‹¤.
	- empty string : letter char=0, NULL String
	- substring
	- string
	- length

	> Algorithm1 : ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ ì°¾ê¸° -Â $O(N^3)Â $


	> Algorithm2 : Sumêµ¬í•  ë•Œ ì¤‘ë³µ ì¡°ê¸ˆ í”¼í•˜ê¸° -Â $O(N^2)$Â 

	- simple counting
		- $O(n^2)$ : SS ì—¬ëŸ¬ ê°œê°€ ìˆëŠ”ë° í•œ ë²ˆì”© ëª¨ë‘ ë³´ì.
		- $i$ì—ì„œ ì‹œì‘í•˜ëŠ” ê²ƒë“¤ 1, 2, â€¦ ê°œë¥¼ ëª¨ë‘ ë³´ì : $n^2$ê°œë¥¼ ëª¨ë‘ ë³¸ ê²ƒ.

	![2](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/2.png)


	> Algorithm3 : Divide n Conquer -Â $O(N \log N)$Â 

	- Divide n Conquer
		- ê²½ìš°ë¥¼ ë‚˜ëˆˆë‹¤ : MSS subsequenceê°€ ì¡´ì¬í•˜ëŠ”ë° ì´ë¥¼ ë°˜ìœ¼ë¡œ ì˜ë¼ì„œ ë¶„ëª…íˆ ì–´ë”˜ê°€ ì¡´ì¬í•œë‹¤ â†’ ì™¼ìª½ í˜¹ì€ ì˜¤ë¥¸ìª½, ì•„ë‹ˆë©´ ì–‘ë‹¤ë¦¬ ê±¸ì¹˜ë˜ì§€.
		- ì™¼ìª½ ì¤‘ ì œì¼ í° ê²ƒ ì°¾ê³ , ì˜¤ë¥¸ìª½ ì¡´ì¬ ì¤‘ ì œì¼ í° ê²ƒ ã…ˆì°¾ê³ , ì–‘ë‹¤ë¦¬ ì¤‘ ì œì¼ í° ê²ƒ ì°¾ê³ .
		- ê·¸ì¤‘ì— ì œì¼ í° ê²ƒì„ ì°¾ì•˜ëŠ”ë° O(Nlog N)ê±¸ë¦¬ë”ë¼

	![3](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/3.png)


	> Algorithm4 : Dynamic Programming -Â $O(N)$

	- DP
		- ê°ê°ì˜ iì— ëŒ€í•´ì„œ ië²ˆì§¸ ëë‚˜ëŠ” ì• ë“¤
		- ë¶„ëª…íˆ maximum sumì„ í•´ì£¼ëŠ” ê²ƒì€ í•˜ë‚˜ ì¡´ì¬í•˜ëŠ”ë° ì²« ë²ˆì§¸ ì›ì„œë¡œ ëë‚˜ë˜ì§€, â€¦ ëª‡ ë²ˆì§¸ì¯¤ì— ëë‚  ê²ƒì´ë‹¤. në²ˆì§¸ì—ì„œ ëë‚˜ëŠ” ê²ƒë“¤ ê°ê°ì„ ë³´ìëŠ” ì˜ë¯¸ì´ë‹¤.

	![4](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/4.png)

	- algorithmì„ ë§Œë“¤ ë•Œ, íš¨ìœ¨ì„ ì‹ ê²½ì“°ì§€ ë§ê³  í•˜ë‚˜í•˜ë‚˜ ë”°ì ¸ë³¸ë‹¤. ê³ ë“±í•™êµ ë•Œ ìˆœì—´ê³¼ ì¡°í•©ìœ¼ë¡œ ê²½ìš°ì˜ ìˆ˜ë¥¼ ë”°ì§€ëŠ”ë°, ì „ê³µì—ì„œ ë§¤ìš° ì¤‘ìš”í•œ ìš”ì†Œì´ë‹¤.
		- ë¬¸ì œë¥¼ ì–´ë–»ê²Œ ì ‘ê·¼í•´ í•´ê²°í•¨ì— ë”°ë¼ n^2ê°œê°€ ìˆìŒì—ë„ ë¶ˆêµ¬í•˜ê³  í›¨ì”¬ ë” íš¨ìœ¨ì ìœ¼ë¡œ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆë‹¤.
	- ì´ëŸ° ìˆ˜ì—´ì´ ì£¼ì–´ì¡Œì„ ë•Œ ë¶„ëª… ë‹µì€ ì¡´ì¬í•œë‹¤:
	- alg 1, 2
		- ëª¨ë‘ -ë¼ë©´ ì •ë‹µì€ 0ì´ê³  :
			- -ì„ì„ í™•ì¸í•˜ëŠ” ë¹„ìš©ì€ linear time
		- ì–‘ìˆ˜ê°€ í•˜ë‚˜ë¼ë„ ìˆìœ¼ë©´ ì°¾ì•„ë³´ì•„ì•¼ í•œë‹¤

	0ì—ì„œ ì‹œì‘í•˜ëŠ”ê±° ë‹¤ ë”°ì ¸ë´ì„œ í•©ì´ ì œì¼ í° ê²ƒ ì°¾ê³ , â€”- 1, 2 ë²ˆì§¸ì—ì„œ ì‹œì‘í•˜ëŠ”ê±° ë‹¤ ë”°ì ¸ë´ì„œ í•©ì´ ì œì¼ í° ê²ƒ ì°¾ê³ . n-1 ê¹Œì§€ ì¤‘ ì œì¼ ì‘ì€ ê±° 


# MSS 1 - simple counting

- Strategy
	- Enumerate all possibilities one at a time.
	- No efficiency is considered, resulting in a lot of unnecessary computation!

		```c
		Maxsum = 0 for (i = 0; i < n; i++)
		{
		    for (j = i; j < n; j++)
		    {
		        Thissum = sum(A [i:j])
		            Maxsum = max(Thissum, Maxsum)
		    }
		}
		```

	- ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ í•˜ë‚˜í•˜ë‚˜ ëª¨ë‘ ë”°ì ¸ë³´ëŠ” ë°©ë²•.

		```c
		int MaxSubsequenceSum(const int A[], int N)
		{
		    int ThisSum, MaxSum, i, j, k;
		    // i = ë¦¬ìŠ¤íŠ¸ ì™¼ìª½ ë ì¸ë±ìŠ¤, j = ë¦¬ìŠ¤íŠ¸ ì˜¤ë¥¸ìª½ ë ì¸ë±ìŠ¤,
		    //  ThisSum = ê³ ë ¤ ëŒ€ìƒ ë¶€ë¶„ ë¦¬ìŠ¤íŠ¸ í•©, MaxSum = ë¬¸ì œ ìµœì¢…ê²°ë¡ 
		    MaxSum = 0;
		    for (i = 0; i < N; i++)
		        for (j = i; j < N; j++)
		        {
		            ThisSum = 0;
		            for (k = i; k <= j; k++)
		                ThisSum += A[k];
		            if (ThisSum > MaxSum)
		                MaxSum = ThisSum;
		        }
		    return MaxSum;
		}
		```

	- Is this for-loop OK for you?
	- Time Complexity :Â $O(N^3)$
		- ğ‘–ì™€ ê´€ë ¨ëœ ë°˜ë³µë¬¸ì€ ğ‘›në²ˆ, ğ‘—ì™€ ê´€ë ¨ëœ ë°˜ë³µë¬¸ì€ ìµœëŒ€ ğ‘›ë²ˆ, Thissumì„ êµ¬í•  ë•Œ ìµœëŒ€ ğ‘›ê°œì˜ ìš”ì†Œë¥¼ ê³„ì‚°í•´ì•¼ í•˜ê¸°ì—
		- $\sum_{i=0}^{N-1} \sum_{j=i}^{N-1} \sum_{k=i}^{j} 1 = \frac{N^3 + 3N^2 + 2N}{6}$

			```c
			for (i = 0; i < N; i++)
			```

		- $\sum_{j=i}^{N-1}\ (j-i+1) = \frac{(N-i+1)(N-i)}{2}$

			```c
			// for (i = 0; i < N; i++)
			    for (j = i; j < N; j++)
			   // {
			     //   ThisSum = 0;
			       // for (k = i; k <= j; k++)
			```

		- $\sum_{k=i}^{j} 1 = j-i+1$

			```c
			//for (i = 0; i < N; i++)
			//    for (j = i; j < N; j++)
			//    {
			//        ThisSum = 0;
			        for (k = i; k <= j; k++)
			```

	- 0ë²ˆì§¸ì—ì„œ ì‹œì‘í•´ì„œ Max êµ¬í•œ ê²ƒ,â€¦, në²ˆì§¸ì—ì„œ ì‹œì‘í•˜ì—¬ Max êµ¬í•œ ê²ƒ.
	- í¬ê²Œ ë°”ê¹¥ìª½ì—ì„œ for loopì´ ëŒë©´ì„œ ië²ˆì§¸ë¶€í„° ì‹œì‘í•´ì„œ i í•˜ë‚˜, ë‘ê°œ, ì„¸ê°œ, â€¦ ëª¨ë“  ê²ƒì„ ë‹¤ ë´ì„œ ië²ˆì§¸ì—ì„œ ì‹œì‘í•˜ëŠ” ê²ƒ ì¤‘ ê°€ì¥ í° ê²ƒì„ ì°¾ìœ¼ë ¤ í•œë‹¤.
	- for loopì€ i, i+1, i - i+2, i - n-1â€¦ ê¹Œì§€ ë”í•´ ë´„.

	> ğŸ’¡ [ê°œì„ ì ] ì´ì „ì— ë”í•œê²ƒì—ë‹¤ê°€ í•˜ë‚˜ë§Œ ë” ë”í•˜ë©´ ë˜ì§€ ì•Šì„ê¹Œ


![5](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/5.png)


# MSS 2

- Strategy

	> ğŸ’¡ ì´ì „ ìŠ¤íƒì—ì„œ í•˜ë‚˜ë§Œ ë” ë”í•˜ë©´ ë˜ëŠ” ê²ƒ ì•„ë‹Œê°€?

	- Get rid of the inefficiency in the innermost for-loop. Algorithm 1ë³´ë‹¤ ì¤‘ë³µì„ ì¤„ì´ëŠ” ë°©ë²•
	- for loopê°€ í•˜ë‚˜ ì‚¬ë¼ì§€ê²Œ ë¨.

		```c
		Maxsum = 0 for (i = 0; i < n; i++)
		{
		    for (j = i; j < n; j++)
		    {
		        Thissum = sum(A [i:j])
		            Maxsum = max(Thissum, Maxsum)
		    }
		}
		```

		- Notice thatÂ $\sum_{k=i}^{j } {A_k} = A_j + \sum_{k=i}^{j-1} {A_k}$

		```c
		int MaxSubsequenceSum(const int A[], int N)
		{
		    int ThisSum, MaxSum, i, j;
		    MaxSum = 0;
		    for (i = 0; i < N; i++)
		    {
		        ThisSum = 0;
		        for (j = i; j < N; j++)
		        {
		            ThisSum += A[j];
		            if (ThisSum > MaxSum)
		                MaxSum = ThisSum;
		        }
		    }
		    return MaxSum;
		```

	- time complexity :Â $O(N^3) \rightarrow O(N^2)$

![6](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/6.png)


# MSS  3 : Divide n Conquer


![7](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/7.png)

- Divide and Conquer
	- ê²½ìš°ì˜ ìˆ˜ë¥¼ ë”°ì§ : ì „ë¶€ ë‹¤ ìŒìˆ˜ê°€ ì•„ë‹ˆë¼ë©´ ë¶„ëª…íˆ í•˜ë‚˜ ì¡´ì¬í•œë‹¤.
	- 0ë²ˆ ì›ì†Œë¶€í„° n-1 ì›ì†Œê¹Œì§€ ìˆëŠ”ë° ì´ë¥¼ ë°˜ìœ¼ë¡œ 1/2ë¡œ ëš ìë¥´ê³ ,
		- í™€ìˆ˜ ê°œìˆ˜ë©´ ì •í™•íˆ ë‚˜ëˆ ì§€ì§€ ì•ŠìŒ, ì§ìˆ˜ ê°œìˆ˜ì´ë©´ ì •í™•íˆ ë‘˜ë¡œ ë‚˜ëˆ„ì–´ì§
	- left segmentì— ìˆë˜ì§€ right segmentì— ìˆë˜ì§€ ì–‘ë‹¤ë¦¬ ê±¸ì¹˜ë˜ì§€. ì˜ ì„¸ê°€ì§€ ì¼€ì´ìŠ¤ ì¤‘ ì œì¼ í° ê°’ì„ ì°¾ëŠ”ë‹¤.
	- â†’ ì´ ì „ì²´ì—ì„œ mssë¥¼ ì°¾ê³ ì í•˜ëŠ”ë°, ì¼ë‹¨ ì™¼ìª½í•˜ê³  ì˜¤ë¥¸ìª½ ê°ê°ì—ì„œ MSS ì°¾ê³ 
- ì›ë˜ í”Œê³ ì í•˜ëŠ” ë¬¸ì œì™€ problem sizeë§Œ ë‹¤ë¥´ë‹¤
	- ì „ì²´ subsequenceë¥¼ ë°˜ìœ¼ë¡œ ì˜ë¼ left- right segment ê°ê° ì˜ì—­ì—ì„œì˜ MSSë¥¼  ì°¾ê³ ì í•¨.
	- ê²°êµ­ ê°™ì€ ë¬¸ì œ : problem size ë§Œ 1/2, 1/2ëœ ì¼€ì´ìŠ¤
	- ì „ì²´ ë¬¸ì œ ì‚¬ì´ì¦ˆ 2ì¸ê²ƒì„ 1, 1ë¡œ divideí•˜ì—¬ ê°ê°ì˜ segmentì—ì„œ conquerí•˜ì—¬ ì°¾ëŠ”ë‹¤
	- with - â€˜Recursionâ€™
		- ìê¸° ìì‹ ì„ ë¶€ë¥¸ë‹¤ :
		- í•­ìƒ recursive callì„ í•  ë•ŒëŠ” problem sizeë¥¼ ì‘ê²Œ í•˜ì—¬ ë¶€ë¥¸ë‹¤.
		- ì–‘ë‹¤ë¦¬ ê±¸ì¹˜ëŠ” ê²ƒ ì¤‘ ì œì¼ í° ê²ƒì„ ì°¾ì•„ ë¹„êµ
		- ê° ë™ë„¤ì—ì„œ MSSë¥¼ ì°¾ì•„ ê·¸ ì¤‘ ì œì¼ í° ê²ƒì„ ëŒë¦°ë‹¤.
- Why is Log N
	- [ì‚¬ì§„]
	- Binary Treeì—ì„œ ê° depthë³„ë¡œ $1 , 2, 4, 8, ...$
	- $O (N \log N)$
- Strategy
	- Use the **Divide-and-Conquer** strategy.
		- ì› ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆ  í’€ê³ , ê·¸ ê²°ê³¼ë¥¼ í•©ì³ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
	- The maximum subsequence sum can be in one of three places.
	- êµì¬ì— íƒ‘ì¬ë˜ì–´ ìˆì§€ë§Œ ê·¸ë ‡ê²Œ ì¢‹ì€ ì½”ë“œê°€ ì•„ë‹Œë“¯ í•˜ë‹¤ !
	- leaf node 1ê°œê¹Œì§€ ë‚´ë ¤ì™”ì„ ê²½ìš° ì–‘ìˆ˜ì´ë©´ ê·¸ëŒ€ë¡œ returní•˜ê³  ìŒìˆ˜ì´ë©´ 0
	- Divide and Conquer
		- centerë¥¼ ì°¾ì•„ ì¤‘ì•™ ì§€ì  : ë˜‘ê°™ì€ ë¬¸ì œ [index left-right] ë¥¼ í’€ì§€ë§Œ [left-center], [center-right]ë¡œ ì›ë˜ í’€ê³ ì í•˜ëŠ” ë¬¸ì œë¥¼ divideí•´ì„œ í‘¼ë‹¤.
		- recursionì˜ ë¬˜ë¯¸ : ë§‰ì•„ì£¼ëŠ” ë¶€ë¶„ (else return 0)ì´ ìˆì–´ì•¼ top-downìœ¼ë¡œ ë‚´ë ¤ê°ˆ ìˆ˜ ìˆëŠ” divide and conquer

		```c
		int MaxSubSum(const int A[], int Left, int Right)
		{
		    int MaxLeftSum, MaxRightSum;
		    int MaxLeftBorderSum, MaxRightBorderSum;
		    int LeftBorderSum, RightBorderSum;
		    int Center, i;
		    //ì¢…ë£Œì¡°ê±´if (Left == Right){
		    if (A[Left] > 0)
		        return A[Left];
		    else
		        return 0;
		}
		// divide n conquer
		Center = (Left + Right) / 2;
		//ì™¼ìª½, ì˜¤ë¥¸ìª½, ì¤‘ê°„
		MaxLeftSum = MaxSubSum(A, Left, Center);
		MaxRightSum = MaxSubSum(A, Center + 1, Right);
		
		MaxLeftBorderSum = 0;
		LeftBorderSum = 0;
		// 1. left ending ëìœ¼ë¡œ í•˜ëŠ” mss
		for (i = Center; i >= Left; i--)
		{
		    LeftBorderSum += A[i];
		    if (LeftBorderSum > MaxLeftBorderSum)
		        MaxLeftBorderSum = LeftBorderSum;
		}
		MaxRightBorderSum = 0;
		RightBorderSum = 0;
		
		// 2. right ending ì‹œì‘ìœ¼ë¡œ í•˜ëŠ” mss
		for (i = Center; i <= Right; i++)
		{
		    RightBorderSum += A[i];
		    if (RightBorderSum > MaxRightBorderSum)
		        MaxRightBorderSum = RightBorderSum;
		}
		return Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);
		// MaxLeftSum - left segmentì˜ sum
		// MaxRighttSum - right segmentì˜ sum
		// MaxLeftBorderSum - ê°€ìš´ë°ì—ì„œ leftë¡œ ê°€ëŠ” ê²ƒë“¤ ì¤‘ ìµœëŒ€
		}
		int MaxSubsequenceSum(const int A[], int N)
		{
		    return MaxSubSum(A, 0, N - 1);
		}
		```

		- // ìŒìˆ˜ê°€ ë˜ëŠ” ê²½ìš°ì´ë”ë¼ë„ ì–‘ë‹¤ë¦¬ê°€ ê±¸ì¹  ìˆ˜ ìˆë„ë¡ ì„¤ê³„í•  ê²ƒ
			- 

		![8](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/8.png)


		```c
		int MaxSubSum(const int A[], int Left, int Right)
		{
		    int MaxLeftSum, MaxRightSum;
		    int MaxLeftBorderSum, MaxRightBorderSum;
		    int LeftBorderSum, RightBorderSum;
		    int Center, i;
		    //ì¢…ë£Œì¡°ê±´if (Left == Right){
		    if (A[Left] > 0)
		        return A[Left];
		    else
		        return 0;
		}
		// divide n conquer
		Center = (Left + Right) / 2;
		//ì™¼ìª½, ì˜¤ë¥¸ìª½, ì¤‘ê°„
		MaxLeftSum = MaxSubSum(A, Left, Center);
		MaxRightSum = MaxSubSum(A, Center + 1, Right);
		
		// ìŒìˆ˜ê°€ ë˜ëŠ” ê²½ìš°ì´ë”ë¼ë„ ì–‘ë‹¤ë¦¬ê°€ ê±¸ì¹  ìˆ˜ ìˆë„ë¡ ì„¤ê³„í•  ê²ƒ
		
		MaxLeftBorderSum = A[i];
		LeftBorderSum = 0;
		// 1. left ending ëìœ¼ë¡œ í•˜ëŠ” mss
		for (i = Center; i >= Left; i--)
		{
		    LeftBorderSum += A[i];
		    if (LeftBorderSum > MaxLeftBorderSum)
		        MaxLeftBorderSum = LeftBorderSum;
		}
		
		MaxRightBorderSum = 0;
		RightBorderSum = 0;
		
		// 2. right ending ì‹œì‘ìœ¼ë¡œ í•˜ëŠ” mss
		for (i = Center; i <= Right; i++)
		{
		    RightBorderSum += A[i];
		    if (RightBorderSum > MaxRightBorderSum)
		        MaxRightBorderSum = RightBorderSum;
		}
		return Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);
		// MaxLeftSum - left segmentì˜ sum
		// MaxRighttSum - right segmentì˜ sum
		// MaxLeftBorderSum - ê°€ìš´ë°ì—ì„œ leftë¡œ ê°€ëŠ” ê²ƒë“¤ ì¤‘ ìµœëŒ€
		}
		int MaxSubsequenceSum(const int A[], int N)
		{
		    return MaxSubSum(A, 0, N - 1);
		}
		```

- cost :Â $T(n) = 2T(\frac n 2) + cn$,Â $T(1) = d$
- whyÂ O(N log N)_O_(_NlogN_)Â ?
	- $T(n) = 2T(\frac n 2) + cn$
	- $T(1) = d$

		$= 2 [ 2T(\frac n {2^2}) + c \frac n 2 ] + cn$


		$= 2^2 T [ \frac n {2^2}] + 2cn$


		$= 2^3 T [ \frac n {2^3}] + 3cn =...$


		$= 2^i T [ \frac n {2^i}] + icn$


		$= 2^{\log_2 n} T(1) + \log_2 n \cdot cn$


		$=nT(1) + \log_2 n \cdot cn$


		$= O(n) + O(n \log_2 n) = O(n \log_2 n)$


# MSS  4; Kadaneâ€™s algorithm

- ië²ˆì§¸ ì›ì†Œë¡œ ëë‚˜ëŠ” ê°€ì¥ í•©ì´ í° subsequenceê°€ ì–˜ë¼ë©´, ë‹¤ë¥¸ ë‚˜ë¨¸ì§€ë¥¼ ë¶„ë¦¬í–ˆì„ ë•Œ i-1ë¡œ ëë‚˜ëŠ” subsequenceì´ë‹¤.

	![9](/assets/img/2022-09-08-[ALG]-1.4.-MSS-(1).md/9.png)

	- ì•„ë‹ˆë‹¤ â†’ ëª¨ìˆœ ì¦ëª… : ê³ ë“±í•™êµ proof by contradiction ê·€ë¥˜ë²•ìœ¼ë¡œ
	- iì›ì†Œë¡œ ëë‚˜ëŠ” í•©ì´ ì œì¼ í° subsequenceëŠ” ì–˜ì¸ë°, í•©ì´ ì œì¼ í° subsequenceê°€ ë˜ì–´ì•¼ í•œë‹¤.
	- í•©ì´ ì œì¼ í° ë¶€ë¶„ì„ ì°¾ëŠ”ë°, ë‚˜ë³´ë‹¤ í•˜ë‚˜ ì•ì•  ìˆëŠ” i-1ê¹Œì§€ì˜ sequenceë¡œ ë°”ë€ë‹¤.
		- recursionì´ë‘ ë¹„ìŠ· : ê°™ì€ ë¬¸ì œë£° í‘¸ëŠ”ë° ë¬¸ì œ í¬ê¸°ê°€ ë‹¬ë¼ì§. ì´ë¥¼ ì–´ë–¤ í˜•ì‹ìœ¼ë¡œ í•´ê²°í•˜ëŠëƒì— ë”°ë¼ì„œ ë‹¬ë¼ì§€ê²Œ ë¨.
	- ië²ˆì§¸ ëë‚˜ëŠ” subsequenceì¤‘ì— ì—¬ëŸ¬ê°€ì§€ ìˆì„ ìˆ˜ ìˆëŠ”ë°, ê·¸ ì¤‘ ê°€ì¥ í•©ì´ í° ê²ƒì„ Bië¼ê³  í•  ë•Œ
		- $B[i]$ : the sum of the maximum subsequence that ends at index $i$
		- $B[i] = \max \{ B[i-1] + A[i], 0\}$
- Strategy
	- Use the Dynamic Programming strategy.
	- subsequence sum<0ì¸ ê²½ìš°, ë…¼ë¦¬ì ìœ¼ë¡œ ìµœëŒ€ê°’ì´ ë  ìˆ˜ ì—†ìŒì— ì°©ì•ˆí•œ ì „ëµ
	- ë§Œì•½ì— sumì´ ìŒìˆ˜ë¼ë„ ë¬´ë°©í•˜ê³  1ê°œ ì´ìƒì˜ ì›ì†Œë¡œ êµ¬ì„±ëœ Subsequence (subarray)ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œë¼ë©´?

		```c
		int MaxSubsequenceSum(const int A[], int N){
		    int ThisSum, MaxSum, i;
		
		    ThisSum = 0; // jë²ˆì§¸ ì›ì†Œë¥´ ëë‚˜ëŠ” ê²ƒ ì¤‘ í•©ì´ ì œì¼ í° ê²ƒ
				MaxSum = 0; // ì§€ê¸ˆê¹Œì§€ì˜ ì›ì†Œë¥´ ëë‚˜ëŠ” ê²ƒ ì¤‘ í•©ì´ ì œì¼ í° ê²ƒ
		    for(i = 0; i < N; i++){
		        ThisSum += A[i];
		        if(ThisSum > MaxSum)
		            MaxSum = ThisSum;
		        else if(ThisSum < 0)
		            ThisSum = 0;
					// if (ThisSum<0) ThisSum=0; 
					// else if (ThisSum>MaxSum) MaxSum = ThisSum;
		    }
		    return MaxSum;
		}
		```

	- thissum : j ë²ˆì§¸ ëŒ ë•Œ j-1ë²ˆì§¸ ì›ì†Œë¡œ ëë‚˜ëŠ” ê²ƒ ì¤‘ ì œì¼ í•©ì´ í° ê²ƒ.
		- `ThisSum += A[j]`
	- ThisSum â†’ 0, jë²ˆì§¸ ì›ì†Œë¡œ ëë‚˜ëŠ” ê²ƒ ì¤‘ ê°€ì¥ í° ê±°ë³´ë‹¤ í¬ë©´ ë°”ê¿”ì¹˜ê¸°í•˜ê³ ..
	- ìµœì†Œí•œ ëª¨ë“  ì›ì†Œë¥¼ í•œ ë²ˆì”©ì€ ë´ì•¼ í•˜ê¸° ë•Œë¬¸ì— linearë³´ë‹¤ ë” ë¹ ë¥¸ algëŠ” ì—†ë‹¤.
	- Time Complexity :Â $O(n)$
		- for i, iteration n times, and $Â O(1$)Â for 1 calculation
	- C Implementation
		- Maximum sum rectangle in a 2D matrix (DP-27) by GeeksforGeeks

			```c
			int kadane(int *arr, int *start, int *finish, int n)
			{
			    int sum = 0, maxSum = INT_MIN;
			
			    *finish = -1;
			    int local_start = 0;
			    for (int i = 0; i < n; ++i)
			    {
			        sum += arr[i];
			        if (sum < 0)
			        {
			            sum = 0;
			            local_start = i + 1;
			        }
			        else if (sum > maxSum)
			        {
			            maxSum = sum;
			            *start = local_start;
			            *finish = i;
			        }
			    }
			    if (*finish != -1)
			        return maxSum;
			// at least one non-negative number.
			
			// When all numbers in the array are negative
			    maxSum = arr[0];
			    *start = *finish = 0;
			    for (int i = 1; i < n; i++)
			    {
			        if (arr[i] > maxSum)
			        {
			            maxSum = arr[i];
			            *start = *finish = i;
			        }
			    }
			// Empty subsequenceë¥¼ í—ˆìš©í•˜ë©´ 0ì„ ë¦¬í„´ (ì›ë˜ ë¬¸ì œ)
			// Empty subsequenceë¥¼ í—ˆìš©í•˜ì§€ ì•Šìœ¼ë©´ ìŒìˆ˜ ì¤‘ ê°€ì¥ í° ì›ì†Œë¥¼ ë¦¬í„´
					return maxSum;
			}
			
			
			
			```


### So, why do we bother with the time complexity?


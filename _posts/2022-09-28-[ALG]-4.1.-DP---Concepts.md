---
layout: post
date: 2022-09-28
title: "[ALG] 4.1. DP - Concepts"
tags: [Algorithm, ]
categories: [Notes, ]
use_math: true
---

- divide and conquer: top - down
	- íš¨ìœ¨ì ì´ê¸°ë„ í•˜ë‚˜ ë§¤ìš° ë¹„íš¨ìœ¨ì ì´ ë˜ê¸°ë„ í•¨
	- splittedëœ ì‚¬ë¡€ë“¤ì´ ì„œë¡œ ê´€ë ¨ ì—†ëŠ” ë¬¸ì œë¥¼ í’€ë•Œ ì˜ í†µí•¨
- dynamic programming : bottom -up
	- ì•„ë˜ì—ì„œ ìœ„ë¡œ ì˜¬ë¼ê°€ë©° íš¨ìœ¨ì„ ì¶”êµ¬í•˜ìëŠ” ë°©ì‹
- NOW
	- Divide-and-Conquer Method
	- **Dynamic Programming Method**
	- Greedy Method
	- Backtracking Method
	- Local Search Method
	- Branch-and-Bound Method
	- Etc.
- FromÂ [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_programming): Dynamic programming is both a
	- <u>mathematical optimization method and a computer programming method.</u>
- A complicated problem isÂ **broken down into simpler sub-problems in a recursive manner**.
- Overlapping subproblems
	- A problem is broken down into subproblems which are reused several times or a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblems.
- Optimal substructure
	- A solution to a given optimization problem can be constructed efficiently from optimal solutions of its subproblems.
- When applicable, the methodÂ <u>**takes far less time than other methods**</u>Â that don't take advantage of the subproblem overlapÂ **like the divide- and-conquer technique**.

â†’ ë¬¸ì œ ëª‡ê°œ í’€ì–´ë³´ê³ , ì´ ê³ ìƒí•œ ë§ë“¤ì´ ë³„ ê²ƒ ì•„ë‹Œ ìì—°ìŠ¤ëŸ¬ìš´ ì›ë¦¬ì„ì„ ì²´ë“í•˜ì!


# [ALG] 4.2. Approaches for Recursive Formulation (1)


Two Approaches for Recursive Formulation

- Top Down Approach
- Bototm up Approach

## 4.2.1. Top Down Approach

- $T(i,j) = T(i-1,j) + T(i, j-1) + C \cdot (2i + j), i,j \geq 1$
- $T(i,0) = T(0,j) = 1$Â forÂ $i,jâ‰¥0$
- recursiveí•˜ê²Œ ë˜‘ê°™ì´ ë¬¸ì œ ë‘ê°œë¥¼ í‘¼ë‹¤ : ë¹¨ê°„ ê²ƒ í•˜ë‚˜, ë…¹ìƒ‰ í•˜ë‚˜. ê·¸ë¦¬ê³  ê·¸ ê²°ê³¼ë¥¼ combineí•˜ì—¬ ì›ë˜ ë¬¸ì œë¥¼ í‘¼ë‹¤. ë¬¸ì œê°€ ê²¹ì¹˜ëŠ”ê²Œ ë³´ì¸ë‹¤.
	- divide and conquer : ìƒë‹¹íˆ ë§ì´ overlapë¨ì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.
	- 
undefined- Easily becomes exponential!

	![0](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/0.png)


recursive function call : ë‚´ë ¤ê°”ë‹¤ ì˜¬ë¼ê°”ë‹¤ depth first searchí•˜ë‹¤ê°€ í•˜ì—¼ì—†ì´ ëŒì•„ì˜¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤.


## 4.2.2. Bottom Up Approach

- $T(i,j) = T(i-1,j) + T(i, j-1) + C \cdot (2i + j),Â i,jâ‰¥1$
- $T(i,0) = T(0,j) = 1$Â forÂ $i,j \geq 0$
- Often much more efficient!

	![1](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/1.png)

- ê·¸ëŸ¬ë‚˜ bottom upì€ Top Downê³¼ ëŒ€ë¹„í•˜ì—¬ ì­‰ ì­‰ ì­‰ í•œ ì¤„ë¡œ ë‚´ë ¤ê°€ë©° ì˜ í’€ë¦¬ê²Œ ëœë‹¤.
	- bottom upìœ¼ë¡œ ì˜¬ë¼ì˜¤ë©´ì„œ, ê·¸ë¦¬ê³  ëª¨ë“  ê²½ìš°ì— divide n conquerì— ë¹„íš¨ìœ¨ì ì´ê³  dpê°€ íš¨ìœ¨ì ì¸ê±´ ì•„ë‹ˆë‹¤.
- Bottom up vs. Top down ê³µí†µ: ë‘˜ë‹¤ ì–´ë–¤ ë¬¸ì œê°€ ì¬ê·€ì ì¸, recursiveí•œ í˜•íƒœë¡œ ë¬¸ì œê°€ í’€ë¦¬ê²Œ ëœë‹¤.
	- ì‘ê²Œ ë˜‘ê°™ì´ í’€ì–´ì„œ í•©ì¹˜ì : recursion í•œ solutionì´ ë‚˜íƒ€ë‚˜ê²Œ ëœë‹¤
	- solutionì„ ë§Œë“œëŠ”ë° ì¬ê·€ì ìœ¼ë¡œ ë‚˜íƒ€ë‚œë‹¤.
- ëª‡ ê°œ ì•ˆ ë˜ëŠ” ê²ƒì„ í’€ë©´ ë˜ëŠ”ë°, ë˜‘ê°™ì€ê²ƒì„ ë°˜ë³µì ìœ¼ë¡œ ë³´ë‚˜?
	- ì´ë¥¼ ê³„ì‚°í•˜ëŠ” í”„ë¡œê·¸ë¨: ì´ë¥¼ í’€ê¸° ìœ„í•´ì„œ í•„ìš”í•œ ê²ƒì€ ì™¼ìª½ í•˜ë¶€, ì˜¤ë¥¸ìª½ í•˜ë¶€
	- ê±°ê¾¸ë¡œ ìƒê°í•´ë³´ë©´ : ì™¼ìª½ ì•„ë˜ + ì˜¤ë¥¸ìª½ ì•„ë˜ í™œìš©í•´ì„œ ê·¸ ìœ„ ê°€ìš´ë° ë…¸ë“œë¥¼ êµ¬í•  ìˆ˜ ìˆë‹¤. (ì•„ë˜ì—ì„œ ìœ„ë¡œ)
- ì•„ë¬´ë¦¬ ë¶€ì •í•˜ë ¤ê³  í•˜ë”ë¼ë„ ì¸ì •í•  ìˆ˜ë°–ì— ì—†ëŠ” ì›ë¦¬.

## 4.2.3. Examples


### 4.2.3.1. [ex1] World Series Odds

- Problem
	- Dodgers and Yankees are playing the World Series in which either team needs to winÂ _n_Â games first.
	- Suppose that each team has a $50%$ % chance of winning any game.
	- LetÂ _P_(_i_,_j_)Â be the probability that if Dodgers needsÂ _i_Â games to win, and Yankees needsÂ _j_Â games, Dodgers will eventually win the Series.
		- ië²ˆì„ ë” ì´ê²¨ì•¼ ë‹¤ì €ìŠ¤ëŠ” ìš°ìŠ¹í•  ìˆ˜ ìˆêµ¬ ì–‘í‚¤ìŠ¤ëŠ” ì„¸ë²ˆ ì´ê¸°ëŠ”ë° ì´ ë•Œ ë‹¤ì ¸ìŠ¤ê¸° ìš°ìŠ¹í•  í™•ë¥ ì€
		?
	- Ex:Â $P(2, 3) = \frac {11}{16}$ì•¼
		- í‚¤ìŠ¤ëŠ” ë‘ë²ˆ, ë‹¤ì €ìŠ¤ëŠ” 3ë²ˆ
	- ComputeÂ $P(i,j)Â 0â‰¤i,jâ‰¤nÂ âˆ€n$

		![2](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/2.png)

		- ì„ì˜ì˜ nì— ëŒ€í•´ì„œ í™•ë¥ ì„ ê³„ì‚°í•˜ë¼ : ê·¸ë¦¼ì„ ë³´ê³ , recursion êµ¬ì¡°ê°€ ë– ì˜¤ë¥´ëŠ”ê°€?
			- ë¬¸ì œ ì‚¬ì´ì¦ˆ $( i,j) = (i-1,j) + (i, j-1)$
			- 0.5, 0.5 : dodgersì´ê±°ë‚˜ yankeesì¸ë° dodgersê°€ ì´ê¸°ë©´ $(i-1,j)$
			- ì¡°ê±´ë¶€ í™•ë¥  : $P(i,j) = 0.5 P(i-1,j) + 0.5P(i, j-1)$ rlê¸°ë³¸ì ì¸ìˆ˜ì‹

![3](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/3.png)


### 4.2.3.2. [Worse] A Divide-and-Conquer Approach

- Recursive formulation
	- $P(i,j) =1Â ifÂ i=0,j>0$
	- $P(i,j) =0 if i=0,j=0$
	- $P(i,j)= \frac{P(i-1,j)+P(i,j-1)}{2}=2P(iâˆ’1,j)+P(i,jâˆ’1)$

		if $i>0, j>0$

- overlap subproblem : overlappingí•˜ì§€ ì•Šìœ¼ë©´ì„œ sizeê°€ ì¤„ì—ˆë˜ dncì™€ ë‹¬ë¦¬ overlappingëœë‹¤. êµ‰ì¥íˆ ì•ˆ ì¢‹ì€ ìƒí™©. ê·¸ë˜ì„œ ì´ë¥¼ recursive fn call í•¨ìˆ˜ë¥¼ ì§œì„œ $P(100,100), P(50,50)$ì§œë³´ë¼
	- â†’ ì‚¬ì‹¤ ëŒë ¤ì§€ì§€ë„ ì•ŠëŠ”ë‹¤. ì‹œê°„ì´ ë„ˆë¬´ ê±¸ë ¤ ì»´í“¨í„°ê°€ ì£½ì–´ë²„ë¦°ë‹¤.
- If we solve this recurrence relation in the divide-and-conquer way,
	- LetÂ _T_(_n_) be the maximum time taken by a call toÂ _P_(_i_),whereÂ _i_+_j_Â =_n_.
	- Then we can prove thatÂ _T_(_n_) is exponential!
	- $T(1)=1,Â T(n) = 2T(n-1) + c \rightarrow O(2^n)$
- What is the problem of this approach?

![4](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/4.png)


### 4.3.2.3. [Better] A Dynamic Programming Approach

- í•µì‹¬ ê°œë… Table
	- 1D, 2D, 3D
- $T(4,4) $: table setup í›„ ì´ë¥¼ ì±„ì›Œë‚˜ê°€ì„œ (fill)
	- ë‹¨ã„·ìˆœí•˜ê²Œ ìƒê°í•˜ë©´ 2 ì¤‘ for loop í™œìš©í•˜ì—¬ ì§„í–‰í•œë‹¤.
	- 0,0ì€ ì–‘ìª½ ë‹¤ ìš°ìŠ¹í•œ ê²ƒì´ê¸°ì— ê³ ë ¤í•  í•„ìš” ì—†ë‹¤.
- í•œì¹¸ ì—¬í´ ì™¼ìª½ì— ìˆëŠ” ì• ì™€, í•œì¹¸ ì•„ë˜ ë°‘ìª½ì— ì‡ëŠ” ì• ë¥¼ í†µí•´ ê³„ì‹¼í•  ìˆ˜ ìˆë‹¤.
- $P(i,j) = 1 $ if $i=0, j>0$
- $P(i,j) = 0$ if $i>0, j=0$
- $P(i,j) = \frac{P(i-1,j) + P(i, j-1)}{2}$ if $i>0, j>0$
- fill í•˜ëŠ” ë°©ì‹
	- ì¢Œâ†’ìš° (ë°‘ì—ì„œ ìœ„ë¡œ): ê°€ëŠ¥
	- ë°‘â†’ìœ„ (ì¢Œì—ì„œ ìœ„ë¡œ) : ê°€ëŠ¥
	- ê¸°ì¡´ì˜ í”Œë¡œìš°ëŠ” ëŒ€ê°ì„  ìš°ìƒí–¥ì´ê¸°ë•Œë¬¸ì— ê°€ëŠ¥!
	- ê¸°êµë¥¼ ë¶€ë¦¬ê³  ì‹¶ìœ¼ë©´ ã„¹or loopì„ ë³µì¡í•˜ê²Œ í•´ì„œ êµ¬í˜„í•  ìˆœ ìˆë‹¤.
		- ê·¸ëŸ¬ë‚˜ ë‹¨ìˆœí•˜ë©´ì„œ ì˜ ì‘ë™í•˜ëŠ”ê²ƒì´ ë” ì¤‘ìš”í•˜ë‹¤.
- $T(n,n) = O(n^2)$dì„ì„ ë°”ë¡œ í™•ì¸í•´ì•¼í•œë‹¤.
	- table ì›ì†Œê°€ ê°€ë¡œ n, ì„¸ë¡œ nì¼ ë•Œ
	- n+1, n+1ê°œê°€ ìˆê³ 
	- ìƒìˆ˜ì‹œê°„ì´ë¯€ë¡œ ì‹œê°„ ë³µì¡ë„ëŠ” nììŠ¹ì´ ëœë‹¤. â†’ ì‹œê°„ë³µì¡ë„ëŠ”
- Instead of computing the same repeatedly, fill in a table as suggested below:
	- 

		![5](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/5.png)

- Time Complexity
	- For input sizeÂ $(m, n)$, computingÂ $P(m, n)$ takesÂ $O(mn)$-time.
	- By far better than the Divide-and-Conquer approach.

		![6](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/6.png)

undefined
![7](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/7.png)

- DP ë¬¸ì œë¥¼ í‘¸ëŠ”ë° ì´ëŸ¬í•œ recursive structureê°€ ì¡´ì¬í•˜ê³ , ì´ë¥¼ divide and conquer ë¡œ top downìœ¼ë¡œ í’€ì–´ì•¼ í•œë‹¤ë©´ overlapping subproblemì˜ ë¬¸ì œê°€ë°œìƒí•œë‹¤.
	- ìƒë‹¹í•œ ì–‘ì˜ ë¬¸ì œê°€ ìˆë‹¤ : divide and conquerë¡œ ê°€ì§€ ë§ê³  dpë¡œ ê°€ëŠ”ê±´ ì–´ë–¨ê¹Œ?
	- ì–´ë–¤ ë¬¸ì œë¥¼ subproblemì„ í†µí•´ recursiveí•˜ê²Œ í’€ë ¤ í•˜ëŠ”ë° ë¬¸ì œê°€ ì–´ë–»ê²Œ í’€ë¦¬ë”ë¼: dncê°€ ì•„ë‹ˆë¼ bottom up ë°©ì‹ìœ¼ë¡œ í’€ë„ë¡ ìƒê°í•˜ê³ 
	- tableì„ 1ì°¨-3ã…ì°¨ì›ìœ¼ë¡œ êµ¬ì„±í•˜ê³ , ì´ˆê¸°í™”í•˜ê³ , ì¼ë°˜í™”ëœ ê³µì‹ìœ¼ë¡œë¶€í„° fill í•˜ëŠ ë°©ì‹ì„ ì•Œì•„ ì›ì†Œë¥¼ ì±„ì›Œ ë‚˜ê°„ë‹¤
- ê°ê°ì˜ subproblem
	- ë¬¸ì œë¥¼ ê°ê° í•œ ë²ˆì”©ë§Œ í‘¼ë‹¤ : bottom up ë°©ì‹ìœ¼ë¡œ tableì„ ì±„ì›Œë‚˜ê°€ì„œ ëª©ì ì„ ë‹¬ì„±í•˜ëŠ” ê²ƒ : DPì˜ ì‹œì‘ê³¼ ëì´ë‹¤
	- overlapping substructure ë“± ë³µì¡í•œ ê±° ìƒê°í•  í•„ìš” ì—†ì´, ì´ê²ƒì´ ì „ë¶€!

# [ALG] 4.3. Concepts of Dynamic Programming (1)


# Dynamic Programming


> Top-down â†’ Bottom-up

- When theÂ **divide-and-conquer**Â approach produces anÂ **exponential algorithm**Â whereÂ **the same sub-problems are solved iteratively**,
	- Take the recursive relation from the divide-and-conquer algorithm, and
	- replaceÂ **the recursive calls with table lookups**Â by recording a value in a table entry instead of returning it.
- master theoremê³¼ë„ ì—°ê³„
	- overlapping ë‚˜ìœê±° (a>c)
- Three elements to consider in designing a dynamic programming algorithm
	- Recursive relation
		- Optimal substructure
	- Table setup
	- Table fill order
	- $B(i,j)=B(i-1,j-1) + B(i-1,j)$ if $0<j<i$
	- $B(i,j)=1$Â ifÂ $j=0$Â orÂ $j=i$
- [Neapolitan] DP Procedure
	- input caseì— ëŒ€í•´ solutionì„ ê³„ì‚°í•˜ëŠ” recursive property ì„¸ìš°ê¸°
	- ì‘ì€ input caseë¶€í„° ë¨¼ì € í•´ê²°í•˜ëŠ” bottom upì„ í†µí•œ ì „ì²´ Inputì— ëŒ€í•´ Solution êµ¬ì¶•

# Application of DP


# 4.3.1. The Manhattan Tourist Problem

- Courtesy of [Jones & Pevzner 6.3]

	![8](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/8.png)

- Problem:
	- Given two street corners in the borough of Manhattan in New York City, find the path between them with the maximum number of attractions, that is, a path of maximum overall weight.
	- Assume that a tourist mayÂ <u>**move either to east or to south only**</u>

> ğŸï¸ ì–´ë–»ê²Œ í•˜ë©´ ë§ì€ ê´€ê´‘ì§€ë¥¼ì„ ìµœëŒ€ë¡œ ë°©ë¬¸í•  ìˆ˜ ìˆê² ëŠ”ê°€?

- (1) A <u>brute force</u> approach
	- ëª¨ë“  ê²½ë¡œ ë‹¤ ë”°ì ¸ë³´ê¸° : ëª‡ê°œ ë‚˜ì˜¬ê¹Œ? ê°ê° n, mì¹¸ì´ë¼ê³  í• ë•Œ(ì„¸ë¡œ, ê°€ë¡œ)
		- ì´ë¥¼ ë”°ì ¸ë³´ë©´ : $2^n, 2^m, n!, m!$ì´ ë‚˜ì˜¨ë‹¤ â†’ ëª¨ë“  ê²½ìš°ë¥¼ ë”°ì§€ë©´ exponential, factorial timeì´ ë‚˜ì˜¤ê¸°ì— í’€ ìˆ˜ ì—†ë‹¤.
	- Search among all paths in the grid for the longest path!
	- nì´ ì¡°ê¸ˆ ì»¤ë„ ì•Œ ìˆ˜ ìˆë‹¤.
- (2) A greedy approach
	- ë‹¤ìŒ ê°•ì˜ ì£¼ì œ
- <u>A formal description of this problem</u>
	- Given a weighted graph (grid)Â _G_Â of sizeÂ (_n_,_m_)Â with two distinguished vertices, a sourceÂ (0,0)Â and a sinkÂ (_n_,_m_), <u>**find a longest path between them**</u> in its weighted graph.Â (0,0)
		- find â€˜aâ€™ : í•˜ë‚˜ë§Œ ì°¾ê¸°
	- graph : vertex-vertex ê°„ ê´€ê³„ë¥¼ ë‚˜íƒ€ë‚´ì£¼ëŠ” edgeë¡œ edgeëŠ” directional/nondirectionalì¼ ìˆ˜ ìˆë‹¤
		- undirected / directed edge : arc
			- directed graph : digraph
			- edgeì— ë°©í–¥ì„±ì´ ìˆëŠ”ê°€ ì—†ëŠ”ê°€ëŠ” vertex ê´€ê³„ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤.
			- directed : ex. aëŠ” bë¥¼ ì¢‹ì•„í•˜ê³ , bëŠ” cë¥¼ ì¢‹ì•„í•˜ê³ ,, : ë°©í–¥ì„± ì¡´ì¬
	- weighted : ê° edgeì— ê°’ì´ ì‡ëŠ”ê²½ìš°
	- â†’ weighted digraph
- ì›ë˜ ë¬¸ì œì— ëŒ€í•´ì„œ ë‘ ê°œì˜ subproblem ìœ¼ë¡œ í‘¸ëŠ” ê²ƒ

	![9](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/9.png)

- ê²½ë¡œëŠ” ë‹¬ë¼ë„ ê¸¸ì´ëŠ” ê°™ì€ longest pathëŠ” ì¡´ì¬í•  ìˆ˜ ìˆë‹¤.
	- ë‘˜ì¤‘ì— í•˜ë‚˜ë¡œ ì¶œë°œí•˜ê±°ë‚˜ ë„ì°©í•¨
		- 1) ì•„ë˜ë¡œ ì¶œë°œí•˜ê±°ë‚˜
		- 2) ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì¶œë°œí•˜ê±°ë‚˜
	- ì•Œê³ ë¦¬ì¦˜ì„ ì–´ë–»ê²Œ ìƒê°í•´ëƒˆì„ê¹Œì— ëŒ€í•˜ì—¬ ì ‘ê·¼í•´ë³´ì!
	- ë‘˜ ì¤‘ì— í•˜ë‚˜ì¸ë°, ì˜¤ë¥¸ìª½ì—ì„œ ì˜¤ëŠ” ê²ƒì´ ìµœì¢… longest pathë¼ë©´
		- (4,4) ê¹Œì§€ ì´ë¥´ëŠ” ë°©ë²•ì—ëŠ” (4,3) - (3,4)ì´ë¯€ë¡œ ê°ê°ì— ëŒ€í•œ ã…£ongest pathë¥¼ êµ¬í•´ë³´ë©´ ëœë‹¤
		- â†’ divide and conquerë¡œ í’€ì´
- ìƒê°ì˜ íë¦„
	- divide and conquerë¥¼ ì¼ì„ ë•Œ, overlapping subproblemì„ í™œìš©í–‡ê¸°ì— worse ë¨
	- recursive top-down ì´ë©´ ë˜‘ê°™ì€ ì‹ìœ¼ë¡œ (4,2) í˜¹ì€ (3,3)ì˜ í˜•íƒœì˜ longest pathë¥¼ ì°¾ì•„ì•¼ í•œë‹¤
	- â†’ ì‹¬ê°í•´ì§€ëŠ” overlapping problem
- solution : DP (bottom up)
	- 0,0 ì—ì„œ 4,3 ì— ì´ë¥´ê¸°ê¹Œì§€ì˜ ë¬¸ì œë¥¼ í•œ ë²ˆì”©ë§Œ í’€ê³  ë°‘ì—ì„œë¶€í„° ìœ„ë¡œ ì˜¬ë¼ê°€ì.
- divide and conquerì˜ overlapping subproblemìœ¼ë¡œ ìƒë‹¹íˆ ë§¤ì¹­
	- top down: overlapping subproblem â†’ ìƒë‹¹íˆ ë§ì´ ê²¹ì¹˜ëŠ” í¬ì¸íŠ¸
	- bottom up : ì„œë¡œ ì„œë¡œë¥¼ ê³„ì‹¼í•˜ë©° ê²°ê´ê°’ ì‚°ì¶œ
- An example grid of sizeÂ (4,4)
	- GRID : íŠ¹ìˆ˜í•œ í˜•íƒœì˜ ê²©ìì²˜ëŸ¼ ìƒê¸´ graph

		![10](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/10.png)

- shortest pathê°€ ì•„ë‹Œ longest path ë¬¸ì œ
	- DP ë¬¸ì œì™€ ì–´ë–¤ ê´€ê³„ê°€ ìˆì„ê¹Œ?
	- recursive solutionì´ ë³´ì´ëŠ”ê°€?
- A possible selection determined by a greedy approach

![11](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/11.png)

- <u>**Basic idea**</u>
	- How can you use the solutions of smaller problems to build a solution of a problem?
		- 

			![12](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/12.png)

	- $s_{i,j} = \max\{s_{i-1,j}+ w_{i,j} , \}$
	- directed edge = arc
	- ìœ„ì—ì„œ i,jë¡œ ë‚´ë ¤ì˜¬ ë•Œì˜ weight,
	- ì™¼ìª½ì—ì„œ i,jë¡œ ì˜¬ ë•Œì˜ weight
	- A given optimization problem can be constructed efficiently from optimal solutions of its subproblems.
		- ìµœì í™” ë¬¸ì œ
			- ë¦¬í„´ê°’ì„ ìµœëŒ€ë¡œ í•´ ì£¼ëŠ” solutionì„ ì°¾ì•„ë¼,
			- solutionì„ ê·¹ëŒ€í™”í•´ì£¼ëŠ”/ê·¹ì†Œí™”í•´ì£¼ëŠ” solutionì„ ì°¾ì•„ë¼
		- ìµœì í™”ê°€ ì•„ë‹ˆë‚˜ DPë¥¼ í™œìš©
			- ë‹¤ì €ìŠ¤ ë¬¸ì œ : ìµœì í™” ë¬¸ì œê°€ ì•„ë‹ˆì§€ë§Œ DPë¥¼ ì‚¬ìš©í•¨
		- ìµœì ì˜ solutionì„ ì–»ê¸° ìœ„í•´ ë¬¸ì œë¥¼ í’€ì–´ê°
		- â†’ optimal substructure

![13](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/13.png)

- Optimal substructure :Â $S_{n,m} =?$
	1. $i,j \geq 1$
		- $S_{i,j} = \max(S_{i-1,j}+W({(i-1,j)},{(i,j)}), S_{i,j-1}+W({(i,j-1)},{(i,j)}))$
	2. $i=0, j=1,2,...,n$
		- $S_{0,j} = S_{0,j-1}+W({(0,j-1)},{(0,j)})$
	3. $j=0, i=1,2,...,m$
		- $S_{i,0} = S_{i-1,0}+W({(i-1,0)},{(i,0)})$
	4. $i=j=0$
		- $S_{0,0} = 0$

> ğŸ’¡ Induction, Base stepì— ê´€í•œ ê²ƒë“¤ë„ ì •í™•í•˜ê²Œ ê¸°ìˆ í•´ì£¼ì–´ì•¼ í•¨.

- Table setup and fill
	- ë§¨ ìœ„, ë§¨ ì˜† lineì—ì„œëŠ” uniqueí•œ path costê°€ ë‚˜ì˜´
	- divide and conquer = top down â†’ í° ë¬¸ì œë¶€í„° ì‘ì€ ë¬¸ì œë¡œ (merge sort : í° ê²ƒì„ ë°˜ìœ¼ë¡œ ë°˜ìœ¼ë¡œ ìª¼ê°œê°€ë©° merge) â†”Â DP
	- ì •ë³´ì˜ íë¦„ : ë‚´ ê°’ì„ ê³„ì‚°í•˜ê¸° ìœ„í•´ì„œ j ì¸ë±ìŠ¤ê°€ ì‘ì€ ê²ƒ, i ì¸ë±ìŠ¤ê°€ ì‘ì€ ê²ƒì„ ê³„ì‚°í•´ë‘ë©´ ë¨
	- ê°ê°ì˜ Nodeê°€ subproblemì„ ë‚˜íƒ€ë‚¸ë‹¤.
	- ì–´ë–»ê²Œ ê°ê°ì˜ ì›ì†Œë¥¼ ì±„ìš¸ ê²ƒì¸ê°€: í•œ ì›ì†Œ ê°’ì„ ê³„ì‚°í•˜ê¸° ìœ„í•´ì„œëŠ” ë‚˜ë³´ë‹¤ ì™¼ìª½ì— ìˆëŠ” ì• ì™€ ìœ„ìª½ì— ì‡ëŠ” ì• ì˜ ê°’ì„ ì•Œê³  ìˆì–´ì•¼ í•¨.
	- 

		![14](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/14.png)

- Pseudocode
	- 

		![15](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/15.png)


		```c
		MANHATTANTOURIST(w,w,n,m)
		
		
		```

- Given aÂ (_n_,_m_)Â grid, what is the time complexity T(n, m)?
undefined- So far, we have found theÂ **cost of the longest path**Â from source to each vertex in the grid.
- ê¸¸ì´ê°€ 34ì¸ longest pathëŠ” ì–´ë–»ê²Œ ì¶œë ¥í•  ìˆ˜ ìˆì„ê¹Œ?
	- ì¡°ê¸ˆë§Œ ë” ë…¸ë ¥í•˜ë©´ longest path ê¸¸ì´ + ëŒ€ê°ì„  ê¹Œì§€ì˜ ê±°ë¦¬ë¥¼ ì¶œë ¥í•  ìˆ˜ ìˆëŠ” ì •ë³´ë¥¼ ì¶”ì¶œí•´ë‚¼ìˆ˜ ìˆìŒ
	- ì•Œê³ ë¦¬ì¦˜ì—ì„œ ì •ë³´ë¥¼ ë” ë„ì§‘ì–´ ë‚¼ ìˆ˜ ìˆëŠ” ë¶€ë¶„ :
		- $S_{i,j} = \max(S_{i-1,j}+W({(i-1,j)},{(i,j)}), S_{i,j-1}+W({(i,j-1)},{(i,j)}))$
			- ë‘˜ ì¤‘ì— í° ê²ƒì„ ì„ íƒí•˜ëŠ” statement
			- ì™¼ì© ê²ƒì´ ë” í¬ë‹¤ë©´ â†’ ìœ„ì—ì„œë¶€í„° ë‚´ë ¤ì˜¨ ê²ƒ
			- ì˜¤ë¥¸ìª½ ê²ƒì´ ë” í¬ë‹¤ë©´ â†’ ì™¼ìª½ì—ì„œ ë‚´ë ¤ì˜¨ ê²ƒ
		- optimal substructureì™€ ì—°ê´€
			- ë‚˜ì˜ optimal solutionì€ ë‚˜ë³´ë‹¤ ì‘ì€ subproblemë“¤ì˜ optimal solutionì„ í†µí•´ ì¶œë ¥
			- ê±°ê¸°ì„œë¡œë¶€í„° ìˆ˜ì‹ì´ ë‚˜íƒ€ë‚œë‹¤:ì´ë¥¼ programí™”í•˜ì—¬ ê° table ì›ì†Œë¥¼ ê³„ì‚°í•  ë•Œ ì„ íƒë¨ì— ë”°ë¼ì„œ ê° ë˜ ë‹¤ë¥¸ table í•˜ë‚˜ë¥¼ ê¸°ë¡í•´ë‘ë©´ +1, -1 ë“±ì„ ì¤„ì¤„ ì«“ì•„ê°€ë©´ ë¨
		- recursion : êµ‰ì¥íˆ compactí•˜ê²Œ í‘œí˜„í•´ì£¼ëŠ” ì¢‹ì€ ë°©ì‹
			- ë¬¼ë¡  overlapping subproblemì˜ ê²½ìš° ê°œë…ì„ compactí•˜ê²Œ í–í•´ì£¼ì§€ë§Œ ì¡°ì‹¬í•˜ë©´ì„œ ì¨ì•¼ì§€ ì•ˆ ë³µì¡í•´ì§
		- ìµœì¢… ê²ƒê¹Œì§€ ê°€ëŠ” ê¸¸ : (-1â†’ 1) + (ì´ì „ ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ê±°ë¦¬)
- Time complexity
	- Input size (m,n)
	- Time Complexity : O(mn)
		- ê° ë…¸ë“œë§ˆë‹¤ ê³„ì‚°í•˜ëŠ”ë° ê±¸ë¦¬ëŠ” ìƒìˆ˜ì‹œê°„
		- nodeì˜ ë³µì¡ë„ê°€ ì‹œê°„ ë³µì¡ë„
	- Space Complexity : O(mn)
		- 50.50ìœ¼ë¡œ divide and conquerí•˜ë©´, ê³¼ì—° ì‹¤í–‰ì˜ ëì„ ë³¼ ìˆ˜ ìˆì„ê°€ ëª¨ë¥´ê² ë‹¤!
- Then, how can you print out theÂ **actual optimal path**Â from source to sink?
undefined
		![16](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/16.png)


# 4.3.2. Chained Matrix Multiplication


[Neapolitan 3.4] dpì˜ ëŒ€í‘œì ì¸ ë¬¸ì œ

- In general, to multiply anÂ _a_Â xÂ _b_Â matrix with aÂ _b_Â xÂ _c_Â matrix using the standard method, it is necessary to doÂ _abc_Â elementary multiplications.
	- a*b, b*c í–‰ë ¬ì„ ê³±í•˜ë©´ a*c í–‰ë ¬ì´ ë‚˜ì˜¤ëŠ”ë° ê°€ì¥ ë‹¨ìˆœí•˜ê²Œ ì—°ì‚°í•˜ë©´ a*b*cë§Œí¼ì˜ ê³±ì…ˆì´ ìˆ˜í–‰
	- matrix multplication
		- $A_1 \times A_2 \times ... \times A_n$
			- 1ë²ˆ, 2ë²ˆ ê³±ì…ˆ, â€¦ n-1ë²ˆ ê³± : ëˆ„êµ¬ë¥¼ ì œì¼ ë§ˆì§€ë§‰ì— ì—°ì‚°í• ê²ƒì¸ê°€?
			- ìµœì†Œë¹„ìš©ìœ¼ë¡œ ê³±í•œ ë‹¤ìŒ ê³±í•˜ëŠ” ë° í™œìš©ëœ ë¹„ìš©ì„ ë”í•˜ë©´ ê²°ê³¼ ë¹„ìš©
				- 3ë²ˆ ì´ì „ + 3ë²ˆ ì´í›„
			- ì´ ì¤‘ì— ì œì¼ ì‘ì€ ê²ƒì„ ì„ íƒí•œë‹¤.
			- matrix multiplicationì—ëŠ” ê²°í•©ë²•ì¹™ ì„±ë¦½ : ì–´ë–¤ ê²ƒì„ ë¨¼ì € ê³±í•´ë„ ìƒê´€ ì—†ìœ¼ë‚˜ ë¹„ìš©ì´ ë‹¬ë¼ì§
		- $A_i = d_{i-1} \times d_i$

![17](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/17.png)

- Problem
	- Determine the minimum number of elementary multiplications, needed to multiplyÂ $n$Â matrices whereÂ $A_i \in R^{d_{i-1} \times d_i}$
	- optimal substructureë¥¼ í†µí•´ ìµœì ì˜ solutionì„ ë„ì¶œ
- Examples:Â  $A_1 (20 \times 2) \cdot A_2 (2 \times 30) \cdot A_3 (30 \times 12) \cdot A_4 (12 \times 8)$í•´
	- í–‰ë ¬ì˜ ê³±ì…ˆì—ì„œëŠ” ê²°í•©ë²•ì¹™ì´ ì„±ë¦½í•œë‹¤
		- $(a+b)+c = a+(b+c) $: a+b+c
		- binary operation (ì´ì§„ ì—°ì‚° : ë‘ í”¼ì—°ì‚°ìì— ëŒ€í•´ ì—°ì‚°í•˜ë©´ í•œ ì—°ã……ë‚˜)
		- ë¹¼ê¸°ëŠ” ê²°í•©ë²•ì¹™ ì„±ë¦½ x â†’ ì–´ë–¤ ë¹¼ê¸°ë¥¼ ë¨¼ì € í•˜ëŠëƒì— ë”°ë¼ ê²°ê³¼ ë‹¬ë¼ì§
		- í–‰ë ¬ì˜ ê³±ì…ˆì˜ êµí™˜ë²•ì¹™ ì„±ë¦½ X, ê²°í•©ë²•ì¹™ì€ ì„±ë¦½ O
	- ì œì¼ ë¨¼ì € ê³±í•˜ëŠ” ê²Œ ëª‡ ë²ˆì´ëƒê³  ìƒê°í•  ìˆ˜ ìˆê³ ,
	- ìµœì†Œ íšŸìˆ˜ë¥¼ êµ¬í•˜ëŠ” ê²ƒì´ë‹ˆ minimization problem : ìµœì†Œ íšŸìˆ˜ì˜ ê³±ì…ˆ â†’ ìµœì í™” ë¬¸ì œë¡œ ëŒ€ì…
	- ì–´ë–¤ ì¹œêµ¬ë¥¼ ì œì¼ ë¨¼ì € ê³±í•  ê²ƒì¸ê°€ ìƒê°í•  ìˆ˜ ìˆë‹¤.
	- ê³±ì…ˆì„ ê³±í•˜ëŠ” ìˆœì„œ : ê³±ì…ˆì„ ìˆœì„œëŒ€ë¡œ ë‚˜ì—´í•œ ê²ƒê³¼ ë™ì¼
		- ìµœì ì˜ í•´ : ê³±ì…ˆì˜ ê°œìˆ˜ê°€ ì‘ì€ ê²ƒìœ¼ë¡œ ì„ íƒí•  ê²ƒì´ë‹¤.
	- $A_1: 20 \times 2, A_2: 2 \times 30$
	- $A_1(A_2(A_3 A_4)) : 30 \times 12 \times 8 + 2 \times 30 \times 8 + 20 \times 2 \times 8 = 3,680$ multiplications
		- 3, 2, 1
	- $(A_1 A_2)(A_3 A_4) : = 8,880$Â multiplications
	- $A_1((A_2 A_3 )A_4) : = 1,232$Â <u>multiplications</u>
		- 2, 3, 1
	- $((A_1 A_2)A_3 )A_4 := 10,320$Â multiplications
	- $(A_1(A_2 A_3 ))A_4 := 3,120$Â multiplications
	- The order of multiplication is very important!
		- $(a \times b) \times c = a \times (b \times c)$
	- $O((n-1)!)=O(n!)$ : í”„ë¡œê·¸ë¨ ì—´ì‹¬íˆ ì„¤ê³„í•˜ëŠ” ë°ì—ëŠ” ì–¼ë§ˆ ì•ˆ ê±¸ë¦´ì§€ ëª¨ë¥´ì§€ë§Œ n factorialë§Œí¼ ê¸°ë‹¤ë ¤ì•¼ ê²°ê³¼ê°€ ë‚˜ì˜¨ë‹¤
		- ê³±ì…ˆì„ í•  ìˆ˜ ìˆëŠ”ê²Œ $(n-1)!$ì˜ ê²½ìš°ì˜ ìˆ˜ì¸ë° ì´ë“¤ì„ ì–´ë–»ê²Œ ë¶„ë¥˜í•´ì„œ exponentialë³´ë‹¤ ë¬´ì‹œë¬´ì‹œí•œ factorialì„ polynomial timeìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ì–´ë–»ê²Œ ì˜ ë¶„ë¦¬í•´ íŒë‹¨í• ê²ƒì¸ê°€?
		- ë¶„ë¥˜ ë°©ë²• : Ex. $A_1 \cdot A_2 \cdot A_3 \cdot A_4 \cdot A_5 \cdot A_6 \cdot A_7$
			- (1) ì–´ë–¤ ì• ë¥¼ ê°€ì¥ ë¨¼ì € ë‚˜ëˆŒ ê²ƒì¸ê°€
				- 
			- (2) ì–´ë–¤ ì• ë¥¼ ê°€ì¥ ë‚˜ì¤‘ì— ë‚˜ëˆ„ì–´ ê³±í•  ê²ƒì¸ê°€
				- ìµœì†Œ ê³±ì…ˆì„ í•˜ê³ ì í•˜ëŠ”ë°, ë§Œì¼ ì œì¼ ë§ˆì§€ë§‰ì— ê³±í•˜ëŠ” ê²ƒì´ë¼ë©´ ì•ì˜ ê²ƒì„ ë‹¤ ê³±í•˜ê³  ë’¤ì˜ ê²ƒì„ ë‚˜ì¤‘ì— ê³±í•´ì•¼ í•˜ëŠ”ë° ìš°ë¦¬ì˜ ëª©ì ì´ ìµœì†Œ ê³±ì…‰ì„ ì›í•˜ëŠ” ê²ƒì´ë¯€ë¡œ ê°ê°ì˜ partitionì— ëŒ€í•´ì„œ ìµœì†Œ íšŸìˆ˜ë¡œ ê³±í•˜ê²Œ ë¨
					- â†’ ìì—°ìŠ¤ë¡œìš´ recursive ì‚¬ê³ ë°©ì‹
				- $(A_1 \cdot A_2 \cdot A_3) \cdot (A_4 \cdot A_5 \cdot A_6 \cdot A_7) = A_{13} \cdot A_{37}$

	![18](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/18.png)

- Divide and Conquer, Dynamic Programmping
	- problem â†’ <u>**recursive structure**</u> â†’ optimal substructure â†’ dynamic programming
	- ~ë¥¼ ìµœëŒ€ë¡œ í•´ ì£¼ëŠ” ìµœì í™” ë¬¸ì œì— ë§ì´ ì“°ì´ëŠ” DP
	- ìµœì ì˜ êµ¬ì¡° ì´ëŸ° ê²ƒë“¤ì´ ìˆì„ ê²½ìš°, ê²½ìš°ì— ë”°ë¼ì„œëŠ” divide and conquerê°€ ìœ ë¦¬í•  ìˆ˜ ìˆë‹¤
	- exponential algì´ ë‚˜ì˜¤ê¸° ë•Œë¬¸ì— dpë¥¼ í•œ ë²ˆ ì¨ë³´ì.
- Divide and Conquer â†’ Top-down
- Dynamic Programming â†’ Bottom-up
- Recursive : ë‚˜ë‘ ê°™ì´ ìƒê²¼ëŠ”ë°, ë‚˜ë³´ë‹¤ ì‚¬ì´ì¦‰ ì‘ì€ ë¬¸ì œë¥¼ í•´ê²°í•œë‹¤.
	- ì‘ì€ ë¬¸ì œë¶€í„° í’€ ê²ƒì¸ê°€ (Bottom Up), í° ë¬¸ì œë¶€í„° ë‚´ë ¤ì˜¬ ê²ƒì¸ê°€ (Top Down)
- directed graphë¼ê³  ë´¤ì„ ë•Œ, ìµœì†Œ íšŸìˆ˜ë¡œ ê±´ë„ˆê°€ëŠ” ë¬¸ì œ
	- nì—ì„œ 1ê¹Œì§€ì˜ shortest path ì°¾ëŠ” ë¬¸ì œ
	- ë¶„ëª… shortest pathëŠ” ì¡´ì¬í•˜ëŠ”ë°, 6â†’ 5,3,2
	- $P_n = \min\{ P_{n-1}, P_{\frac n 2}, P_{\frac n 3}\}+1$
		- if $n\%2 ==0$ â†’ $P_{\frac n 2}$
		- if $n\%3 ==0$ â†’ $P_{\frac n 3}$
	- ë‚˜ë³´ë‹¤ ì‚¬ì´ì¦ˆ ì‘ì€ ê²ƒë“¤ì˜ ìµœì ì˜ solutionì„ ì°¾ëŠë‹¤ : optimal substructure
	- ë¬¸ì œ ì‚¬ì´ì ì¦‰ì€ ê±°ë¶€í„° ê°’ì„ ê³„ì‚°í•´ë³¸ë‹¤. ì´ëŸ¬í•œ P_nì˜ ì‹ì„ í†µí•´ì„œ ê³„ì‚°
		- nì„ kë¡œ ëŒ€ì¹˜í•˜ì—¬ ìƒê°

	![19](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/19.png)


# 4.3.3. Dynamic programming approach

- Definition
	- $M(i, j)$
		- the minimum number of multiplications needed to multiplyÂ $A_i$Â throughÂ $A_j (i \leq j )$
		- ë‘ ê°™ì´ í–‰ë ¬ ië¶€í„° jê¹Œì§€ ìµœì†Œ íšŸìˆ˜ë¥¼ ê³±í•  ë•Œ, ê·¸ ë•Œ í•„ìš”í•œ ê³±ì…ˆì˜ í™‹ìˆ˜ë¥¼ M(i,j)ë¡œ ì •ì˜
- Optimal subtructure
	- ì§€ê¸ˆê¹Œì§€ ë³¸ ê²ƒì´ë‘ ì¡°ê¸ˆ ë‹¤ë¥¸ í˜•íƒœì˜ substructureê°€ ë‚˜ì˜¤ë”ë¼
	- ìµœì í™” ë¬¸ì œì˜ ê²½ìš° dp ëŠë‚‘ì¸ë° ê·¸ë ‡ì§€ ì•Šì„ìˆ˜ë„ ìˆë”ë¼ : ê²½ìš°ì˜ ìˆ˜ë¥¼ ë”°ì§€ê³  recursiveí•œ ê°œë…ì´ ë“¤ì–´ê°€ëŠ” ê²½ìš°
		- i, jê°€ ê°™ìœ¼ë©´ ê³±ì…ˆì´ í•„ìš” ì—†ë‹¤.
		- i<jì´ë©´
			- iì—ì„œ kê¹Œì§€ ìµœì†ŒíšŸìˆ˜ â†’ $M(i,k) = d_{i-1} \cdot d_k $
			- kì—ì„œ jê¹Œì§€ ìµœì†ŒíšŸìˆ˜ â†’ $M(k+1, j) = d_k \cdot d_j$
	- â†’ $M(1,n) = ?$

![20](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/20.png)

- Example:Â $M(2, 7)$
	- $M(2,7) = \min_{2\leq k \leq 6}{\{ M(2,k) + M(k+1,7)+d_1 d_k d_7}\}$

		![21](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/21.png)

	- dp : ì‘ì€ ë¬¸ì œë¶€í„° í’€ì–´ê°
	- tableì„ ë§Œë“¤ì–´ì„œ ë™ì¼í•œ subproblemì„ ë”± í•œ ë²ˆë§Œ í‘¸ëŠ” ê²ƒ: tableì„ ì–´ë–»ê²Œ ë§Œë“¤ ê²ƒì¸ê°€?
	- ìš°ë¦¬ê°€ í•„ìš”í•œ ê²ƒ : ì„¸ë¡œ i, ê°€ë¡œ j â†’ í•„ìš”í•œ subproblemì„ ë‹¤ ëª¨ì•„ë‘ë©´, M(i,j)ì´ë‹¤. $M(i,j) i\leq j$
		- ëŒ€ê°ì„  ìš°í•˜í–¥ìœ¼ë¡œ ë‚´ë ¤ê°ˆìˆ˜ë¡ ì‘ì€ ë¬¸ì œì´ë‹¤
		- tableì„ ì–´ë–»ê²Œ í›‘ìœ¼ë©° ì‘ì€ ë¬¸ì œì—ì„œ í° ë¬¸ì œë¡œ ë³€í™˜í•  ê²ƒì¸ê°€?
		- optimal substructureì˜ êµ¬ì¡°ê°€ ì–´ë–»ê²Œ tableì„ ì«“ì•„ê°ˆ ê²ƒì¸ê°€ ê³ ë¯¼í•´ë³´ëŠ” ë¬¸ì œ
- M(2,7)
	- ê°€ë¡œë¡œ ì‹œì‘í•˜ë©´ ì•ˆ ë¨ : ê°€ë¡œì˜ M(2,2,) M(2,3) .. ì€ ë‹¤ ë˜ì§€ë§Œ ì„¸ë¡œì˜ ê²ƒë“¤ì€ í•œë²ˆì— ëª» ì±„ìš°ê¸° ë•Œë¬¸
	- ì„¸ë¡œë¡œ ì‹œì‘í•˜ë©´ ë ê¹Œ? : ì„¸ë¡œë¡œ ìˆœì„œëŒ€ë¡œ ì´ ì‹ì„ í™œìš©í•´ ê³„ì‹¼í•  ê²ƒì¸ë° ì™¼ìª½ì˜ ê²ƒë“¤ê³¼ ë°‘ì˜ ìª½ì˜ ê²ƒë“¤ì´ ê³„ì‚°ë  ê²ƒ ê°™ë‹¤.
- Table fill order

	![22](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/22.png)


	```c
	for (i = 1; i <= n; i++)
			M[i][i] = 0;
	for (g = 1; g <= n - 1; g++){
			for (i = 1; i <= n - g; i++) {
							j = i + g;
							M[i][j] = BIG_NUM;
							for (k = i; k <= j - 1; k++){
	        		        if ((tmp = M[i][k] + M[k + 1][j] +
	                           d[i - 1] * d[k] * d[j]) < M[i][j]) {
	            				        M[i][j] = tmp;
	                    				P[i][j] = k;
			                }
	            }
	        }
	    }
	```

- Time complexity
	- $n + (n-1) \cdot 1 + (n-2) \cdot 2 + ... + (n-(n-1))\cdot (n-1)n+(nâˆ’1)â‹…1+(nâˆ’2)â‹…2+...+(nâˆ’(nâˆ’1))â‹…(nâˆ’1)\\= n + \Sigma_{g=1}^{n-1}{(n-g)g} \\= O(n^3)$
undefined- Chained matrix multiplication problem
	- $O(n^3)$Â by Godbole (1973)
	- $O(n^2)$Â by Yao (1972)
	- $O(n \log n)$Â by Hu and Shing (1982, 1984)
- Printing optimal order
	- $M(2,7) = \min_{2\leq k \leq 6}{\{ M(2,k) + M(k+1,7)+d_1 d_k d_7}\}$

	```c
	void order(int i, int j)
	{
	    int k;
	    if (i == j)
	        printf(â€œA_ % dâ€, i);
	    else
	    {
	        k = P[i][j];
	        printf("(");
	        order(i, k);
	        order(k + 1, j);
	        printf(")");
	    }
	}
	```


	![23](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/23.png)


â†’Â $O(n)$Â time


![24](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/24.png)


# [ALG] 4.4. Principles of Dynamic Programming (1)


# 4.4. Principles of Dynamic Programming

- $C_{ij}$Â = the cost of the shortest path fromÂ (0,0)Â toÂ (_i_,_j_)
	- ê° directed edgeì—ì„œ shortest pathë¥¼ ì°¾ì•„ë¼
	- ThenÂ $C_{ij} = min \{C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} \}$rkr

		![25](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/25.png)

- Recursive formulation
- Optimal substructure
	- ë‚˜ì˜ ìµœì ì˜ í•´ë¥¼ êµ¬í•˜ê¸° ìœ„í•´ì„œ ë‚˜ë³´ë‹¤ í¬ê¸°ê°€ ì‘ì€ subproblemë“¤ì˜ optimal solutionì„ í†µí•´ì„œ ìµœì ì˜ í•´ë¥¼ êµ¬í•˜ëŠ” ê³¼ì •ì„ ê°€ëŠ¥ì¼€í•´ì£¼ëŠ” êµ¬ì¡°
- Overlapping subproblems
	- êµ‰ì¥íˆ ì•ˆ ì¢‹ì€ í˜•íƒœë¡œ í’€ì´ë ìˆ˜ ìˆìŒ(ë¬´í•œ loop)
	- subproblemì˜ ê°œìˆ˜ëŠ” ê° nodeë§Œí¼ ìˆìœ¼ë‹ˆê°€
- Bottom-up approach
	- ì‘ì€ ë¬¸ì œë¶€í„° í’€ì
- Table Fill-up
	- ê° nodeì— ëŒ€í•œ ìµœë‹¨ ê±°ë¦¬ë¥¼ tableì— ê³„ì‚°í•´ë‘ê³  ê¸°ë¡ë˜ì–´ ìˆëŠ” ê²ƒë“¤ì— ëŒ€í•´ ì±„ì›Œê°€ë©° ìˆ˜í–‰í•˜ì

## 4.4.1. Optimal SubstructureÂ [(wiki)](https://en.wikipedia.org/wiki/Optimal_substructure)


ì­‰ ì½ê³  ì•„ëŠ”ì²™ í•´ë´ì !! (dynamic programming)

- ë¬¸ì œì— ëŒ€í•´ì„œ DPë¥¼ ì ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” optimal substructureë¥¼ ì°¾ì•„ë‚´ì•¼ í•œë‹¤
	- ë‚˜ì˜ optimal solutionì„ ì°¾ëŠ” êµ¬ì¡° : recursionì´ ë“¤ì–´ê°€ ìˆìŒ
	- recursionì„ divide and conquerë¡œ top-downìœ¼ë¡œ í•˜ë˜ê°€, bottom-upìœ¼ë¡œ ì˜¬ë¼ê°€ë˜ê°€
- Dynamic programming algorithms are oftenÂ **used for optimization**.
	- ~ë¥¼ ìµœëŒ€ë¡œ í•´ ì£¼ëŠ” optimal problemì„ í‘¸ëŠ” ë°ì— ì£¼ë¡œ ì“°ì¸ë‹¤
- A problem is said to haveÂ **optimal substructure**
	- if a solution to a given optimization problem can be constructed efficiently from optimal solutions of its subproblems.
- Consequently, the first step towards devising a dynamic programming solution is to check whether the problem exhibits such optimal substructure.
	- Such optimal substructures areÂ **usually described by means of recursion**.
	- $C_{ij} = min \{C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} \}$

## 4.4.2. Overlapping SubproblemsÂ [(wiki)](https://en.wikipedia.org/wiki/Overlapping_subproblems)


> ğŸ’¡ í° ë¬¸ì œë¥¼ í‘¸ëŠ”ë°, recursiveí•˜ê²Œ ì‘ì€ ë¬¸ì œë¥¼ ê³„ì†í•´ì„œ top downì‹ìœ¼ë¡œ í’€ ë•Œ ê°™ì€ ì‹ìœ¼ë¡œ ë°˜ë³µì ìœ¼ë¡œ ë‚˜ì˜¤ëŠ” ê²½ìš° : overlapping problem ë¬¸ì œê°€ ì‹¬ê°í•  ë•Œ

- To solve a problem, we often need toÂ **solve different parts of the problem (subproblems), then combine the solutions of the subproblems to reach an overall solution**.
- A problem is said to haveÂ <u>**overlapping subproblems**</u>Â if
	- the problem can be broken down into subproblems which are reused several times or
	- a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblems.
	- í•œ ë²ˆë§Œ í’€ê³  ì´ë¥¼ tableì— ì§‘ì–´ë„£ì–´ ì ì°¨ sizeë¥¼ í‚¤ì›Œ ë¬¸ì œ ì›ë˜ ê²ƒì„ í‘¸ëŠ” ë°©ì‹
	- $C_{ij} = min \{C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} \}$
- The dynamic programming approach seeks toÂ **solve each subproblem only once**, thus reducing the number of computations:
	- (i) once the solution to a given subproblem has been computed, it is stored or "**memoized**":
	- (ii) the next time the same solution is needed, it is simplyÂ **looked up**.
- This approach isÂ **especially useful when the number of repeating subproblems grows exponentially**Â as a function of the size of the input.
- **If a problem can be solved by combining optimal solutions to non-overlapping sub-problems**, the strategy is called "divide-and- conquer" instead. This is why merge sort and quick sort are not classified as dynamic programming problems.
	- overlapping subproblemì´ ê±°ì˜ ë°œìƒí•˜ì§€ ì•ŠìŒ : merge sort, selection
		- merge sort : í° ë¬¸ì œë¥¼ ë°˜ìœ¼ë¡œ ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ê³  í•´ë‹¹ subproblemë“¤ì´ overlapë˜ì§€ ì•ŠìŒ
		- selection : í° ë¶€ë¶„ë“¤ì— ëŒ€í•´ì„œ ë¶€ë¶„ì„ ì„ íƒí•˜ê³  í•œ ë¶€ë¶„ì€ ë‹¤ë¥¸ ê²ƒê³¼ ê²¹ì¹˜ì§€ ì•ŠìŒ
		- quick sort : pivotì„ ì œì™¸í•œ ë‚˜ë¨¸ì§€ ë¶€ë¶„ë“¤ì€ overlapí•˜ì§€ ì•ŠìŒ
			- êµ³ì´ DPë¡œë„ ê°ˆ í•„ìš” ì—†ì´ divide and conquerë¡œ ì‰¬ì´ í’€ë¦¬ê²Œ ë¨
			- ì´ë¶„ë²•ì  ì‚¬ê³  ì§€ì–‘ :
				- <u>ìœ„ì—ì„œ ì•„ë˜ë¡œ ë‚´ë ¤ê°€ëŠ”ë° subproblemì´ ë°˜ë³µì ìœ¼ë¡œ ë‚˜íƒ€ë‚˜ëŠ” ê²½ìš° exponentially í•œ ì‹œê°„ ë³µì¡ë„ê°€ ê±¸ë¦´ ìˆ˜ ìˆê¸°ì— ì´ëŸ´ ë•ŒëŠ” dpë¥¼ ì¨ë¼</u>
- $C_{ij} = min \{C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} \}$

## 4.4.3. The Checkerboard Problem


[Courtesy of Wikipedia]

- ì²´ìŠ¤íŒ
- Restrictions
	- A checker can start at any square on the first row (i= 1).
	- It can move only diagonally left forward, diagonally right forward, or straight forward.
		- ë‚´ë ¤ê°€ëŠ” ë°©ë²• ì œí•œ : ë‚¨ì„œìª½ìœ¼ë¡œë§Œ ë‚´ë ¤ê°€ë˜ê°€, ë‚¨ìª½ìœ¼ë¡œ ë‚´ë ¤ê°€ë˜ê°€, ë‚¨ë™ìª½ìœ¼ë¡œ ë‚´ë ¤ê°€ë˜ê°€
	- It must pay the costÂ _c_[i] when visiting the (i, j)-position.
- Cost table $c [i] [j]$

	![26](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/26.png)

- Problem
	- Given a checkerboard withÂ $n \times n$Â squares, and a cost functionÂ `c[i][j]`,Â **find the minimum-cost path from the first row to the last row**.
	- ë‚´ê°€ ì–´ë–¤ ì§€ì ì„ ë°©ë¬¸í–ˆì„ ë•Œì—ëŠ” í™”ì‚´í‘œê°€ ì§€ë‚˜ê°„ costë¥¼ summationí•œ ê²ƒ
		- ê°€ì¥ ê¸¸ì´ê°€ ì§§ì€ ì ì€ ë¹„ìš©ì˜ path ì°¾ëŠ”ê²ƒì´ ëª©í‘œ
	- recursive êµ¬ì¡°, optimal substructureì„ ì°¾ì•„ë³´ì
		- ê°€ì¥ ì‘ê²Œ í•´ì£¼ëŠ” minimization problem
- Ex. 1 ê¹Œì§€ì˜ ìµœì†Œë¹„ìš© [4][4]
	- ìµœì†Œ ë¹„ìš©ì˜ pathëŠ” ì…‹ ì¤‘ í•˜ë‚˜ : ë‚¨ìª½ìœ¼ë¡œ ì˜¤ê±°ë‚˜, ë‚¨ì„œìª½ì—ì„œ ì˜¤ê±°ë‚˜, ë‚¨ë™ìª½ì—ì„œ ì˜¤ê±°ë‚˜
	- ë‚´ê°€ ìµœì†Œ ë¹„ìš©ì„ ì°¾ê³ ì í•˜ëŠ” ê²ƒì´ë‹ˆ ê°ê°ì— ì´ë¥´ê¸°ê¹Œì§€ì˜ ìµœì†Œ ë¹„ìš© pathì˜ ì´ ë¹„ìš©ì˜ ê³„ì‚°
		- ê°ê° ìƒí™©ì— ëŒ€í•œ ì´ ë¹„ìš©ì„ ì•ˆë‹¤ë©´, ã…ptimal substructureë¡œ ì–´ë–»ê²Œ ë‚˜íƒ€ë‚¼ê¹Œ?
		- minimum cost pathì— ëŒ€í•œ ì´ ë¹„ìš©ì€ ì˜¬ ìˆ˜ ìˆëŠ”ê±´ ì„¸ ê°€ì§€ ê²½ë¡œì¸ë° ê°€ì¥ ì‘ì€ ê²ƒì—ë‹¤ê°€ ì´ë¥¼ ì„ íƒí•´ì„œ
		- ë‚˜ë¥¼ ë°©ë¬¸í•  ë•Œ 1ì„ ë”í•˜ë©´ ë˜ë”ë¼
	- 
- Optimal substructure
	- $q(i,j) = \min \{ q(i-1, j-1), q(i-1,j), q(i-1, j+1)\} + c(i,j)$
		- $c(i,j)$ :
		- table sizeëŠ” ì–´ë–»ê²Œ í•  ê²ƒì¸ê°€ : ê° subproblemë§ˆë‹¤ ì›ì†Œì— ëŒ€ì‘ë˜ê²Œ tableì„ ì¡ìœ¼ë©´ ë¨
		- ì´ ë¹„ìš©ì— í•´ë‹¹í•˜ëŠ” q(i,j) : (i,j) ê¹Œì§€ ìœ„ì¹˜ ê¹Œì§€ì˜ ì´ ë¹„ìš© ê³„ì‚°
			- min (ë‚¨ìª½ìœ¼ë¡œ ë‚´ë ¤ì˜¤ëŠ”, ë‚¨ë™ìª½, ë‚¨ì„œìª½)
	- $q(i,j) = c(i,j)$
		- i=1ì¼ ë•Œ : ìê¸° ìì‹  - ë§¨ ìœ—ì¤„
			- ê·¸ ì§€ì ê¹Œì§€ ì˜¤ëŠ” ìµœì†Œ ë¹„ìš©ì€ ìê¸° ìì‹  costë§Œ ì§€ë¶ˆí•˜ë©´ ë¨
	- dummy
		- ìˆ˜í•™ì ìœ¼ë¡œ ë¬´í•œëŒ€ ê°’ì„ ì„¤ì •í•´ ë‘ 
		- ì´ëŸ°ì‹ìœ¼ë¡œ ì„¤ì •í•˜ê³  programmingí•˜ë©´ ê° ëì— ê°’ë“¤ì— ì„ íƒë˜ì§€ ì•ŠìŒ
		- ì‚¬ì‹¤ ìˆ˜í•™ì ìœ¼ë¡œ ì“¸ ë•Œ í•„ìš”ëŠ” ì—†ì§€ë§Œ, dummyê°’ì„ ë„£ì–´ì£¼ëŠ” ê²Œ í¸ë¦¬
			- boundary ì²´í¬í•´ë„ ìƒê´€ì€ ì—†ì§€ë§Œ ê° ì™¼ìª½, ì˜¤ë¥¸ìª½ ëì—ì„œ boundaryë¡œë¶€í„° ì˜¤ëŠ” ê°’ë“¤ì„ ê³„ì‚°í•˜ê¸° ê³¤ë€í•¨
		- ê° cost table ìœ„ì¹˜ë§ˆë‹¤ subproblemì´ í•˜ë‚˜ ìƒì„±ë¨
	- table setup & table fill
		- ì–´ë–¤ì‹ìœ¼ë¡œ loopì„ ëŒë©´ì„œ í• ê¹Œ
	- (if) ìˆ˜ì§ìœ¼ë¡œ for loopë¥¼ ëŒê² ë‹¤ê³  í•˜ë©´
		- ë‚¨ë™, ë‚¨ì„œë¡œ ë‚´ë ¤ì˜¤ëŠ” ê²ƒë“¤ì— ëŒ€í•´ì„œëŠ” ê³ ë ¤í•˜ì§€ ëª»í•˜ë¯€ë¡œ ì•ˆë¨
	- (if) ìˆ˜í‰ìœ¼ë¡œ for loopë¥¼ ëŒê² ë‹¤ê³  í•˜ë©´
		- íŠ¹ì • ì›ì†Œë¥¼ ê³„ì‚°í•˜ê³ ì í•  ë•Œ, ë‚˜ì—ê²Œ í•„ìš”í•œ ì •ë³´ê°€ ë¯¸ë¦¬ ì¤€ë¹„ë˜ì–´ ìˆìŒ
		- q tableì´ ê³„ì‚°ë˜ë”ë¼
	- q tableì´ ê³„ì‚°ëœ í›„ í• ì¼ : ì•„ë¬´ë°ì„œë‚˜ ì‹œì‘í•´ë„ ìƒê´€ì—†ìœ¼ë‹ˆ ìœ„ì—ì„œ ë‚´ë ¤ì™€ì„œ ìµœì†Œë¹„ìš©ìœ¼ë¡œ ê°€ê²Œí•˜ì
		- ì•„ë¬´ë°ì„œë‚˜ ì‹œì‘í•´ì„œ ê°€ëŠ” minimum cost path
		- â†’ 8
	- q tableì„ ê³„ì‹¼í•¨ê³¼ ë™ì‹œì— p table ê³„ì‚°
		- ì–´ëŠ ë°©í–¥ì—ì„œ ì™”ëŠ”ì§€
			- ê°€ì¥ ì‘ì€ ê²ƒì„ ì„ íƒí•˜ëŠ” ê²½ìš°
		- -1 : ë¶ì„œì—ì„œ ë‚´ë ¤ì˜¨ê±°ë‹¤ / 0 : ë¶ì—ì„œ ë‚´ë ¤ì˜¨ê±°ë‹¤ / 1 : ë¶ë™ì—ì„œ ë‚´ë ¤ì˜¨ê±°ë‹¤
	- optimal substructureë¥¼ ì°¾ì€ ë‹¤ìŒ tableì„ setupí•˜ê³  base step ì •ë³´ë¥¼ ê°€ì§€ê³  initializeí•˜ê³  tableì„ ì ë‹¹í•œ ìˆœì„œë¡œ ì •ë¦¬í•œ ë‹¤ìŒ ì ì •í•œ ìµœë‹¨ optimal pathë¥¼ ì°¾ëŠ”ë‹¤.
	- ì´í›„ table fillì„ í•  ë•Œ tableì„ í•˜ë‚˜ ì¡ì•„ì„œ ì–´ë–¤ nodeë¥¼ ì„ íƒí•´ì„œ ë‚´ë ¤ì™”ìŒì„ í‘œê¸°í•¨ (p table)
	- â†’ shortest pathë¥¼ ì•Œê²Œ ëœë‹¤.

	![27](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/27.png)

	- ë‚˜ë³´ë‹¤ ì‚¬ì´ì¦ˆê°€ ì‘ì€ ìµœì ì˜ ì†”ë£¨ì…˜ë“¤ë¡œ í‘œí˜„í•˜ëŠ” ê²ƒ
	- code
		- c/c++ëŠ” recursionì´ ì¢‹ì€ toolì´ì§€ë§Œ ë³´í¸ì ìœ¼ë¡œ êµ‰ì¥íˆ ê°œë…ì„ compactí•˜ê²Œ ì˜ í‘œí˜„í•´ì¤€ë‹¤.

	```c
	#include <stdio.h>
	#define N 5
	#define INFTY 100000
	int c[N + 1][N + 2] = {-1, -1, -1, -1, -1, -1, -1, -1, 7, 3, 5, 6, 1, -1, -1, 2, 6, 7, 0, 2, -1, -1, 3, 5, 7, 8, 2, -1, -1, 7, 6, 1, 1, 4, -1, -1, 6, 7, 4, 7, 8, -1};
	int p[N + 1][N + 2], q[N + 1][N + 2];
	
	int min3(int a, int b, int c)
	{
	    ...
	}
	
	void ComputeCBCosts(int n)
	{
	    int i, j, min;
	    for (i = 1; i <= n; i++)
	        q[1][i] = c[1][i];
	    for (i = 1; i <= n; i++)
	    {
	        q[i][0] = INFTY;
	        q[i][n + 1] = INFTY;
	    }
	    for (i = 2; i <= n; i++)
	    {
	        for (j = 1; j <= n; j++)
	        {
	            min = min3(q[i - 1][j - 1], q[i - 1][j],
	       for (i = 2; i <= n; i++)
	    {
	        for (j = 1; j <= n; j++)
	        {
	            min = min3(q[i - 1][j - 1], q[i - 1][j],
	                    q[i - 1][j + 1]);
	            q[i][j] = min + c[i][j];
	            if (min == q[i - 1][j - 1])
	                p[i][j] = -1;
	            else if (min == q[i - 1][j])
	                p[i][j] = 0;
	            else
	                p[i][j] = 1;
	        }
	    }
	}
	
	void PrintShortestPath(int n, int imin)
	{
	    printf(" (%d, %d) <-", n, imin);
	    if (n == 2)
	        printf(" (%d, %d)\n", 1, imin + p[n][imin]);
	    else
	        PrintShortestPath(n - 1, imin + p[n][imin]);
	}
	
	void ComputeCBShortestPath(int n)
	{
	    int i, imin, min;
	    ComputeCBCosts(n);
	    imin = 1;
	    min = q[n][1];
	    for (i = 2; i <= n; i++)
	    {
	        if (q[n][i] < min)
	        {
	            imin = i;
	            min = q[n][i];
	        }
	    }
	    printf("*** The cost of the shortest path is %d.\n", q[n][imin]);
	    PrintShortestPath(n, imin);
	}
	
	void main(void)
	{
	    int n;
	    n = N;
	    ComputeCBShortestPath(n);
	}
	```


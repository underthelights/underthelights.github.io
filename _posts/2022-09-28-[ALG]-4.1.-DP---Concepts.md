---
layout: post
date: 2022-09-28
title: "[ALG] 4.1. DP - Concepts"
tags: [Algorithm, ]
categories: [Notes, ]
use_math: true
---

- divide and conquer: top - down
	- íš¨ìœ¨ì ì´ê¸°ë„ í•˜ë‚˜ ë§¤ìš° ë¹„íš¨ìœ¨ì ì´ ë˜ê¸°ë„ í•¨
	- splittedëœ ì‚¬ë¡€ë“¤ì´ ì„œë¡œ ê´€ë ¨ ì—†ëŠ” ë¬¸ì œë¥¼ í’€ë•Œ ì˜ í†µí•¨
- dynamic programming : bottom -up
	- ì•„ë˜ì—ì„œ ìœ„ë¡œ ì˜¬ë¼ê°€ë©° íš¨ìœ¨ì„ ì¶”êµ¬í•˜ìëŠ” ë°©ì‹
- NOW
	- Divide-and-Conquer Method
	- **Dynamic Programming Method**
	- Greedy Method
	- Backtracking Method
	- Local Search Method
	- Branch-and-Bound Method
	- Etc.
- FromÂ [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_programming): Dynamic programming is both a
	- <u>mathematical optimization method and a computer programming method.</u>
- A complicated problem isÂ **broken down into simpler sub-problems in a recursive manner**.
- Overlapping subproblems
	- A problem is broken down into subproblems which are reused several times or a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblems.
- Optimal substructure
	- A solution to a given optimization problem can be constructed efficiently from optimal solutions of its subproblems.
- When applicable, the methodÂ <u>**takes far less time than other methods**</u>Â that don't take advantage of the subproblem overlapÂ **like the divide- and-conquer technique**.

â†’ ë¬¸ì œ ëª‡ê°œ í’€ì–´ë³´ê³ , ì´ ê³ ìƒí•œ ë§ë“¤ì´ ë³„ ê²ƒ ì•„ë‹Œ ìì—°ìŠ¤ëŸ¬ìš´ ì›ë¦¬ì„ì„ ì²´ë“í•˜ì!


Two Approaches for Recursive Formulation

- Top Down Approach
- Bototm up Approach

## 4.2.1. Top Down Approach

- $T(i,j) = T(i-1,j) + T(i, j-1) + C \cdot (2i + j), i,j \geq 1$
- $T(i,0) = T(0,j) = 1$Â forÂ $i,jâ‰¥0$
- recursiveí•˜ê²Œ ë˜‘ê°™ì´ ë¬¸ì œ ë‘ê°œë¥¼ í‘¼ë‹¤ : ë¹¨ê°„ ê²ƒ í•˜ë‚˜, ë…¹ìƒ‰ í•˜ë‚˜. ê·¸ë¦¬ê³  ê·¸ ê²°ê³¼ë¥¼ combineí•˜ì—¬ ì›ë˜ ë¬¸ì œë¥¼ í‘¼ë‹¤. ë¬¸ì œê°€ ê²¹ì¹˜ëŠ”ê²Œ ë³´ì¸ë‹¤.
undefined- Easily becomes exponential!
undefined
recursive function call : ë‚´ë ¤ê°”ë‹¤ ì˜¬ë¼ê°”ë‹¤ depth first searchí•˜ë‹¤ê°€ í•˜ì—¼ì—†ì´ ëŒì•„ì˜¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤.


## 4.2.2. Bottom Up Approach

- $T(i,j) = T(i-1,j) + T(i, j-1) + C \cdot (2i + j),Â i,jâ‰¥1$
- $T(i,0) = T(0,j) = 1$Â forÂ $i,j \geq 0$
- Often much more efficient!
undefined- ê·¸ëŸ¬ë‚˜ bottom upì€ Top Downê³¼ ëŒ€ë¹„í•˜ì—¬ ì­‰ ì­‰ ì­‰ í•œ ì¤„ë¡œ ë‚´ë ¤ê°€ë©° ì˜ í’€ë¦¬ê²Œ ëœë‹¤.
undefined- Bottom up vs. Top down ê³µí†µ: ë‘˜ë‹¤ ì–´ë–¤ ë¬¸ì œê°€ ì¬ê·€ì ì¸, recursiveí•œ í˜•íƒœë¡œ ë¬¸ì œê°€ í’€ë¦¬ê²Œ ëœë‹¤.
undefined- ëª‡ ê°œ ì•ˆ ë˜ëŠ” ê²ƒì„ í’€ë©´ ë˜ëŠ”ë°, ë˜‘ê°™ì€ê²ƒì„ ë°˜ë³µì ìœ¼ë¡œ ë³´ë‚˜?
undefined- ì•„ë¬´ë¦¬ ë¶€ì •í•˜ë ¤ê³  í•˜ë”ë¼ë„ ì¸ì •í•  ìˆ˜ë°–ì— ì—†ëŠ” ì›ë¦¬.

## 4.2.3. Examples


### 4.2.3.1. [ex1] World Series Odds

- Problem
undefined
![0](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/0.png)


### 4.2.3.2. [Worse] A Divide-and-Conquer Approach

- Recursive formulation
undefined- overlap subproblem : overlappingí•˜ì§€ ì•Šìœ¼ë©´ì„œ sizeê°€ ì¤„ì—ˆë˜ dncì™€ ë‹¬ë¦¬ overlappingëœë‹¤. êµ‰ì¥íˆ ì•ˆ ì¢‹ì€ ìƒí™©. ê·¸ë˜ì„œ ì´ë¥¼ recursive fn call í•¨ìˆ˜ë¥¼ ì§œì„œ $P(100,100), P(50,50)$ì§œë³´ë¼
undefined- If we solve this recurrence relation in the divide-and-conquer way,
undefined- What is the problem of this approach?

![1](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/1.png)


### 4.3.2.3. [Better] A Dynamic Programming Approach

- í•µì‹¬ ê°œë… Table
undefined- $T(4,4) $: table setup í›„ ì´ë¥¼ ì±„ì›Œë‚˜ê°€ì„œ (fill)
undefined- í•œì¹¸ ì—¬í´ ì™¼ìª½ì— ìˆëŠ” ì• ì™€, í•œì¹¸ ì•„ë˜ ë°‘ìª½ì— ì‡ëŠ” ì• ë¥¼ í†µí•´ ê³„ì‹¼í•  ìˆ˜ ìˆë‹¤.
- $P(i,j) = 1 $ if $i=0, j>0$
- $P(i,j) = 0$ if $i>0, j=0$
- $P(i,j) = \frac{P(i-1,j) + P(i, j-1)}{2}$ if $i>0, j>0$
- fill í•˜ëŠ” ë°©ì‹
undefined- $T(n,n) = O(n^2)$dì„ì„ ë°”ë¡œ í™•ì¸í•´ì•¼í•œë‹¤.
undefined- Instead of computing the same repeatedly, fill in a table as suggested below:
undefined- Time Complexity
undefinedundefined
![2](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/2.png)

- DP ë¬¸ì œë¥¼ í‘¸ëŠ”ë° ì´ëŸ¬í•œ recursive structureê°€ ì¡´ì¬í•˜ê³ , ì´ë¥¼ divide and conquer ë¡œ top downìœ¼ë¡œ í’€ì–´ì•¼ í•œë‹¤ë©´ overlapping subproblemì˜ ë¬¸ì œê°€ë°œìƒí•œë‹¤.
undefined- ê°ê°ì˜ subproblem
undefined
# Dynamic Programming


> Top-down â†’ Bottom-up

- When theÂ **divide-and-conquer**Â approach produces anÂ **exponential algorithm**Â whereÂ **the same sub-problems are solved iteratively**,
undefined- master theoremê³¼ë„ ì—°ê³„
undefined- Three elements to consider in designing a dynamic programming algorithm
undefined- [Neapolitan] DP Procedure
undefined
# Application of DP


# 4.3.1. The Manhattan Tourist Problem

- Courtesy of [Jones & Pevzner 6.3]
undefined- Problem:
undefined
> ğŸï¸ ì–´ë–»ê²Œ í•˜ë©´ ë§ì€ ê´€ê´‘ì§€ë¥¼ì„ ìµœëŒ€ë¡œ ë°©ë¬¸í•  ìˆ˜ ìˆê² ëŠ”ê°€?

- (1) A <u>brute force</u> approach
undefined- (2) A greedy approach
undefined- <u>A formal description of this problem</u>
undefined- ì›ë˜ ë¬¸ì œì— ëŒ€í•´ì„œ ë‘ ê°œì˜ subproblem ìœ¼ë¡œ í‘¸ëŠ” ê²ƒ
undefined- ê²½ë¡œëŠ” ë‹¬ë¼ë„ ê¸¸ì´ëŠ” ê°™ì€ longest pathëŠ” ì¡´ì¬í•  ìˆ˜ ìˆë‹¤.
undefined- ìƒê°ì˜ íë¦„
undefined- solution : DP (bottom up)
undefined- divide and conquerì˜ overlapping subproblemìœ¼ë¡œ ìƒë‹¹íˆ ë§¤ì¹­
undefined- An example grid of sizeÂ (4,4)
undefined- shortest pathê°€ ì•„ë‹Œ longest path ë¬¸ì œ
undefined- A possible selection determined by a greedy approach

![3](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/3.png)

- <u>**Basic idea**</u>
undefined
![4](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/4.png)

- Optimal substructure :Â $S_{n,m} =?$
undefined
> ğŸ’¡ Induction, Base stepì— ê´€í•œ ê²ƒë“¤ë„ ì •í™•í•˜ê²Œ ê¸°ìˆ í•´ì£¼ì–´ì•¼ í•¨.

- Table setup and fill
undefined- Pseudocode
undefined- Given aÂ (_n_,_m_)Â grid, what is the time complexity T(n, m)?
undefined- So far, we have found theÂ **cost of the longest path**Â from source to each vertex in the grid.
- ê¸¸ì´ê°€ 34ì¸ longest pathëŠ” ì–´ë–»ê²Œ ì¶œë ¥í•  ìˆ˜ ìˆì„ê¹Œ?
undefined- Time complexity
undefined- Then, how can you print out theÂ **actual optimal path**Â from source to sink?
undefined
# 4.3.2. Chained Matrix Multiplication


[Neapolitan 3.4] dpì˜ ëŒ€í‘œì ì¸ ë¬¸ì œ

- In general, to multiply anÂ _a_Â xÂ _b_Â matrix with aÂ _b_Â xÂ _c_Â matrix using the standard method, it is necessary to doÂ _abc_Â elementary multiplications.
undefined
![5](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/5.png)

- Problem
undefined- Examples:Â  $A_1 (20 \times 2) \cdot A_2 (2 \times 30) \cdot A_3 (30 \times 12) \cdot A_4 (12 \times 8)$í•´
undefined- Divide and Conquer, Dynamic Programmping
undefined- Divide and Conquer â†’ Top-down
- Dynamic Programming â†’ Bottom-up
- Recursive : ë‚˜ë‘ ê°™ì´ ìƒê²¼ëŠ”ë°, ë‚˜ë³´ë‹¤ ì‚¬ì´ì¦‰ ì‘ì€ ë¬¸ì œë¥¼ í•´ê²°í•œë‹¤.
undefined- directed graphë¼ê³  ë´¤ì„ ë•Œ, ìµœì†Œ íšŸìˆ˜ë¡œ ê±´ë„ˆê°€ëŠ” ë¬¸ì œ
undefined
# 4.3.3. Dynamic programming approach

- Definition
undefined- Optimal subtructure
undefined
![6](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/6.png)

- Example:Â $M(2, 7)$
undefined- M(2,7)
undefined- Table fill order
undefined- Time complexity
undefined- Chained matrix multiplication problem
undefined- Printing optimal order
undefined
â†’Â $O(n)$Â time


![7](/assets/img/2022-09-28-[ALG]-4.1.-DP---Concepts.md/7.png)


# 4.4. Principles of Dynamic Programming

- $C_{ij}$Â = the cost of the shortest path fromÂ (0,0)Â toÂ (_i_,_j_)
undefined- Recursive formulation
- Optimal substructure
undefined- Overlapping subproblems
undefined- Bottom-up approach
undefined- Table Fill-up
undefined
## 4.4.1. Optimal SubstructureÂ [(wiki)](https://en.wikipedia.org/wiki/Optimal_substructure)


ì­‰ ì½ê³  ì•„ëŠ”ì²™ í•´ë´ì !! (dynamic programming)

- ë¬¸ì œì— ëŒ€í•´ì„œ DPë¥¼ ì ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” optimal substructureë¥¼ ì°¾ì•„ë‚´ì•¼ í•œë‹¤
undefined- Dynamic programming algorithms are oftenÂ **used for optimization**.
undefined- A problem is said to haveÂ **optimal substructure**
undefined- Consequently, the first step towards devising a dynamic programming solution is to check whether the problem exhibits such optimal substructure.
undefined
## 4.4.2. Overlapping SubproblemsÂ [(wiki)](https://en.wikipedia.org/wiki/Overlapping_subproblems)


> ğŸ’¡ í° ë¬¸ì œë¥¼ í‘¸ëŠ”ë°, recursiveí•˜ê²Œ ì‘ì€ ë¬¸ì œë¥¼ ê³„ì†í•´ì„œ top downì‹ìœ¼ë¡œ í’€ ë•Œ ê°™ì€ ì‹ìœ¼ë¡œ ë°˜ë³µì ìœ¼ë¡œ ë‚˜ì˜¤ëŠ” ê²½ìš° : overlapping problem ë¬¸ì œê°€ ì‹¬ê°í•  ë•Œ

- To solve a problem, we often need toÂ **solve different parts of the problem (subproblems), then combine the solutions of the subproblems to reach an overall solution**.
- A problem is said to haveÂ <u>**overlapping subproblems**</u>Â if
undefined- The dynamic programming approach seeks toÂ **solve each subproblem only once**, thus reducing the number of computations:
undefined- This approach isÂ **especially useful when the number of repeating subproblems grows exponentially**Â as a function of the size of the input.
- **If a problem can be solved by combining optimal solutions to non-overlapping sub-problems**, the strategy is called "divide-and- conquer" instead. This is why merge sort and quick sort are not classified as dynamic programming problems.
undefined- $C_{ij} = min \{C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} \}$

## 4.4.3. The Checkerboard Problem


[Courtesy of Wikipedia]

- ì²´ìŠ¤íŒ
- Restrictions
undefined- Cost table $c [i] [j]$
undefined- Problem
undefined- Ex. 1 ê¹Œì§€ì˜ ìµœì†Œë¹„ìš© [4][4]
undefined- Optimal substructure
undefinedundefined
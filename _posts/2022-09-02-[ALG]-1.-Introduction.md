---
layout: post
date: 2022-09-02
title: "[ALG] 1. Introduction"
tags: [Algorithm, ]
categories: [Notes, ]
use_math: true
---


Algorithm : Big O and MSS


# **1.0. Computational Thinking**


## **Definition of computational thinking**


The thought processes involved in (i) formulating a problem and (ii) expressing its solutions in such a way that a computer --human or machine- can effectively carry out.

1. Problem formulation (abstraction)
2. Solution expression (automation)
3. Solution execution & evaluation (analyses)

## **Characteristics of computational thinking**

- Formulating problems in a way that enables us to use a computer and other tools to help solve them
- Logically organizing and analyzing data â†’ Data structure
- Representing data though abstractions such as models and simulations â†’ Data Structure
- Automating solutions through algorithmic thinking (a series of ordered steps) â†’ Algorithm
- Identifying, analyzing, and implementing possible solutions with the goal of achieving the most efficient and effective combination of steps and resources â†’ time and space complexity
- Generalizing and transferring the problem solving process to a wide variety of problems

## **Problem Solving in Computer Science and Engineering**


ë¬¸ ì œ (Problem)Â â†’Â í•´ (Solution)

- Problem : ê°€ìƒ í˜„ì‹¤, ë¬¸ì„œì‘ì„±, í™ˆë±…í‚¹, ì¸í„°ë„· ì‹ ë¬¸, ë¬¸ì„œ ë²ˆì—­, íšŒë¡œ ì„¤ê³„, ìœ ì „ì ë¶„ì„, ë¬´ì¸ ìë™ì°¨, ì˜¨ë¼ì¸ ê²Œì„, ë¹„ë””ì˜¤ í¸ì§‘, ìë£Œ ê²€ìƒ‰, ì˜í™” ì œì‘, ìŒì„± ì¸ì‹, ê°€ìƒ ìˆ˜ìˆ , ê±´ì¶• ì„¤ê³„, ê¸°ìƒ ì˜ˆì¸¡, ì£¼ê°€ ì˜ˆì¸¡, ì¸ê³µ ì§€ëŠ¥, ëŒ€ìš©ëŸ‰ ê³¼í•™ ê³„ì‚°, â€¦

## **Problem Solving Pipeline**


![0](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/0.png)


# **ë„ê°• ë¬¸ì œ**


í•œ ì–´ë¶€(M)ê°€ ëŠ‘ëŒ€(W), ì—¼ì†Œ(G), ì–‘ë°°ì¶”(C)ë¥¼ ê°• í•œ ìª½ì—ì„œ ë‹¤ë¥¸ ìª½ìœ¼ë¡œ ì˜®ê¸°ë ¤ í•œë‹¤. ì–´ë¶€ê°€ ë°°ë¥¼ íƒ€ê³  ê°•ì„ ê±´ë„ ë•Œ ì–´ë¶€ ìì‹  ì™¸ì— ëŠ‘ëŒ€, ì—¼ ì†Œ, ì–‘ë°°ì¶” ì¤‘ í•˜ë‚˜ë§Œ ë°°ì— ê°€ì§€ê³  ê°ˆ ìˆ˜ê°€ ìˆëŠ”ë°, ë¬¸ì œëŠ” ì–´ë¶€ê°€ ëŠ‘ëŒ€ ë¥¼ ì‹£ê³  ê°€ëŠ” ë™ì•ˆ, ì—¼ì†Œê°€ ì–‘ë°°ì¶”ë¥¼ ê°™ì€ ìª½ì— ë‚¨ê²¨ë‘ë©´ ì—¼ì†Œê°€ ì–‘ë°° ì¶”ë¥¼ ë¨¹ì–´ë²„ë¦¬ê²Œ ë˜ê³ , ì–‘ë°°ì¶”ë¥¼ ì‹£ê³  ê°ˆ ë•Œ ëŠ‘ëŒ€ì™€ ì—¼ì†Œë¥¼ ê°™ì€ ìª½ì— ë‚¨ê²¨ë‘˜ ê²½ìš° ëŠ‘ëŒ€ê°€ ì—¼ì†Œë¥¼ ì¡ì•„ ë¨¹ê²Œ ëœë‹¤. ê³¼ì—° ì–´ë–»ê²Œ í•˜ë©´ ì–´ë¶€ê°€ ê°€ì¥ ì ì€ íšŒìˆ˜ë¡œ ê°•ì„ ê±´ë„ˆë©´ì„œ ì„¸ ê°€ì§€ë¥¼ ëª¨ë‘ ì•ˆì „í•˜ê²Œ ì˜®ê¸¸ ìˆ˜ ìˆì„ê¹Œ?


## **ë¬¸ì œ ë¶„ì„**


![1](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/1.png)

- 

![2](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/2.png)


## **í•´ë²• ê³ ì•ˆ**

- Graph, search, and so on â†’ Which data structures and algorithms?
- Cost, time, space, and so on â†’ What complexities?

[ì—°ìŠµ] ì´ ë¬¸ì œì— ëŒ€í•œ ì•Œê³ ë¦¬ì¦˜ê³¼ ì‹œê°„/ê³µê°„ ë³µì¡ë„ë¥¼ ì»´í“¨í„°í•™ì˜ ìš© ì–´ë¥¼ ì¨ì„œ ê¸°ìˆ í•œë‹¤ë©´, ???

- ë¬´ìŠ¨ ë§ì¸ì§€ ì „í˜€ ëª¨ë¥´ê² ìœ¼ë©´ [43-080 ìë£Œêµ¬ì¡°]ë¥¼ ì¬ìˆ˜ê°•í•œ í›„ ì´ ê³¼ëª©ì„ ë“¤ì„ ê²ƒ!

# **êµ¬í˜„ : âœ“ Programming is an art!**

- ì–´ë–»ê²Œ í•˜ë©´ ì£¼ì–´ì§„ ì•Œê³ ë¦¬ì¦˜ì„ ê°€ì¥ íš¨ê³¼ì ìœ¼ë¡œ êµ¬í˜„ì„ í•  ìˆ˜ ìˆì„ê¹Œ?
- ì–´ë–»ê²Œ í•˜ë©´ C/C++ë¥¼ ì‚¬ìš©í•˜ì—¬ ì£¼ì–´ì§„ ì•Œê³ ë¦¬ì¦˜ì„ ê°€ì¥ ìµœì ìœ¼ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆì„ê¹Œ?
	- ì›ì‹œ ì½”ë“œ ë ˆë²¨ì˜ ì¸¡ë©´
	- ì–´ì…ˆë¸”ëŸ¬ ë ˆë²¨ì˜ ì¸¡ë©´
	- ì‹œìŠ¤í…œ ë ˆë²¨ì˜ ì¸¡ë©´
	- ê¸°íƒ€
- âœ“ ê³¼ì—° ë‚´ê°€Â [http://acm.uva.es/problemset/ì—](http://acm.uva.es/problemset/%EC%97%90)Â ìˆëŠ” ë¬¸ì œë“¤ì„ ìŠ¤ìŠ¤ë¡œ â€œë¬¸ì œ ë¶„ì„Â â†’Â í•´ë²• ê³ ì•ˆÂ â†’Â êµ¬í˜„â€ ê³¼ì •ì„ í†µí•˜ì—¬ íš¨ê³¼ì ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆì„ê¹Œ???
	- Programming Challenges by S. Skiena and M. Revilla, Springer, 2003.
- ì–´ë–»ê²Œ í•˜ë©´ ì¢‹ì€ êµ¬í˜„ ê²°ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆëŠ”ê°€?
	- ë™ì¼í•œ í”„ë¡œì„¸ì„œ ìƒì—ì„œ ë” ë¹ ë¥´ê²Œ
	- ì ì€ ë©”ëª¨ë¦¬ë§Œ ì‚¬ìš©í•˜ê²Œ
	- ì•ˆì •ì ì´ê²Œ
- êµ¬í˜„ ì˜ˆ

	![3](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/3.png)


	![4](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/4.png)


19 0.265968ì´ˆ 4.862961ì´ˆ 3.4GHz Intel Core i7 CPU


# **Data Structure â†’ Algorithm â†’ Theory of Computation**

- ì–´ë–»ê²Œ í•˜ë©´ ì£¼ì–´ì§„ ë³µì¡í•œ ë¬¸ì œë¥¼ ì´ì§„ìˆ˜ í˜•íƒœì˜ ë‚®ì€ ìˆ˜ì¤€ì˜ ëª…ë ¹ì–´ë§Œ ì´í•´í•˜ëŠ” â€˜ë‹¨ìˆœí•œâ€™ ì»´í“¨í„° ìƒì—ì„œ íš¨ìœ¨ì ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆì„ê¹Œ?
1. [Data Structure] ì£¼ì–´ì§„ ì¶”ìƒì ì¸ ë¬¸ì œë¥¼ ì–´ë– í•œ ìë£Œ êµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ì—¬ ì»´ í“¨í„°ì˜ êµ¬ì¡°ì— ìµœì í™”ëœ í˜•íƒœë¡œ í‘œí˜„í•  ìˆ˜ ìˆì„ê¹Œ?
2. [Algorithm] ì£¼ì–´ì§„ ì¶”ìƒì ì¸ ë¬¸ì œë¥¼ ì–´ë– í•œ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ì»´í“¨í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ ê°€ì¥ íš¨ìœ¨ì ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆì„ê¹Œ?
3. [Complexity] ê³¼ì—° ì»´í“¨í„°ê°€ ì£¼ì–´ì§„ ë¬¸ì œë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆì„ê¹Œ ?
4. [Computability] ê³¼ì—° ì»´í“¨í„°ê°€ ì„¸ìƒì˜ ëª¨ë“  ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆì„ê¹Œ?
- âœ“ ì´ ê³¼ëª©ì—ì„œëŠ” [CSE3080 ìë£Œêµ¬ì¡°] ê³¼ëª©ì— ì´ì–´, 1ë²ˆê³¼ 2ë²ˆì„ ì§‘ì¤‘ì ìœ¼ë¡œ ì‚´í´ë³´ ê³ , 3ë²ˆ ë¬¸ì œì— ëŒ€í•˜ì—¬ ì–´ëŠ ì •ë„ ì‚´í´ë³¼ ì˜ˆì •ì„.
- 4ë²ˆ ë¬¸ì œëŠ” [CSE3085 ìë™ì¥ì¹˜ì´ë¡ ] ê³¼ëª©ì—ì„œ ë‹¤ë£¸.

# **1.1 - 1.2 Solve with Alg**


# **1. How to think and solve problems with computer**


## **Data Structureâ†’Algorithmâ†’Theory of Computation**

- ì–´ë–»ê²Œ í•˜ë©´ ì£¼ì–´ì§„ ë³µì¡í•œ ë¬¸ì œë¥¼ ì´ì§„ìˆ˜ í˜•íƒœì˜ ë‚®ì€ ìˆ˜ì¤€ì˜ ëª…ë ¹ì–´ë§Œ ì´í•´í•˜ëŠ” â€˜ë‹¨ìˆœí•œâ€™ ì»´í“¨í„° ìƒì—ì„œ íš¨ìœ¨ì ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆì„ê¹Œ?
	1. [Data Structure] ì£¼ì–´ì§„ ì¶”ìƒì ì¸ ë¬¸ì œë¥¼Â **ì–´ë– í•œ ìë£Œ êµ¬ì¡°**ë¥¼ ì‚¬ìš©í•˜ì—¬ ì»´ í“¨í„°ì˜ êµ¬ì¡°ì— ìµœì í™”ëœ í˜•íƒœë¡œ í‘œí˜„í•  ìˆ˜ ìˆì„ê¹Œ?
	2. [Algorithm] ì£¼ì–´ì§„ ì¶”ìƒì ì¸ ë¬¸ì œë¥¼ ì–´ë– í•œÂ **ì•Œê³ ë¦¬ì¦˜ì„**Â ì‚¬ìš©í•˜ì—¬ ì»´í“¨í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ ê°€ì¥ íš¨ìœ¨ì ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆì„ê¹Œ
	3. [Complexity] ê³¼ì—° ì»´í“¨í„°ê°€ ì£¼ì–´ì§„ ë¬¸ì œë¥¼Â **íš¨ìœ¨ì ìœ¼ë¡œ**Â í•´ê²°í•  ìˆ˜ ìˆì„ê¹Œ ?
	4. [Computability] ê³¼ì—° ì»´í“¨í„°ê°€ ì„¸ìƒì˜Â **ëª¨ë“  ë¬¸ì œë¥¼ í•´ê²°**í•  ìˆ˜ ìˆì„ê¹Œ?
- Data Structure & AlgorithmÂ â†’Â 1, 2, 3
- Automata TheoryÂ â†’Â 4

# **2. Def. of Algorithm**


## **Definition of Algorithm**


from [Horowitz 1.2]

- AnÂ **algorithm**Â is aÂ **finite set of instructions that**, if followed, accomplishes a particular task. In addition, all algorithms must satisfy the following criteria:
	1. **Input**.
	- Zero or more quantities from the outside.
	- ì™¸ë¶€ë¡œë¶€í„° 0ê°œ ì´ìƒì˜ ìˆ˜ëŸ‰ì´ ì…ë ¥ìœ¼ë¡œì„œ ë“¤ì–´ì˜¨ë‹¤.
	1. **Output**.
	- At least one quantity is produced.
	- í•˜ë‚˜ ì´ìƒì˜ ê²°ê³¼ê°’ì´ ìˆ˜í–‰ëœë‹¤.
	1. **Definiteness**.
	- Each instruction is clear and unambiguous.
	- ê° ì§€ì¹¨ì€ ëª¨ë‘ ëª…í™•í•˜ë©°, ì• ë§¤í•˜ê²Œ ì“°ì—¬ ìˆì§€ ì•Šë‹¤.
	1. **Finiteness**.
	- If we trace out the instructions of an algorithm, then for all cases, the algorithm terminates after a finite number of steps.
	- ì œí•œëœ ìˆ˜ì˜ ë‹¨ê³„ í›„ ì¢…ë£Œëœë‹¤.
	1. **Effectiveness**.
	- Every instruction must be basic enough to be carried out, in principle, by a person using only pencil and paper.
	- ì†ìœ¼ë¡œ í’€ ìˆ˜ ìˆì„ ë§Œí¼ íš¨ê³¼ì ì´ì–´ì•¼ í•œë‹¤.
	- It is not enough that each operation be definite as in (3);
	- it also must be feasible. ë˜í•œ ì‹¤í˜„ ê°€ëŠ¥í•˜ì—¬ì•¼ í•œë‹¤.

## **Thoughts on 4) Finiteness: [Computability]**

- Problem ([Postâ€™s correspondence problem](https://en.wikipedia.org/wiki/Post_correspondence_problem)Â í¬ìŠ¤íŠ¸ ëŒ€ì‘ ë¬¸ì œ)
	- ê²°ì • ë¶ˆê°€ëŠ¥í•œ ê²°ì • ë¬¸ì œì˜ ì˜ˆì‹œ, 1946ë…„ emil post ì— ì˜í•´ ê³ ì•ˆ
	- Consider a finite setÂ _P_Â of ordered pairs of nonempty strings such asÂ _P_={(_a_,_ab_),(_b_,_c__a_),(_c__a_,_a_),(_ab__c_,_c_)}
	- A match ofÂ _P_Â is any string w such that, for someÂ _m_>0Â and some pairsÂ (_u_1,_v_1),(_u_2,_v_2),...,(_u__m_,_v__m_)âˆˆ_P_,Â _w_=_u_1_u_2..._u__m_=_v_1_v_2..._v__m_.
	- Design an algorithm that determine, given P, whether P has a match.
- Cheolsuâ€™s algorithm

	```c++
	For i = 1, 2, 3, ... do
	  For each permutation of P of length i, do
	    If it is a match, print â€˜yesâ€™ and exit.
	    If not, continue.
	
	```

	- Can this be regarded as an algorithm?

## **Thoughts on Efficiency: [Complexity]**

- **An algorithm is regarded as efficient or good**Â if there exist a polynomialÂ _P_(_n_)Â such that the time required for solving any instance of sizeÂ _n_Â is bounded above byÂ _P_(_n_).
- NP-Complete problems:
	- Nobody has found so far any good algorithm for any problem in this class.
	- It has been proved that if a good algorithm exists for some algorithm in this class, then a good algorithm exists for all NP-Complete Problem.
- Examples
	- Suppose a CD-ROM can store up to 720MBytes of data. You have a sequence of n files of sizesÂ _s_1,_s_2,...,_s__n_Â Mbytes, to dump into backup CDs. What is the minimum number of necessary CDs to store all the files?
	- Consider n tasks to be executed on CPU. All the tasks must be finished within the time requirement L (seconds). If theÂ _i_th task takesÂ _s__i_Â seconds, and you can harness multiple processors, what would be the minimum number of processors needed to accomplish this?
	- Ex.Â _L_=10,Â _n_=6, and $(s_1, s_2, s_3, s_4, s_5, s_6) = (5, 6, 3, 7, 5, 4) $
	- thenÂ (5,5),(6,4),(7,3)

ì–´ë–»ê²Œ í•˜ë©´ ì¢€ ë” â€œíš¨ìœ¨ì ìœ¼ë¡œâ€ ë¬¸ì œë¥¼ í•´ê²°í• ê¹Œ?


## **Efficient Algorithm Design**


**Example 1**

- Sequential search vs binary search
	- Problem: Determine whetherÂ _x_Â is in the sorted arrayÂ _S_Â ofÂ _n_Â keys.
	- Inputs: positive integerÂ _n_, sorted (nondecreasing order) arrays of keys S indexed fromÂ 0Â toÂ _n_âˆ’1, a keyÂ _x_.
	- Outputs: the location ofÂ _x_âˆˆ_S_Â (âˆ’1Â ifÂ _x_âˆˆ/_S_).
- Sequential search:Â _T_(_n_)=_O_(_n_)
- Binary search:Â _T_(_n_)=_O_(_l__o__g__n_)
- 

	![5](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/5.png)

	- [From Neapolitan] The number of comparisons done by Sequential & Binary Search whenÂ _x_Â is larger than all the array items
		- 40ì–µ ê°œì˜ elementê°€ arrayì— ìˆì„ ë•Œ, Sequential SearchëŠ” 40ì–µ ê°œ í•­ëª©ê³¼ ë¹„êµí•˜ëŠ” ë°˜ë©´ì— Binary SearchëŠ” ë‹¨ 33ê°œì˜ í•­ëª©ë§Œì„ ë¹„êµí•œë‹¤.
		- ì»´í“¨í„°ê°€ 1nsì— whlie loopë¥¼ í†µê³¼í•  ìˆ˜ ìˆë‹¤ê³  ê°€ì •í•œë“¤ Binary searchëŠ” ì¦‰ê°ì ìœ¼ë¡œ ê²°ì •ì„ ë‚´ë¦¬ëŠ” ë°˜ë©´ Sequential SearchëŠ” 4sê°€ ê±¸ë¦°ë‹¤.
- Why is the binary search more efficient? ì™œ ì´ì§„ê²€ìƒ‰ì´ ë” íš¨ìœ¨ì ì¸ê°€?

**Example 2:The Fibonacci Sequence**

- Problem: Determine theÂ _n_th term in the Fibonacci sequence.
- Inputs: a nonnegative integerÂ _n_
- Outputs: the nth term of the Fibonacci sequence.

	_f_0=0_f_1=1_f__n_=_f__n_âˆ’1+_f__n_âˆ’2Â forÂ _n_â‰¥2


```c++
//<recursive: divide-and-conquer>
int fib (int n) {
  if (n == 0) return 0;
  else if (n == 1) return 1;
  else return fib(n-1) + fib(n-2);
}

//<iterative: dynamic programming>
  int fib(int n) {
  index i;
  int f[0 .. n];
  f[0] = 0;
  if (n > 0) {
  	f[1] = 1;
    for (i = 2; i <= n; i++)
      f[i] = f[i-1] + f[i-2];
  }return f[n];
}

```

- Recursive: $T(n) = O(2^n) $
- Iterative:Â _T_(_n_)=_O_(_n_)
- Why is the iterative version more efficient?
	- 

		![6](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/6.png)

	- _T_(_n_)>22_n_Â forÂ _n_â‰¥2
	- Mathematical inductionì„ ì¨ì„œ ì¦ëª…í•´ë³¼ ê²ƒ!
- Linear versus exponential
	- 

		![7](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/7.png)

	- [From Neapolitan] This table compares these expressions for various values of n. The execution times are based on the simplifying assumption that one term can be computed inÂ 10âˆ’9Â second.
	- The table shows the time it would take 'Iterative Algorithm' to compute the nth term on a hypothetical computer that could compute each term in a nanosecond, and it shows a lower bound on the time it would take to execute 'Iterative Algorithm'.
	- By the time n is 80, 'Recursive Algorithm' takes at least 18 minutes. When n is 120, it takes more than 36 years, an amount of time intolerable compared with a human life span. Even if we could build a computer one billion times as fast, 'Recursive Algorithm' would take over 40,000 years to compute the 200th term. This result can be obtained by dividing the time for the 200th term by one billion.
	- We see that regardless of how fast computers become, 'Recursive Algorithm' will still take an intolerable amount of time unless n is small. On the other hand, 'Iterative Algorithm' computes the nth Fibonacci term almost instantaneously.

	This comparison shows why the efficiency of an algorithm remains an important consideration regardless of how fast computers become


# [ALG] 1.3. Order of Algorithms (1)

- ì œì¼ ë¨¼ì € ìƒê°
	- Input Size
		- Problemì„ í’€ê³ ì í•˜ëŠ”ë° ì´ë¥¼ solí•˜ê³ ì í•˜ëŠ” algorithmì—ì„œ, ì•Œê³ ë¦¬ì¦˜ì— ë“¤ì–´ì˜¤ëŠ” dataì˜ í¬ê¸°ëŠ” ì–´ë–»ê²Œ ë˜ëŠ”ê°€.
			- ë¬¸ì œ ìƒí™©ì— ë”°ë¼ ê°€ë¡œ n, ì„¸ë¡œ mì˜ ë°ì´í„°ê°€ ë“¤ì–´ì˜¤ë©´ (n,m) nì¼ìˆ˜ë„ nmì¼ìˆ˜ë„ ìˆë‹¤.
		- data sizeê°€ ì»¤ì§ì— ë”°ë¼ ì–¼ë§ˆë‚˜ ì‹œê°„ì´ ê±¸ë¦¬ëŠ”ê°€ ë¶„ì„ : ì–¼ë§ˆë‚œ í¬ê¸°ì˜ ë°ì´í„°ê°€ ë“¤ì–´ì™”ì„ ë•Œ, ì–¼ë§ˆë‚˜ ì‹œê°„ì´ ê±¸ë¦¬ëŠ”ê°€.
		- ì‹œê°„ ë¶„ì„ì˜ ê¸°ë³¸ ìš”ì†Œ : dataì˜ ìˆ˜
	- Cost : $g(n)$
		- ë¬¸ì œê°€ ìˆì„ ë•Œ nì— ëŒ€í•˜ì—¬ ì–´ëŠ ì •ë„ì˜ ë¹„ìš©ì´ ê±¸ë¦¬ëŠ”ê°€.

# _O_Â (BigÂ $O$Â Notation)


> ğŸ’¡ for given two functionsÂ $f(n)$Â andÂ $g(n)$,  
>   
> $g(n) = O(f(n))\iff \exists c \in \mathbb{R}, N \in \mathbb{N}\quad g(n)\leq c\cdot f(n), \forall n \geq N$

- complexityë¥¼ ë”°ì§ˆ ë•Œ, data sizeê°€ ì‘ì„ ë•Œ ë³´ë‹¤ëŠ” ì»¤ì§ˆ ë•Œ ë¬¸ì œê°€ ë°œìƒí•¨ì„ í™•ì¸í•˜ê³  ì‹¶ìŒ.
	- â†’ ëª¨ë“  nì¼ í•„ìš”ëŠ” ì—†ê³ , ê·¸ Në³´ë‹¤ í° ëª¨ë“  input sizeì— ëŒ€í•´ì„œ ì´ëŸ¬í•œ ì¡°ê±´ì„ ë§Œì¡±í•˜ë©´.
- then we say that :$g(n)$Â is big O ofÂ $f(n)$
- ì˜ˆ)
	- ì½”ë“œì˜ ë¹„ìš©ì„ ë¶„ì„í•´ ë´¤ë”ë‹ˆ
		- for loop 1, for loop n ììŠ¹ë§Œí¼ ëŒê²Œ ëœë‹¤.

		```c
		x = x + 1;
		for (i = 1; i <= n; i++)
			y = y + 2;
		for (i = n; i >=1; i--)
			for (j = n; j >= 1; j--)
				z = z + 1;
		```

- ë¹„ìš© :Â $g(n) = c_0 + c_1 n + c_2 n^2$
- ì˜ˆ :Â $g(n) = 5 + 6 + 7n^2 \leq 8n^2 \quad \forall n \geq 8$
	- $8 \cdot n^2 = c \cdot f(n), N = 8$
		- nì´ ì»¤ì§€ë©´ g(n)ì´ ì••ë„ì ìœ¼ë¡œ ë‹¤ë¥¸ ì¹œêµ¬ë“¤ì„ ëˆ„ë¥´ê²Œ ëœë‹¤.
		- ë‹¤ì‹œí•œë²ˆ ì´ì•¼ê¸°í•˜ì§€ë§Œ, nì´ ì»¤ì§ˆ ë•Œ, ë‚´ê°€ ë¶„ì„í•œ ë¹„ìš©ì€ f(n)ì´ë¼ëŠ” í•¨ìˆ˜ì— ëˆŒë¦¬ê²Œ ë˜ëŠ” upper bound ê°œë…
	- $g(n) = O(n^2)$
- $g(n) = O(n^{1000})$?
	- ì •ì˜ì— ì˜í•˜ë©´ ë§ìŒ : ê·¸ë˜í”„ìƒ í™•ì¸í•´ë³´ì•„ë„ ë§ìŒ.
	- $f(n)\geq g(n) \cdot c$

## Notes for big O

- [Note 1] The big O puts anÂ <u>**asymptotic**</u>Â <u>upper bound</u> on a function.
	- ë³µì¡ë„ë¥¼ ë”°ì§ˆ ë•Œ â€˜ëª‡ ì´ˆ'ê°€ ê±¸ë¦°ë‹¤ê¸° ë³´ë‹¤ëŠ” ì–¼ë§ˆë‚˜ íš¨ìœ¨ì ì¸ê°€ë¥¼ ë”°ì§€ëŠ” ì²™ë„
		- PL, HW ìƒí™©ì— ëŒ€í•´ì„œ implementation ê´€ì ì—ì„œ ê°œì¸ ì°¨ ë°œìƒ
	- Asymptotic analysis (from Wikipedia)
		- asymptotic : ì ê·¼ì ì¸
		- data sizeê°€ ì»¤ì§ˆ ë•Œ, ì´ ì•Œê³ ë¦¬ì¦˜ì´ ì‹œê°„ì´ë‚˜ í•„ìš”ë¡œ í•˜ëŠ” ë©”ëª¨ë¦¬ ì‚¬ì´ì¦ˆê°€ ì–¼ë§ˆë‚˜ ë‚˜ë¹ ì§€ëŠ”ê°€? â†’ ì•Œê³ ë¦¬ì¦˜ì´ ìš”êµ¬í•˜ëŠ” ì‹œê°„, ë©”ëª¨ë¦¬ ì–‘ ë“±ì´ ì–¼ë§ˆë‚˜ ë‚˜ìœ í˜•íƒœë¡œ ë³€í™”í•˜ëŠ”ì§€ â€˜í˜•íƒœâ€™

			> IfÂ $f(n) = n^2 + 3n$, then as n becomes very large, the termÂ $3n$Â becomes insignificant compared toÂ $n^2$. The functionÂ f(n)f(n)Â is said to be "asymptotically equivalent toÂ n^2n2, asÂ $nâ†’âˆ$". This is often written symbolically asÂ $f(n) -> n^2$, which is read as "$f(n)$Â is asymptotic toÂ $n^2$".

	- ê³„ì‚° ë¹„ìš©ì´Â $0.01n^2$Â ê³¼Â $100n$Â ì•Œê³ ë¦¬ì¦˜ ì¤‘ ì–´ë–¤ ê²ƒì´ ë” íš¨ìœ¨ì ì¸ê°€?
		- ì´ë¡ ì ì¸ ê´€ì ì—ì„œ $100n = O(n), 0.01n^2 = O(n^2)$
		- input size $n=3$: $0.09 \quad 300$
		- input size $n=10^6$: $0.01 \cdot (10^6)^2 = 10^{10}$, $100 \cdot 10^6 = 10^8$

		â†’ ê²°êµ­ $O(n^2)$

	- (Tight) upper bound
		- $37log n + 0.1n = O(n)$
			- nì´ ì»¤ì§€ë©´ $\log n$ì€ ìƒë‹¹íˆ ì‘ì•„ì§
		- $n^2 + 10n = O(n^2)$
		- $4(\log n)^2 + n \log n + 100n = O(n \log n)$
			- $\log n$ vs $n$ â†’ ë‹¹ì—°í•˜ê²Œ $\log n$
			- $n \log n > {\log n} ^2$
		- $n^2 + 10n = O(n^{200})$???
			- upper bound ë§ì•„ í‹€ë¦° ë§ì€ ì•„ë‹ˆì§€ë§Œ, ì¼ë°˜ì ìœ¼ë¡œ O Notationì„ í™œìš©í•  ë•Œì—ëŠ” tight upper boundë¥¼ ì„ íƒí•˜ì—¬ í‘œí˜„í•œë‹¤.

		> ğŸ’¡ Dominating Term   
		> - ì§€ë°°í•˜ëŠ” termì„ ì°¾ì•„ Upper Boundë¥¼ ì°¾ëŠ”ë‹¤.

			- ì§€ë°°í•˜ëŠ” termì„ ì°¾ì•„ Upper Boundë¥¼ ì°¾ëŠ”ë‹¤.
		- $\log _en $ë“± baseëŠ” ì™œ ê³ ë ¤í•˜ì§€ ì•ŠëŠëƒ â†’ ìƒìˆ˜ì— í•´ë‹¹í•˜ë¯€ë¡œ ìƒê´€ ì—†ê¸° ë•Œë¬¸ì—.
			- $\log _2 n = \frac {\log_e n }{\log_e2}$

	### Growth Rates of Some Common Complexity Functions

	- ì´ë¡ ì ìœ¼ë¡œëŠ” $n^3$ì€ efficientí•˜ì§€ë§Œ í˜„ì‹¤ì ìœ¼ë¡œëŠ” ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆì„ë§Œí•œ ë³µì¡ë„
	- ê°ë‹¹í•  ìˆ˜ ì—†ì„ ì •ë„ë¡œ ì»¤ì§€ë„¤ ë“± asymptotic íŠ¹ì„±ì„ ë¶„ì„í•˜ê¸° ìœ„í•¨

![8](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/8.png)

- [Note 2] Given a cost function g(n), how do you find the proper complexity functionÂ f(n)Â such that $g(n) = O(f(n))$?
	- Suppress lower-order terms and constant factors!
	- Example:
		- $10^3 + 10^3n + 10^-3 n^2 = O(n^2)$
			- thenÂ $lim_{n \to \infty} \frac{n^2}{n} = \infty$
		- $5n \log_3 n + 3(\log_2 n)^2 + n + 6n^2 = O(n^2)$
			- thenÂ $lim_{n \to \infty} \frac{n}{log_en} = lim _{n \to \infty} = \infty$
		- $3(log_2 n)^2+ 0.1n = O(?)$
			- Dominate Termì´ ë¬´ì—‡ì¼ê¹Œ?
			- $\lim _{n \rightarrow \infty}{\frac {(\log n)^2}{n}}$ =$\infty, c, 0$
				- $\infty$ : $(\log n)^2$ , $0$ : $n$ , $c$ :
				- Lâ€™Hospital Theorem : $\lim _{n \rightarrow \infty}{\frac {f(n)}{g(n)}} = \lim _{n \rightarrow \infty}{\frac {f'(n)}{g'(n)}} $
					- $\lim _{n \rightarrow \infty}{\frac {(\log n)^2}{n}} = \lim = \lim _{n \rightarrow \infty} {\frac {2}{n}{}}0$
			- â†’ Linear Time
		- $2^{n+5} = O(2^n)$Â ??
		- $2^{5n} = O(2^n)$??

## Comparing Orders of Growth

- How do you compare orders of growth of two functions?
	- One possible way is to compute the limit of the ratio of two functions in question.
	- $x = lim_{n \to \infty } \frac{f_1(n)}{f_2(n)}$
		- ifÂ _x_=0,Â _f_1Â has a smaller order of growth thanÂ _f_2
		- ifÂ $x=c$,Â $f_1$Â has a same order of growth thanÂ $f_2$
		- ifÂ $x=\infty$,Â $f_1$Â has a larger order of growth thanÂ $f_2$
	- Ex.1:Â $\log_2 n $ vs. $\sqrt{n}$
		- $lim_{n \to \infty} \frac{log_2 n}{\sqrt(n)} = lim_{n \to \infty} \frac{(log_2 n)'}{(\sqrt(n))'} = lim_{n \to \infty} \frac{(log_2 e)\frac{1}{n}}{\sqrt\frac{1}{2\sqrt(n)}} $
	- Ex.1.2.:Â $\log_2 n $ vs. $n^{0.0001}$
		- $lim_{n \to \infty} \frac{log_2 n}{\sqrt(n)} $
	- Ex.2:Â $n!$Â vsÂ $2^n$ - factorial vs. exponential
		- $lim_{n \to \infty} \frac{ n!}{2^n} = lim_{n \to \infty} \frac{\sqrt{2 \pi n} (\frac {n}{e})^n}{2^n}=lim_{n \to \infty }\sqrt{2 \pi n} \frac{({n})^n}{2^n e^n}$
		- stirling's formula :Â $n! \approx \sqrt{2 \pi n} (\frac {n}{e})^n$

# $Î©$Â (Big Omega Notation)


â†’ Lower Bound

- for two given functionsÂ $f(n), g(n)$

> ğŸ’¡ $g(n) = \Omega(f(n))g(n)=Î©(f(n)) âŸº \exists c \in \mathbb{R}, âˆƒcâˆˆR,$ and $N \in \mathbb{Z^+ \cup {0}}$, s.t.Â $g(n) \geq cf(n) \forall n \geq N$

- We say thatÂ g(n)_g_(_n_)Â isÂ _Ï‰_Â ofÂ $f(n)$.
- TheÂ Î©Â puts an asymptotic lower bound on a function.
- Ex:
	- $37\log n+0.1n=\Omega(n)$
	- $n^2 + 10n = \Omega(n^2)$
	- $4(logn)^2 +nlogn+100n=\Omega(nlogn)$
	- $n^{200} +10n=\Omega(n^2)$
	- 

		![9](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/9.png)


# $Î˜$Â (Big Theta Notation)

- for two given functionsÂ f(n)_f_(_n_)Â ,Â g(n)_g_(_n_)
	- ìœ„ì—ì„œ ëˆ„ë¥´ê³ 
	- ì•„ë˜ì—ì„œ ëˆ„ë¥´ê³ 

> ğŸ’¡ $g(n) = \Theta(f(n))g(n)=Î˜(f(n))Â \iffâŸºÂ g(n) = O(f(n))g(n)=O(f(n))Â andÂ g(n) = \Omega (f(n))$

- that is,

	> ğŸ’¡ $g(n) = \Theta (f(n))g(n)=Î˜(f(n))Â \iffâŸºÂ \exists c,d \in \mathbb{R}âˆƒc,dâˆˆRÂ andÂ N \in \mathbb{Z^+ \cup {0}}NâˆˆZ+âˆª0Â s.t.Â g(n) \geq cf(n)g(n)â‰¥cf(n)Â \forall n \geq Nâˆ€nâ‰¥N$

- We say thatÂ g(n)_g_(_n_)Â is order ofÂ f(n)_f_(_n_).
- TheÂ \ThetaÎ˜Â puts an asymptotic bound on a function.
- $0.1n + 10n^2 = O(n^{1000}) / O(n^2)$
	- Big O ë¡œ N ììŠ¹ì´ë‹¤ í•˜ë©°ëŠ” tight upper boundë¥¼ ì´ì•¼ê¸°í•œë‹¤.
- Ex:
	- $37\log n+0.1n=\Theta(n)$
		- $O(n), \Omega(n)$
	- $n^2 + 10n = \Theta(n^2)$
	- $4(logn)^2 +nlogn+100n=\Theta(nlogn)$

> ğŸ’¡ $\Theta(1)<\Theta(log n)<\Theta(n)<\Theta(n log n)<\Theta(n^2)<\Theta(n^3)<\Theta(n^j)<\Theta(n^k)<\Theta(a^n)<\Theta(b^n)<\Theta(n!)$

- forÂ $k>j>3 , b>a>1$
- O(1)Â orÂ _O_(_c_)Â : constant
	- $g(n) = 0.000001 \cdot n$
	- g(n) = 1000000_g_(_n_)=1000000
- Ref. Neapolitan Ex. (pp.42) 19, 24, 26, 28]

# Big O, Omega, and Order

- 

	![10](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/10.png)

- Ref._Ref_.Â [ Neapolitan Chapter 1.]

## Execution Times for Algorithms with the Given Time Complexities

- nì˜ kìŠ¹, ì´ë¥¼ polynomial time (ë‹¤í•­ ì‹œê°„)ì´ë¼ê³  ì¹­í•œë‹¤.
- n log n, logëŠ” ë‹¤í•­ì‹ì´ ì•„ë‹Œë° ì™œ polynomialì´ë¼ê³  í•˜ëŠ”ê°€?
	- upperbound : n ììŠ¹ë³´ë‹¤ ë¹ ë¥´ë‹ˆê¹Œ polynomial timeì— ë“¤ì–´ê°€ê²Œ ë¨.
- ì‹¤ì œì ìœ¼ë¡œ íšŒì‚¬ ê°€ì„œ ì´ ë¬¸ì œë¥¼ í’€ì–´ì£¼ëŠ” SWë¥¼ í•´ì„œ, ì œì¶œí•œë‹¤ê³  í–ˆì„ ë•Œ, nì´ ì»¤ì§ì— ë”°ë¼ ì´ëŸ¬í•œ íš¨ìœ¨ì ì¸ ì•Œê³ ë¦¬ì¦˜ë“¤ì€ ê·¸ í”¼í•´ê°€ ëœí•œë°, ë’¤ëŠ” í”¼í•´ê°€ í˜„ì‹¤ì ìœ¼ë¡œ ë°›ì•„ë“¤ì¼ ìˆ˜ ì—†ì„ ì •ë„ë¡œ ì»¤ì§„ë‹¤. ìš°ë¦¬ê°€ ì´ë¡ ì ìœ¼ë¡œ êµ¬ë³„ì€ ë¬´ì—‡ì´ëƒ í•˜ë©´ì€ polynomial - nonpolynomial alg.ë¥¼ êµ¬ë¶„
	- $n^6$ì€ ì´ë¡ ì ìœ¼ë¡œëŠ” polynomial - ì•ˆ ì¢‹ê¸´ í•˜ì§€ë§Œ
- exponential, factorial algorithmì€ inefficient, polynomial algorithmì€ algorithm
	- í˜„ì‹¤ì ìœ¼ë¡œëŠ” cubicë„ ë¹¡ì…ˆ
- ì•Œê³ ë¦¬ì¦˜ :
	- ì´ë¡ ì ì¸ ì¸¡ë©´ì—ì„œ polynomial time ì— ì“°ì´ëŠ”ê°€
	- í”„ë¡œê·¸ë¨ì„ êµ¬í˜„í•´ì„œ ëŒë¦´ ë•Œ, ë‹¹ì—°íˆ cuvicë³´ë‹¤ëŠ” íš¨ìœ ì ìœ¼ë¡œ ëŒì•„ê°ˆ ê²ƒì´ë‹¤
- í˜„ì‹¤ì ìœ¼ë£¨ nì´ ì‘ì„ ë•Œì—ëŠ” ê·¸ë ‡ê²Œ í° ì§€ì¥ì´ ì—†ì§€ë§Œ, nì´ ì ì°¨ ì»¤ì§ˆ ë•Œ log, linearëŠ” ì˜ ë²„í‹°ëŠ” ë°ì— ë°˜í•´ exp, factorial
	- processorê°€ ì¢‹ì•„ì§„ë‹¤ í•œë“¤ í’€ê³ ì í•˜ëŠ” ë¬¸ì œê°€ ë” ì»¤ì§€ê¸° ë•Œë¬¸ì— ì‹œëŒ€ì  needsë¼ê¸° ë³´ë‹¤ëŠ” í•­ìƒ ìš°ë¦¬ ê³ì˜ needs

	![11](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/11.png)

	- logarithmic, linear, n log n, quadratic, cubic << exp << factorial

![12](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/12.png)


# Worst-Case vs. Average-Case Time Complexity

- complexity : time, space complexity
	- í¸ì˜ìƒ time complexityë¥¼ ë”°ì§
- **Expected value** (from Wikipedia)
	- letÂ X_X_Â be a random variable with a finite number of finite outcomesÂ $x_1, x_2, ..., x_k$Â occuring with probabilitiesÂ $p_1, p_2, ... p_k$Â respectively.
	- the Expectation of X is defined as :
		- $E(X) = \sum_{i=1}^{k }{x_i p_i} = x_1p_1+ x_2 p_2 + ... + x_k p_k$
	- since the sum of all probabilitiesÂ $p_i$Â is 1 (\sum_{i=1}^{k} {p_i}=1âˆ‘_i_=1_k__pi_=1) , the expected value is the weighted sum of theÂ x_i_xi_Â values, with theÂ p_i_pi_Â values being the weights
	- $a_1, a_2, a_3 \rightarrow b_1 , b_2, b_3$
		- input size nì— ëŒ€í•´ì„œ ëª¨ë“  ê°€ëŠ¥í•œ inputë“¤ì˜ ì§‘í•©ì„ S_n
		- ì„ì˜ì˜ input $I$
		- $c(I) $ :
		- $p(I):$
- Worst-case complexity :
	- ëª¨ë“  ê°€ëŠ¥í•œ ì¸í’‹ì¤‘ì— ìµœì•…ìœ¼ë¡œ ê°€ì¥ ë§ì€ ì‹œê°„ì´ ê±¸ë¦¬ëŠ” ê²½ìš°. ê°€ì¥ ì‹œê°„ì´ ë§ì´ ê±¸ë¦¬ëŠ” ê²½ìš°
	- $T_W (n) = max \{ c(I)| I \in S_n \}$
- Average-case complexity
	- ëª¨ë“  inputì— ëŒ€í•´ì„œ ì¼ì–´ë‚  í™•ë¥  ë“±ì— ëŒ€í•´ í‰ê· ì„ ë‚¸ ê²ƒ.
	- $T_A (n) = \sum_{I \in S_n} p(I) c(I)$
- Problem
	- Find the index of a given valueÂ _a_Â in a givven arrayÂ $(a_0, a_1, ...,a _{n-1})$. ifÂ _a_Â doesn't exist in the array returnÂ âˆ’1
- Cost for a linear search algorithm
	- letÂ P_i_Pi_Â be the probability such thatÂ a= a_i_a_=_ai_
	- then the average cost is :

		$g(n) = 1 \cdot P_0 + 2 \cdot P_1 + 3 \cdot P_2 + ...+ n \cdot P_{n-1} + n (1 - \sum_{k=0}^{n-1} P_k)$


		$= \sum_{k=0}^{n-1} (k+1)P_k + n (1 - \sum_{k=0}^{n-1} P_k)=âˆ‘k=0nâˆ’1(k+1)Pk+n(1âˆ’âˆ‘k=0nâˆ’1Pk)$

		- Ex.1.Â $n = 10^9$,Â $P_0 + P_1 + ...+ P_{10^3} = 1$Â soÂ $g(n)=O(1)$
		- Ex.2.Â $n = 10^9$,Â $P_0 + P_1 + ...+ P_{\frac n {100} }= 1$, soÂ g(n) = O(n)_g_(_n_)=_O_(_n_)

> ğŸ’¡ ë°°ìš°ê²Œ ë  ë‚´ìš©, ì¤‘ìš”

- [ì¤‘ìš”] **ì°¸ê³ : Quick sort ì•Œê³ ë¦¬ì¦˜ â†’**
	- Worst-caseÂ : $O(n^2)$
	- Average-CaseÂ : $O(n \log n)$

# Reviews


## Summation

- Sums of powers
	- $\sum_{i=1}^{n} i = \frac {n(n+1)} {2}$
	- $\sum_{i=1}^{n} i^2 = \frac {n(n+1)(2n+1)} {6}$
	- $\sum_{i=1}^{n} i^3 = (\frac {n(n+1)} {2})^2$
	- $\sum_{i=1}^{n} i^4 = \frac {n(n+1)(2n+1)(3n^2+3n-1)} {30}$
	- $\sum_{i=1}^{n} i^s = \frac {(n+1)^{s+1}} {s+1} + \sum_{k=1}^{s} \frac {B_k} {s-k+1} {s \choose k} (n+1)^{s-k+1}$
		- $B_k$Â is theÂ $k^{th}$Â Bernoulli Number.
	- $\sum_{i=1}^{n} i^{-s} = \prod_{p prime} \frac {1} {1 - p^{-s}} = \zeta(s)$
		- $\zeta_k$ is the Riemann zeta function
- Growth rates
	- $\sum_{i=1}^{n} i^c \in \Theta(n^{c+1})$
		- for realÂ cÂ greater thanÂ 1âˆ’1
	- $\sum_{i=1}^{n} \frac 1 i \in \Theta(log n)$
	- $\sum_{i=1}^{n} c^i \in \Theta( n \cdot log(n)^{c+1})$
		- for realÂ c_c_Â greater thanÂ 11
	- $\sum_{i=1}^{n} log(i)^c \in \Theta(n \cdot log(n)^{c})$Â for nonnegative realÂ $c$
	- $
	
	\sum_{i=1}^{n} log(i)^c \cdot i^d \in \Theta(n^{d+1} \cdot log(n)^{c})$Â for nonnegative realÂ $c, d$
	- $\sum_{i=1}^{n} log(i)^c \cdot i^d \cdot b^i \in \Theta(n^{d} \cdot log(n)^{c} \cdot b^n)Â $for nonnegative realÂ $b>1, c, db>1,c,d$
- **Read**Â [_Summation_](http://en.wikipedia.org/wiki/Summation),Â [_Mathematical Series_](http://en.wikipedia.org/wiki/List_of_mathematical_series.)

## Run Time Analysis


What is the worst-case time complexity of each loop?

- ì–´ë””ê°€ dominateí•œê°€ : SWë¥¼ ê°œë°œ í•  ë•Œ ìµœì í™”ë¥¼ í•´ ì£¼ì–´ì•¼ í•¨. programì´ ë„ëŠ” ê²ƒì„ ë³´ë©´ ì–´ë””ê°€ bottleneckì´ ë˜ì–´ ë¹„íš¨ìœ¨ì ì¸ê°€
- (1) Matrix Addition : $O(n^2)$

	```c
	for (i = 0; i < N; i++)
	  for (j = 0; j < N; j++)
	    a[i][j] = b[i][j] + c[i][j];
	```

- (2)$O(n^2)$
	- `x+= i+j`ê°€ ië²ˆ ìˆ˜í–‰ë˜ê³ , $\Sigma_{i=1}^N i = \frac{N(N+1)}{2} = \frac {N^2} 2 + \frac N 2$

	```c
	x = 0;
	for (i = 1; i <= N; i++)
	  for (j = 1; j <= i; j++)
	    x += i + j;
	```

- (3) $O(n^2)$

	```c
	for (i = 1; i <= N; i++)
	        if (i % 2 == 0)
	            a[i] = 1;
	        else
	            a[i] = -1;
	    // N^2
	for (i = 1; i <= N; i++)
	        for (j = 1; j <= N; j++)
	            a[i][j] = i + j;
	    // N^2
	```

- (4) $O(n^3)$
	- $\frac N 2 \cdot N$ . $\frac N 2 N^2$ â†’ $n^3$ì´ dominate

	```c
	for (i = 1; i <= N; i++)
	    {
	        if (i % 2)
	        {
	            for (j = 1; j <= N; j++)
	                a[i][j] = i + j;
	        }
	        else
	        {
	            for (j = 1; j <= N; j++)
	            {
	                a[i][j] = 0;
	                for (k = 1; k <= N; k++)
	                    a[i][j] += k;
	            }
	        }
	    }
	```

- (5)
	- $\Sigma_{i=1}^N \Sigma_{j=1}^i j= O(N^3)$

	```c
	x = 0;
	for (i = 1; i <= N; i++)
	  for (j = 1; j <= i; j++)
		//What if this is i*i?
			for (k = 1; k <= j; k++)
			x += i + j + k;
	```

- (6)$ \rightarrow O(N^4)$
	- $\Sigma_{i=1}^N \Sigma_{j=1}^{i^2} \Sigma_{k=1}^j k= O(N^4)$

	```c
	x = 0;
	for (i = 1; i<=N;i++)
	  for (j = 1; j <= i*i; j++)
	    if (j % i == 0) //jê°€ iì˜ ë°°ìˆ˜ì´ë©´
	      for (k = 1; k <= j; k++)
	        x++;
	```

	- n ì´ ì‘ëƒ, í¬ëƒì— ë”°ë¼ì„œ 10ë§Œì´ëƒ 100ë§Œì´ëƒ í•  ë•Œ ì–´ë–¤ ì†ë„ë¡œ ë‚˜ë¹ ì§ˆ ê²ƒì¸ê°€? ì–¼ë§ˆë‚˜ ì˜ ìœ ì§€ë  ê²ƒì¸ê°€?
	- í•­ìƒ jê°€ 1ë¶€í„° i^2ê¹Œì§€ ë„ëŠ”ë°, j%i ==0 ì¼ ë•Œ ê¹Œì§€ë§Œ ëˆë‹¤ : jê°€ iì˜ ë°°ìˆ˜ì¸ ê²½ìš°
	- jê°€ iì˜ ë°°ìˆ˜ì¼ ë•Œ :
		- $i = 1,2, ... n$
		- $j = 1, i, 2i, ..., i^2$
		- $\Sigma_{i=1}^{N}{(1 + i + ... + i^2)}$
		- 

What is the worst-case time complexity of each loop?

- (1)

	```c
	// n = 2^k for some positive
	    // integer k
	    for (i = 1; i < N; i++)
	    {
	        j = n;
	        while (j >= 1)
	        {
	            // some O(1) computation
	            j = j / 2;
	        }
	    }
	```

- (2)

	```c
	// n = 2^k for some positive
	    // integer k
	    i = n;
	    while (i >= 1)
	    {
	        j = i;
	        while (j <= n)
	        {
	            // some O(1) computation
	            j = 2 * j;
	        }
	        i = i / 2;
	    }
	```

- (3) Could this be faster?

	```c
	//
	    float x[n][n + 1];
	    for (i = 0; i <= n - 2; i++)
	        for (j = i + 1; j <= n - 1; j++)
	            for (k = i; k <= n; k++)
	                x[j][k] = x[j][k] â€“ x[i][k] * x[j][i] / x[i][i];
	```

- (4) Magic square : Could this be faster?

	```c
	// n: odd integer
	    for (i = 0; i < n; i++)
	        for (j = 0; j < n; j++)
	            s[i][j] = 0;
	    s[0][(n - 1) / 2] = 1;
	    j = (n - 1) / 2;
	    for (key = 2; key <= n * n; key++)
	    {
	        k = (i) ? (i - 1) : (n - 1);
	        l = (j) ? (j - 1) : (n - 1);
	        if (s[k][l])
	            i = (i + 1) % n;
	        else
	        {
	            i = k;
	            j = l;
	        }
	        s[i][j] = key;
	    }
	```

- (5)$Â O(\log n)$

	```c
	// compute x^n (n >= 0)
	    m = n;
	    power = 1;
	    z = x;
	    while (m > 0)
	    {
	        while (!(m % 2))
	        {
	            m /= 2;
	            z *= z;
	        }
	        m--;
	        power *= z;
	    }
	```

- time complexity. :Â $c_0 + c_1 n + c_2 n^2 = O(n^2)$

	```c
			x = x + 1;
	    for (i = 1; i <= n; i++)
	        y = y + 2;
	    for (i = n; i >= 1; i--)
	        for (j = n; j >= 1; j--)
	            z = z + 1;
	```

- time complexity. :Â $c( âŒŠ{log_2 n}âŒ‹+1) \cdot n^2 = O(n^2)$

	```c
	c = 0;// n > 0
	for (i = 1; i <= n; i++)
	  for (j = 1; j <= n; j++)
	    for (k = 1; k <= n; k = k*2)
	      c += 2;
	```

	- for k=1;kâ‰¤n;k=k*2
	- floor : 3.7 â†’ 3, ceil : 3.7 â†’ 4
	- $n=15 \rightarrow \lfloor log_2 15 \rfloor = \lfloor 3.*** \rfloor = 3$
	- 1 2 4 8 15
- time complexity. :Â $??= O( \sqrt n)$

	```c
			i = 1;
	    j = 1;
	    m = 0; // n > 0
	    while (j <= n)
	    {
	        i++;
	        j = j + i;
	        m = m + 2;
	    }
	```


# [ALG] 1.4. MSS (1)


> ìµœëŒ€ ë¶€ë¶„ ìˆ˜ì—´ì˜ í•© Maximum Subsequence Sum

- ì–´ë– í•œ ì•Œê³ ë¦¬ì¦˜ì„ ì„¤ê³„í•˜ëŠëƒì— ë”°ë¼ì„œ ì–´ë–»ê²Œ ê²°ê³¼ê°€ ë‹¬ë¼ì§€ëŠ”ì§€.

# Maximum Subsequence Sum (MSS) Problem

- _Ref_.Â **[M. Weiss,**Â **Data Structure and Algorithm Analysis in C (2nd ed.), Pearson, 1997. 2.4.3]**
	- GivenÂ $N$Â (possiblly negative)Â $A_0, A_1, ..., A_{N-1} \in \mathbb{Z}$
	- find the maximum value ofÂ $\sum_{k=i}^{j} {A_k }$Â forÂ $0 \leq i \leq j \leq N-1$
	- for convenience, the max subseuqence sum is 0 if all the integers 're <0
- Example
	- $(-2, 11, -4, 13, -5, -2). â†’ MSS = 20$
	- $(a_1, ..., a_6)$ : ìˆ˜ì—´ì˜ ëª¨ë“  ê°€ëŠ¥í•œ ë¶€ë¶„ìˆ˜ì—´ ì¤‘ $\Sigma_{k=i}^j {A_k}$ ì„ì˜ì˜ iì—ì„œ ì‹œì‘í•´ì„œ jì—ì„œ ëë‚˜ëŠ” ê²ƒë“¤ì„ ë”í–ˆëŠ”ë° ê·¸ëŸ° ê²ƒë“¤ ì¤‘ ì œì¼ í° ê²ƒì„ ì°¾ì•„ë¼.
		- sequence elementë“¤ì€ ì •ìˆ˜ì¼ ë•Œ subsequenceë¥¼ ì°¾ëŠ”ë‹¤.: subsequenceì˜ í•©ì´ ìµœëŒ€ê°€ ë˜ê²Œí•˜ëŠ” ìˆ˜ì—´.
		- ì£¼ì–´ì§„ ìˆ˜ì—´ì˜ ì •ìˆ˜ê°€ ëª¨ë‘ ìŒìˆ˜ì´ë©´ mss=0 ê°„ì£¼
	- length = 0, 1, 2ë¡œ ì‹œì‘í•˜ê±°ë‚˜,,
		- ì•„ë¬´ë¦¬ ë¹¨ë¼ë„ $n^2$ë³´ë‹¤ ë¹ ë¥´ê²ŒëŠ” ëª» ë§Œë“¤ê² ë‹¤ëŠ” ìƒê°ì´ ë“¤ ìˆ˜ ìˆë‹¤.
			- nê°œ data ì¤‘ ê°€ì¥ ì‘ì€ ê²ƒ ë½‘ê¸° : í•œ ë²ˆì”© sequential searchë¥¼ í•´ì•¼ í•˜ë¯€ë¡œ n
			- n^2ê°œì˜ ê²½ìš°ëŠ” n^2ê°€ ë  ê²ƒ ê°™ì€ë°,
			- divide n conquer : $O(N \log N), $ DP : $O(n)$
		- â†’ $n + (n-1) + (n-2) + ... + 2 + 1 = \frac {n(n+1)}{2} = O(n^2)$
	- ì´ ì•ˆì— ëª¨ë“  ì¡´ì¬í•˜ëŠ” subsequence ì¤‘ì— í•©ì„ ê°€ì¥ í¬ê²Œ í•˜ëŠ” subsequenceë¥¼ ì°¾ì•„ë¼.

		![13](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/13.png)

- Maximum Subarray Problem
- Maximum Positive Sum Subarray Problem
- Max. Sum Subsequence versus Max. Subsequence Sum

# Alg of Maximum Subsequence Sum

- ê¸¸ì´Â nì¸ ì •ìˆ˜ì˜ ìˆ˜ì—´Â $a_0, a_1, ..., a_{n-1}$ì´ ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì ¸ ìˆë‹¤.
- ì—¬ê¸°ì„œ ë¶€ë¶„ ìˆ˜ì—´ $[i, j]$ ë¼ëŠ” ê²ƒì€ $Â a_i, a_{i+1}, a_{i+2}..., , a_{j}$ë¥¼ ë§í•œë‹¤.
- aì˜ ìµœëŒ€ê°’ì„ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤.
	- (ì´ë•Œ ì£¼ì–´ì§„ ìˆ˜ì—´ì˜ ì •ìˆ˜ê°€ ëª¨ë‘ ìŒìˆ˜ì´ë©´ ìµœëŒ€ ë¶€ë¶„ ìˆ˜ì—´ì˜ í•©ì€ 0 ì´ë¼ê³  ê°„ì£¼í•œë‹¤)
	- ì˜ˆë¥¼ ë“¤ì–´ ë‹¤ìŒê³¼ ê°™ì€ ìˆ˜ì—´ì´ ì£¼ì–´ì¡Œì„ ë•Œ,Â $+ 31, âˆ’41, +59, +26, âˆ’53, +58, +97, âˆ’93, âˆ’23, +84$ Â ìµœëŒ€ ë¶€ë¶„ ìˆ˜ì—´ì€Â [2,6]ì´ë©° ìˆ˜ì—´ì˜ í•©ì€Â 187Â ì´ ëœë‹¤.

	![14](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/14.png)

- ì´ ë¬¸ì œëŠ” ìµœëŒ€ ë¶€ë¶„ ìˆ˜ì—´ì˜ í•©ì„ êµ¬í•˜ëŠ” ê²ƒì´ì§€ë§Œ, ì•ìœ¼ë¡œ ì†Œê°œí•  ì•Œê³ ë¦¬ì¦˜ì„ ì¡°ê¸ˆë§Œ ìˆ˜ì •í•˜ë©´ ìµœëŒ€ ë¶€ë¶„ ìˆ˜ì—´ë„ ì‰½ê²Œ êµ¬í•  ìˆ˜ ìˆë‹¤.
	- empty string : letter char=0, NULL String
	- substring
	- string
	- length

	> Algorithm1 : ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ ì°¾ê¸° -Â $O(N^3)Â $


	> Algorithm2 : Sumêµ¬í•  ë•Œ ì¤‘ë³µ ì¡°ê¸ˆ í”¼í•˜ê¸° -Â $O(N^2)$Â 

	- simple counting
		- $O(n^2)$ : SS ì—¬ëŸ¬ ê°œê°€ ìˆëŠ”ë° í•œ ë²ˆì”© ëª¨ë‘ ë³´ì.
		- $i$ì—ì„œ ì‹œì‘í•˜ëŠ” ê²ƒë“¤ 1, 2, â€¦ ê°œë¥¼ ëª¨ë‘ ë³´ì : $n^2$ê°œë¥¼ ëª¨ë‘ ë³¸ ê²ƒ.

	![15](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/15.png)


	> Algorithm3 : Divide n Conquer -Â $O(N \log N)$Â 

	- Divide n Conquer
		- ê²½ìš°ë¥¼ ë‚˜ëˆˆë‹¤ : MSS subsequenceê°€ ì¡´ì¬í•˜ëŠ”ë° ì´ë¥¼ ë°˜ìœ¼ë¡œ ì˜ë¼ì„œ ë¶„ëª…íˆ ì–´ë”˜ê°€ ì¡´ì¬í•œë‹¤ â†’ ì™¼ìª½ í˜¹ì€ ì˜¤ë¥¸ìª½, ì•„ë‹ˆë©´ ì–‘ë‹¤ë¦¬ ê±¸ì¹˜ë˜ì§€.
		- ì™¼ìª½ ì¤‘ ì œì¼ í° ê²ƒ ì°¾ê³ , ì˜¤ë¥¸ìª½ ì¡´ì¬ ì¤‘ ì œì¼ í° ê²ƒ ã…ˆì°¾ê³ , ì–‘ë‹¤ë¦¬ ì¤‘ ì œì¼ í° ê²ƒ ì°¾ê³ .
		- ê·¸ì¤‘ì— ì œì¼ í° ê²ƒì„ ì°¾ì•˜ëŠ”ë° O(Nlog N)ê±¸ë¦¬ë”ë¼

	![16](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/16.png)


	> Algorithm4 : Dynamic Programming -Â $O(N)$

	- DP
		- ê°ê°ì˜ iì— ëŒ€í•´ì„œ ië²ˆì§¸ ëë‚˜ëŠ” ì• ë“¤
		- ë¶„ëª…íˆ maximum sumì„ í•´ì£¼ëŠ” ê²ƒì€ í•˜ë‚˜ ì¡´ì¬í•˜ëŠ”ë° ì²« ë²ˆì§¸ ì›ì„œë¡œ ëë‚˜ë˜ì§€, â€¦ ëª‡ ë²ˆì§¸ì¯¤ì— ëë‚  ê²ƒì´ë‹¤. në²ˆì§¸ì—ì„œ ëë‚˜ëŠ” ê²ƒë“¤ ê°ê°ì„ ë³´ìëŠ” ì˜ë¯¸ì´ë‹¤.

	![17](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/17.png)

	- algorithmì„ ë§Œë“¤ ë•Œ, íš¨ìœ¨ì„ ì‹ ê²½ì“°ì§€ ë§ê³  í•˜ë‚˜í•˜ë‚˜ ë”°ì ¸ë³¸ë‹¤. ê³ ë“±í•™êµ ë•Œ ìˆœì—´ê³¼ ì¡°í•©ìœ¼ë¡œ ê²½ìš°ì˜ ìˆ˜ë¥¼ ë”°ì§€ëŠ”ë°, ì „ê³µì—ì„œ ë§¤ìš° ì¤‘ìš”í•œ ìš”ì†Œì´ë‹¤.
		- ë¬¸ì œë¥¼ ì–´ë–»ê²Œ ì ‘ê·¼í•´ í•´ê²°í•¨ì— ë”°ë¼ n^2ê°œê°€ ìˆìŒì—ë„ ë¶ˆêµ¬í•˜ê³  í›¨ì”¬ ë” íš¨ìœ¨ì ìœ¼ë¡œ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆë‹¤.
	- ì´ëŸ° ìˆ˜ì—´ì´ ì£¼ì–´ì¡Œì„ ë•Œ ë¶„ëª… ë‹µì€ ì¡´ì¬í•œë‹¤:
	- alg 1, 2
		- ëª¨ë‘ -ë¼ë©´ ì •ë‹µì€ 0ì´ê³  :
			- -ì„ì„ í™•ì¸í•˜ëŠ” ë¹„ìš©ì€ linear time
		- ì–‘ìˆ˜ê°€ í•˜ë‚˜ë¼ë„ ìˆìœ¼ë©´ ì°¾ì•„ë³´ì•„ì•¼ í•œë‹¤

	0ì—ì„œ ì‹œì‘í•˜ëŠ”ê±° ë‹¤ ë”°ì ¸ë´ì„œ í•©ì´ ì œì¼ í° ê²ƒ ì°¾ê³ , â€”- 1, 2 ë²ˆì§¸ì—ì„œ ì‹œì‘í•˜ëŠ”ê±° ë‹¤ ë”°ì ¸ë´ì„œ í•©ì´ ì œì¼ í° ê²ƒ ì°¾ê³ . n-1 ê¹Œì§€ ì¤‘ ì œì¼ ì‘ì€ ê±° 


# MSS 1 - simple counting

- Strategy
	- Enumerate all possibilities one at a time.
	- No efficiency is considered, resulting in a lot of unnecessary computation!

		```c
		Maxsum = 0 for (i = 0; i < n; i++)
		{
		    for (j = i; j < n; j++)
		    {
		        Thissum = sum(A [i:j])
		            Maxsum = max(Thissum, Maxsum)
		    }
		}
		```

	- ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ í•˜ë‚˜í•˜ë‚˜ ëª¨ë‘ ë”°ì ¸ë³´ëŠ” ë°©ë²•.

		```c
		int MaxSubsequenceSum(const int A[], int N)
		{
		    int ThisSum, MaxSum, i, j, k;
		    // i = ë¦¬ìŠ¤íŠ¸ ì™¼ìª½ ë ì¸ë±ìŠ¤, j = ë¦¬ìŠ¤íŠ¸ ì˜¤ë¥¸ìª½ ë ì¸ë±ìŠ¤,
		    //  ThisSum = ê³ ë ¤ ëŒ€ìƒ ë¶€ë¶„ ë¦¬ìŠ¤íŠ¸ í•©, MaxSum = ë¬¸ì œ ìµœì¢…ê²°ë¡ 
		    MaxSum = 0;
		    for (i = 0; i < N; i++)
		        for (j = i; j < N; j++)
		        {
		            ThisSum = 0;
		            for (k = i; k <= j; k++)
		                ThisSum += A[k];
		            if (ThisSum > MaxSum)
		                MaxSum = ThisSum;
		        }
		    return MaxSum;
		}
		```

	- Is this for-loop OK for you?
	- Time Complexity :Â $O(N^3)$
		- ğ‘–ì™€ ê´€ë ¨ëœ ë°˜ë³µë¬¸ì€ ğ‘›në²ˆ, ğ‘—ì™€ ê´€ë ¨ëœ ë°˜ë³µë¬¸ì€ ìµœëŒ€ ğ‘›ë²ˆ, Thissumì„ êµ¬í•  ë•Œ ìµœëŒ€ ğ‘›ê°œì˜ ìš”ì†Œë¥¼ ê³„ì‚°í•´ì•¼ í•˜ê¸°ì—
		- $\sum_{i=0}^{N-1} \sum_{j=i}^{N-1} \sum_{k=i}^{j} 1 = \frac{N^3 + 3N^2 + 2N}{6}$

			```c
			for (i = 0; i < N; i++)
			```

		- $\sum_{j=i}^{N-1}\ (j-i+1) = \frac{(N-i+1)(N-i)}{2}$

			```c
			// for (i = 0; i < N; i++)
			    for (j = i; j < N; j++)
			   // {
			     //   ThisSum = 0;
			       // for (k = i; k <= j; k++)
			```

		- $\sum_{k=i}^{j} 1 = j-i+1$

			```c
			//for (i = 0; i < N; i++)
			//    for (j = i; j < N; j++)
			//    {
			//        ThisSum = 0;
			        for (k = i; k <= j; k++)
			```

	- 0ë²ˆì§¸ì—ì„œ ì‹œì‘í•´ì„œ Max êµ¬í•œ ê²ƒ,â€¦, në²ˆì§¸ì—ì„œ ì‹œì‘í•˜ì—¬ Max êµ¬í•œ ê²ƒ.
	- í¬ê²Œ ë°”ê¹¥ìª½ì—ì„œ for loopì´ ëŒë©´ì„œ ië²ˆì§¸ë¶€í„° ì‹œì‘í•´ì„œ i í•˜ë‚˜, ë‘ê°œ, ì„¸ê°œ, â€¦ ëª¨ë“  ê²ƒì„ ë‹¤ ë´ì„œ ië²ˆì§¸ì—ì„œ ì‹œì‘í•˜ëŠ” ê²ƒ ì¤‘ ê°€ì¥ í° ê²ƒì„ ì°¾ìœ¼ë ¤ í•œë‹¤.
	- for loopì€ i, i+1, i - i+2, i - n-1â€¦ ê¹Œì§€ ë”í•´ ë´„.

	> ğŸ’¡ [ê°œì„ ì ] ì´ì „ì— ë”í•œê²ƒì—ë‹¤ê°€ í•˜ë‚˜ë§Œ ë” ë”í•˜ë©´ ë˜ì§€ ì•Šì„ê¹Œ


![18](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/18.png)


# MSS 2

- Strategy

	> ğŸ’¡ ì´ì „ ìŠ¤íƒì—ì„œ í•˜ë‚˜ë§Œ ë” ë”í•˜ë©´ ë˜ëŠ” ê²ƒ ì•„ë‹Œê°€?

	- Get rid of the inefficiency in the innermost for-loop. Algorithm 1ë³´ë‹¤ ì¤‘ë³µì„ ì¤„ì´ëŠ” ë°©ë²•
	- for loopê°€ í•˜ë‚˜ ì‚¬ë¼ì§€ê²Œ ë¨.

		```c
		Maxsum = 0 for (i = 0; i < n; i++)
		{
		    for (j = i; j < n; j++)
		    {
		        Thissum = sum(A [i:j])
		            Maxsum = max(Thissum, Maxsum)
		    }
		}
		```

		- Notice thatÂ $\sum_{k=i}^{j } {A_k} = A_j + \sum_{k=i}^{j-1} {A_k}$

		```c
		int MaxSubsequenceSum(const int A[], int N)
		{
		    int ThisSum, MaxSum, i, j;
		    MaxSum = 0;
		    for (i = 0; i < N; i++)
		    {
		        ThisSum = 0;
		        for (j = i; j < N; j++)
		        {
		            ThisSum += A[j];
		            if (ThisSum > MaxSum)
		                MaxSum = ThisSum;
		        }
		    }
		    return MaxSum;
		```

	- time complexity :Â $O(N^3) \rightarrow O(N^2)$

![19](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/19.png)


# MSS  3 : Divide n Conquer


![20](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/20.png)

- Divide and Conquer
	- ê²½ìš°ì˜ ìˆ˜ë¥¼ ë”°ì§ : ì „ë¶€ ë‹¤ ìŒìˆ˜ê°€ ì•„ë‹ˆë¼ë©´ ë¶„ëª…íˆ í•˜ë‚˜ ì¡´ì¬í•œë‹¤.
	- 0ë²ˆ ì›ì†Œë¶€í„° n-1 ì›ì†Œê¹Œì§€ ìˆëŠ”ë° ì´ë¥¼ ë°˜ìœ¼ë¡œ 1/2ë¡œ ëš ìë¥´ê³ ,
		- í™€ìˆ˜ ê°œìˆ˜ë©´ ì •í™•íˆ ë‚˜ëˆ ì§€ì§€ ì•ŠìŒ, ì§ìˆ˜ ê°œìˆ˜ì´ë©´ ì •í™•íˆ ë‘˜ë¡œ ë‚˜ëˆ„ì–´ì§
	- left segmentì— ìˆë˜ì§€ right segmentì— ìˆë˜ì§€ ì–‘ë‹¤ë¦¬ ê±¸ì¹˜ë˜ì§€. ì˜ ì„¸ê°€ì§€ ì¼€ì´ìŠ¤ ì¤‘ ì œì¼ í° ê°’ì„ ì°¾ëŠ”ë‹¤.
	- â†’ ì´ ì „ì²´ì—ì„œ mssë¥¼ ì°¾ê³ ì í•˜ëŠ”ë°, ì¼ë‹¨ ì™¼ìª½í•˜ê³  ì˜¤ë¥¸ìª½ ê°ê°ì—ì„œ MSS ì°¾ê³ 
- ì›ë˜ í”Œê³ ì í•˜ëŠ” ë¬¸ì œì™€ problem sizeë§Œ ë‹¤ë¥´ë‹¤
	- ì „ì²´ subsequenceë¥¼ ë°˜ìœ¼ë¡œ ì˜ë¼ left- right segment ê°ê° ì˜ì—­ì—ì„œì˜ MSSë¥¼  ì°¾ê³ ì í•¨.
	- ê²°êµ­ ê°™ì€ ë¬¸ì œ : problem size ë§Œ 1/2, 1/2ëœ ì¼€ì´ìŠ¤
	- ì „ì²´ ë¬¸ì œ ì‚¬ì´ì¦ˆ 2ì¸ê²ƒì„ 1, 1ë¡œ divideí•˜ì—¬ ê°ê°ì˜ segmentì—ì„œ conquerí•˜ì—¬ ì°¾ëŠ”ë‹¤
	- with - â€˜Recursionâ€™
		- ìê¸° ìì‹ ì„ ë¶€ë¥¸ë‹¤ :
		- í•­ìƒ recursive callì„ í•  ë•ŒëŠ” problem sizeë¥¼ ì‘ê²Œ í•˜ì—¬ ë¶€ë¥¸ë‹¤.
		- ì–‘ë‹¤ë¦¬ ê±¸ì¹˜ëŠ” ê²ƒ ì¤‘ ì œì¼ í° ê²ƒì„ ì°¾ì•„ ë¹„êµ
		- ê° ë™ë„¤ì—ì„œ MSSë¥¼ ì°¾ì•„ ê·¸ ì¤‘ ì œì¼ í° ê²ƒì„ ëŒë¦°ë‹¤.
- Why is Log N
	- [ì‚¬ì§„]
	- Binary Treeì—ì„œ ê° depthë³„ë¡œ $1 , 2, 4, 8, ...$
	- $O (N \log N)$
- Strategy
	- Use the **Divide-and-Conquer** strategy.
		- ì› ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆ  í’€ê³ , ê·¸ ê²°ê³¼ë¥¼ í•©ì³ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
	- The maximum subsequence sum can be in one of three places.
	- êµì¬ì— íƒ‘ì¬ë˜ì–´ ìˆì§€ë§Œ ê·¸ë ‡ê²Œ ì¢‹ì€ ì½”ë“œê°€ ì•„ë‹Œë“¯ í•˜ë‹¤ !
	- leaf node 1ê°œê¹Œì§€ ë‚´ë ¤ì™”ì„ ê²½ìš° ì–‘ìˆ˜ì´ë©´ ê·¸ëŒ€ë¡œ returní•˜ê³  ìŒìˆ˜ì´ë©´ 0
	- Divide and Conquer
		- centerë¥¼ ì°¾ì•„ ì¤‘ì•™ ì§€ì  : ë˜‘ê°™ì€ ë¬¸ì œ [index left-right] ë¥¼ í’€ì§€ë§Œ [left-center], [center-right]ë¡œ ì›ë˜ í’€ê³ ì í•˜ëŠ” ë¬¸ì œë¥¼ divideí•´ì„œ í‘¼ë‹¤.
		- recursionì˜ ë¬˜ë¯¸ : ë§‰ì•„ì£¼ëŠ” ë¶€ë¶„ (else return 0)ì´ ìˆì–´ì•¼ top-downìœ¼ë¡œ ë‚´ë ¤ê°ˆ ìˆ˜ ìˆëŠ” divide and conquer

		```c
		int MaxSubSum(const int A[], int Left, int Right)
		{
		    int MaxLeftSum, MaxRightSum;
		    int MaxLeftBorderSum, MaxRightBorderSum;
		    int LeftBorderSum, RightBorderSum;
		    int Center, i;
		    //ì¢…ë£Œì¡°ê±´if (Left == Right){
		    if (A[Left] > 0)
		        return A[Left];
		    else
		        return 0;
		}
		// divide n conquer
		Center = (Left + Right) / 2;
		//ì™¼ìª½, ì˜¤ë¥¸ìª½, ì¤‘ê°„
		MaxLeftSum = MaxSubSum(A, Left, Center);
		MaxRightSum = MaxSubSum(A, Center + 1, Right);
		
		MaxLeftBorderSum = 0;
		LeftBorderSum = 0;
		// 1. left ending ëìœ¼ë¡œ í•˜ëŠ” mss
		for (i = Center; i >= Left; i--)
		{
		    LeftBorderSum += A[i];
		    if (LeftBorderSum > MaxLeftBorderSum)
		        MaxLeftBorderSum = LeftBorderSum;
		}
		MaxRightBorderSum = 0;
		RightBorderSum = 0;
		
		// 2. right ending ì‹œì‘ìœ¼ë¡œ í•˜ëŠ” mss
		for (i = Center; i <= Right; i++)
		{
		    RightBorderSum += A[i];
		    if (RightBorderSum > MaxRightBorderSum)
		        MaxRightBorderSum = RightBorderSum;
		}
		return Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);
		// MaxLeftSum - left segmentì˜ sum
		// MaxRighttSum - right segmentì˜ sum
		// MaxLeftBorderSum - ê°€ìš´ë°ì—ì„œ leftë¡œ ê°€ëŠ” ê²ƒë“¤ ì¤‘ ìµœëŒ€
		}
		int MaxSubsequenceSum(const int A[], int N)
		{
		    return MaxSubSum(A, 0, N - 1);
		}
		```

		- // ìŒìˆ˜ê°€ ë˜ëŠ” ê²½ìš°ì´ë”ë¼ë„ ì–‘ë‹¤ë¦¬ê°€ ê±¸ì¹  ìˆ˜ ìˆë„ë¡ ì„¤ê³„í•  ê²ƒ
			- 

		![21](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/21.png)


		```c
		int MaxSubSum(const int A[], int Left, int Right)
		{
		    int MaxLeftSum, MaxRightSum;
		    int MaxLeftBorderSum, MaxRightBorderSum;
		    int LeftBorderSum, RightBorderSum;
		    int Center, i;
		    //ì¢…ë£Œì¡°ê±´if (Left == Right){
		    if (A[Left] > 0)
		        return A[Left];
		    else
		        return 0;
		}
		// divide n conquer
		Center = (Left + Right) / 2;
		//ì™¼ìª½, ì˜¤ë¥¸ìª½, ì¤‘ê°„
		MaxLeftSum = MaxSubSum(A, Left, Center);
		MaxRightSum = MaxSubSum(A, Center + 1, Right);
		
		// ìŒìˆ˜ê°€ ë˜ëŠ” ê²½ìš°ì´ë”ë¼ë„ ì–‘ë‹¤ë¦¬ê°€ ê±¸ì¹  ìˆ˜ ìˆë„ë¡ ì„¤ê³„í•  ê²ƒ
		
		MaxLeftBorderSum = A[i];
		LeftBorderSum = 0;
		// 1. left ending ëìœ¼ë¡œ í•˜ëŠ” mss
		for (i = Center; i >= Left; i--)
		{
		    LeftBorderSum += A[i];
		    if (LeftBorderSum > MaxLeftBorderSum)
		        MaxLeftBorderSum = LeftBorderSum;
		}
		
		MaxRightBorderSum = 0;
		RightBorderSum = 0;
		
		// 2. right ending ì‹œì‘ìœ¼ë¡œ í•˜ëŠ” mss
		for (i = Center; i <= Right; i++)
		{
		    RightBorderSum += A[i];
		    if (RightBorderSum > MaxRightBorderSum)
		        MaxRightBorderSum = RightBorderSum;
		}
		return Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);
		// MaxLeftSum - left segmentì˜ sum
		// MaxRighttSum - right segmentì˜ sum
		// MaxLeftBorderSum - ê°€ìš´ë°ì—ì„œ leftë¡œ ê°€ëŠ” ê²ƒë“¤ ì¤‘ ìµœëŒ€
		}
		int MaxSubsequenceSum(const int A[], int N)
		{
		    return MaxSubSum(A, 0, N - 1);
		}
		```

- cost :Â $T(n) = 2T(\frac n 2) + cn$,Â $T(1) = d$
- whyÂ O(N log N)_O_(_NlogN_)Â ?
	- $T(n) = 2T(\frac n 2) + cn$
	- $T(1) = d$

		$= 2 [ 2T(\frac n {2^2}) + c \frac n 2 ] + cn$


		$= 2^2 T [ \frac n {2^2}] + 2cn$


		$= 2^3 T [ \frac n {2^3}] + 3cn =...$


		$= 2^i T [ \frac n {2^i}] + icn$


		$= 2^{\log_2 n} T(1) + \log_2 n \cdot cn$


		$=nT(1) + \log_2 n \cdot cn$


		$= O(n) + O(n \log_2 n) = O(n \log_2 n)$


# MSS  4; Kadaneâ€™s algorithm

- ië²ˆì§¸ ì›ì†Œë¡œ ëë‚˜ëŠ” ê°€ì¥ í•©ì´ í° subsequenceê°€ ì–˜ë¼ë©´, ë‹¤ë¥¸ ë‚˜ë¨¸ì§€ë¥¼ ë¶„ë¦¬í–ˆì„ ë•Œ i-1ë¡œ ëë‚˜ëŠ” subsequenceì´ë‹¤.

	![22](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/22.png)

	- ì•„ë‹ˆë‹¤ â†’ ëª¨ìˆœ ì¦ëª… : ê³ ë“±í•™êµ proof by contradiction ê·€ë¥˜ë²•ìœ¼ë¡œ
	- iì›ì†Œë¡œ ëë‚˜ëŠ” í•©ì´ ì œì¼ í° subsequenceëŠ” ì–˜ì¸ë°, í•©ì´ ì œì¼ í° subsequenceê°€ ë˜ì–´ì•¼ í•œë‹¤.
	- í•©ì´ ì œì¼ í° ë¶€ë¶„ì„ ì°¾ëŠ”ë°, ë‚˜ë³´ë‹¤ í•˜ë‚˜ ì•ì•  ìˆëŠ” i-1ê¹Œì§€ì˜ sequenceë¡œ ë°”ë€ë‹¤.
		- recursionì´ë‘ ë¹„ìŠ· : ê°™ì€ ë¬¸ì œë£° í‘¸ëŠ”ë° ë¬¸ì œ í¬ê¸°ê°€ ë‹¬ë¼ì§. ì´ë¥¼ ì–´ë–¤ í˜•ì‹ìœ¼ë¡œ í•´ê²°í•˜ëŠëƒì— ë”°ë¼ì„œ ë‹¬ë¼ì§€ê²Œ ë¨.
	- ië²ˆì§¸ ëë‚˜ëŠ” subsequenceì¤‘ì— ì—¬ëŸ¬ê°€ì§€ ìˆì„ ìˆ˜ ìˆëŠ”ë°, ê·¸ ì¤‘ ê°€ì¥ í•©ì´ í° ê²ƒì„ Bië¼ê³  í•  ë•Œ
		- $B[i]$ : the sum of the maximum subsequence that ends at index $i$
		- $B[i] = \max \{ B[i-1] + A[i], 0\}$
- Strategy
	- Use the Dynamic Programming strategy.
	- subsequence sum<0ì¸ ê²½ìš°, ë…¼ë¦¬ì ìœ¼ë¡œ ìµœëŒ€ê°’ì´ ë  ìˆ˜ ì—†ìŒì— ì°©ì•ˆí•œ ì „ëµ
	- ë§Œì•½ì— sumì´ ìŒìˆ˜ë¼ë„ ë¬´ë°©í•˜ê³  1ê°œ ì´ìƒì˜ ì›ì†Œë¡œ êµ¬ì„±ëœ Subsequence (subarray)ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œë¼ë©´?

		```c
		int MaxSubsequenceSum(const int A[], int N){
		    int ThisSum, MaxSum, i;
		
		    ThisSum = 0; // jë²ˆì§¸ ì›ì†Œë¥´ ëë‚˜ëŠ” ê²ƒ ì¤‘ í•©ì´ ì œì¼ í° ê²ƒ
				MaxSum = 0; // ì§€ê¸ˆê¹Œì§€ì˜ ì›ì†Œë¥´ ëë‚˜ëŠ” ê²ƒ ì¤‘ í•©ì´ ì œì¼ í° ê²ƒ
		    for(i = 0; i < N; i++){
		        ThisSum += A[i];
		        if(ThisSum > MaxSum)
		            MaxSum = ThisSum;
		        else if(ThisSum < 0)
		            ThisSum = 0;
					// if (ThisSum<0) ThisSum=0; 
					// else if (ThisSum>MaxSum) MaxSum = ThisSum;
		    }
		    return MaxSum;
		}
		```

	- thissum : j ë²ˆì§¸ ëŒ ë•Œ j-1ë²ˆì§¸ ì›ì†Œë¡œ ëë‚˜ëŠ” ê²ƒ ì¤‘ ì œì¼ í•©ì´ í° ê²ƒ.
		- `ThisSum += A[j]`
	- ThisSum â†’ 0, jë²ˆì§¸ ì›ì†Œë¡œ ëë‚˜ëŠ” ê²ƒ ì¤‘ ê°€ì¥ í° ê±°ë³´ë‹¤ í¬ë©´ ë°”ê¿”ì¹˜ê¸°í•˜ê³ ..
	- ìµœì†Œí•œ ëª¨ë“  ì›ì†Œë¥¼ í•œ ë²ˆì”©ì€ ë´ì•¼ í•˜ê¸° ë•Œë¬¸ì— linearë³´ë‹¤ ë” ë¹ ë¥¸ algëŠ” ì—†ë‹¤.
	- Time Complexity :Â $O(n)$
		- for i, iteration n times, and $Â O(1$)Â for 1 calculation
	- C Implementation
		- Maximum sum rectangle in a 2D matrix (DP-27) by GeeksforGeeks

			```c
			int kadane(int *arr, int *start, int *finish, int n)
			{
			    int sum = 0, maxSum = INT_MIN;
			
			    *finish = -1;
			    int local_start = 0;
			    for (int i = 0; i < n; ++i)
			    {
			        sum += arr[i];
			        if (sum < 0)
			        {
			            sum = 0;
			            local_start = i + 1;
			        }
			        else if (sum > maxSum)
			        {
			            maxSum = sum;
			            *start = local_start;
			            *finish = i;
			        }
			    }
			    if (*finish != -1)
			        return maxSum;
			// at least one non-negative number.
			
			// When all numbers in the array are negative
			    maxSum = arr[0];
			    *start = *finish = 0;
			    for (int i = 1; i < n; i++)
			    {
			        if (arr[i] > maxSum)
			        {
			            maxSum = arr[i];
			            *start = *finish = i;
			        }
			    }
			// Empty subsequenceë¥¼ í—ˆìš©í•˜ë©´ 0ì„ ë¦¬í„´ (ì›ë˜ ë¬¸ì œ)
			// Empty subsequenceë¥¼ í—ˆìš©í•˜ì§€ ì•Šìœ¼ë©´ ìŒìˆ˜ ì¤‘ ê°€ì¥ í° ì›ì†Œë¥¼ ë¦¬í„´
					return maxSum;
			}
			
			
			
			```


### So, why do we bother with the time complexity?


# [ALG] 1.5. Maximum Sum Subrectangle in 2D Array (1)


# Maximum Sum Subrectangle in 2D Array


= max sum submatrix


2ì°¨ì› arrayê°€ ìˆì„ ë•Œ í•©ì„ ì œì¼ ìµœëŒ€ë¡œ ë§Œë“¤ê²Œ í•˜ëŠ” subrectangleì„ ì°¾ì•„ë¼.

- empty subrectangle í—ˆìš©
	- ëª¨ë‘ ìŒìˆ˜ë©´ 0
- empty subrectangle ë¹„í—ˆìš©
	- ëª¨ë‘ ìŒìˆ˜ë¼ë©´ ì ˆëŒ“ê°’ì´ ì œì¼ ì‘ì€ ê²ƒ ì„ íƒ
- í–‰ì´ mê°œ, ì—´ì´ nê°œ :
	- nììŠ¹ê°œê°€ ì¡´ì¬í•œë‹¤ê³  í–‡ëŠ”ë°, orderë¡œ subrectangleì´ ëª‡ ê°œ ì¡´ì¬í•  ê²ƒì¸ê°€?
	- 
- Problem
	- Given an mxn array of integers, find a subrectangle with the largest sum. (In this problem, we assume that a subrectangle isÂ **any contiguous sub-array of size 1x1 or greater**Â located within the whole array.)
- Note
	- What is the input size of this problem?
		- $(m, n)$
		- If $m = nâ†’n$
		- problem sizeë¥¼ (n,n) í• ìˆ˜ë„ ìˆê³ 
	- How many subrectangles are there in an mxn array?
	- For the case of $m = n$,
		- Design anÂ $O(n^6)$Â algorithm.
		- Design anÂ $O(n^5)$Â algorithm.
		- Design anÂ $O(n^4)$Â algorithm.
		- Design anÂ _O_(_n_3)Â algorithm.

			O(n^3)

- ê°ê°ì˜ $(i,j,k,l)$ì— ì˜í•´ í•˜ë‚˜ê°€ ì •ì˜ :
- How many subrectangles are there in an mxn array?
	- [1D case] for anÂ m * n_m_âˆ—_n_Â rectangle,

		$\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} \sum_{k=0}^{m-1} \sum_{l=k}^{m-1} 1$


		$= (\sum_{k=0}^{m-1} \sum_{l=k}^{m-1} 1)(\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} 1)$


		$= { \sum_{k=0}^{m-1}(m-k)}{\sum_{i=0}^{n-1}{(n-i)}}$


		$= \frac {m(m+1)} {2} \frac {n(n+1)} {2} = O(m^2 n^2) = O(n^4)$Â ifÂ $m=n$


## A NaiÌˆve Approach

- For each subrectangle, find its sum.
- [ê°€ì •]Â $n=m$

	$\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} \sum_{k=0}^{m-1} \sum_{l=k}^{m-1} (j-i+1)(l-k+1) = \sum_{i=0}^{n-1} \sum_{j=i}^{n-1} {(j-i+1)} \sum_{k=0}^{m-1} \sum_{l=k}^{m-1} {(l-k+1)}$


	letÂ $A =\sum_{i=0}^{n-1} \sum_{j=i}^{n-1} {(j-i+1)}$


	$A = 1*n + 2*(n-1) +3(n-2) + ... + n*1A=1âˆ—n+2âˆ—(nâˆ’1)+3(nâˆ’2)+...+nâˆ—1 = \sum_{i=1}^{n} {i(n-i+1)} = n \sum_{i=1}^n i - \sum_{i=1}^n i^2 + \sum_{i=1}^n i = \frac{1}{6} n^3$

	- soÂ $O(\frac{1}{36} n^6 )$
undefined- Time Complexity :Â $O(n^6)$
- inefficient algorithm

## MSS : Summed Area Table

- memory ìì²´ë„ resourceì´ê¸° ë•Œë¬¸ì— í•­ìƒ ë§ì´ ì“°ëŠ” ê²ƒì´ ì¢‹ì€ ê±´ ì•„ë‹ˆì§€ë§Œ, summed area tableì´ë¼ëŠ” memoryë¥¼ í•˜ë‚˜ ì¨ì„œ ë¬¸ì œë¥¼ í’€ê²Œ ëœë‹¤.
- Table construction:Â $O(n^2)$
	- ê° ì›ì†ŒëŠ” ëŒ€ì‘ë˜ëŠ” ì˜ì—­ì˜ í•©ì´ ê° ëŒ€ì‘ë˜ëŠ” ìœ„ì¹˜ì— ì§€ì •í•œë‹¤ : ìˆœì„œëŒ€ë¡œ ì­‰ ì›ì†Œë“¤ì„ í›‘ìœ¼ë©° ê³„ì‚°í•œë‹¤. ì´ë¥¼ ê³„ì‚°í•˜ë©´ ë‚´ê°€ í›‘ì–´ì•¼ í•˜ëŠ” ì›ì†Œì˜ ê°œìˆ˜ê°€ n^2ë§Œí¼ ìˆë‹¤. ê°ê°ì˜ ì›ì†ŒëŠ” ìƒìˆ˜ ì‹œê°„ì— ê³„ì‚°ë˜ì–´ì•¼ í•œë‹¤.
	- n^2ì— ëŒ€í•´ì„œ ê³„ì‚°í•˜ë ¤ê³  í•˜ëŠ”ë°, ê°ê°ì„ ìƒìˆ˜ ì‹œê°„ ì•ˆì— ê³„ì‚°í•˜ì—¬ì•¼ í•œë‹¤.
	- 
- Sum comparisons:$O(n^4)$
- Time Complexity :Â $O(n^4)$

	![23](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/23.png)

	- preprocessë¥¼ í†µí•´ tableì˜ ë‚´ìš©ì„ ì±„ìš¸ ê²ƒì´ë‹¤.
	- $(i,j,k,l)$ì— í•´ë‹¹í•˜ëŠ” ê²ƒì´ $n^4$ê°œë§Œí¼ ë‚˜ì˜¤ëŠ”ë°, ê·¸ ì˜ì—­ì— ëŒ€í•œ í•©ì„ ê³„ì‚°í•´ì„œ ì‚¬ê°í˜•ì˜ í•© ì¤‘ ì œì¼ í° ê²ƒì„ ì„ íƒí•˜ë©´ ë¨.
	- $S(i,j,k,l) = T(l,j) - T(k-1, j) + T(k, j-1) + T (k-1. i-1)$
		- constant time : ê° ì‚¬ê°í˜•ì— ëŒ€í•œ ê³„ì‚°
		- ì‚´í´ë´ì•¼ í•  ê²ƒë“¤ì€ $n^4$ê°œ ì¡´ì¬í•˜ë‹ˆê¹Œ.
- ë¬¸ì œ : ì§€ê¸ˆê¹Œì§€ëŠ” time complexityë¥¼ ë”°ì¡Œì§€ë§Œ ë¬¸ì œëŠ” space complexity
	- input data : @n^2 ë§Œí¼ì˜ ìë¦¬ë¥¼ ì°¨ì§€í•¨.
		- â†’ ëª¨ë°”ì¼ SWë¥¼ ê°œë°œí•œë‹¤ : input data ë§ê³ ë„ ì„±ëŠ¥ì´ ë‚®ê±°ë‚˜ memory size ì‘ê±°ë‚˜ access ëŠë¦° cpuì— ëŒ€í•´ì„œëŠ” ì•ˆ ì¢‹ì„ìˆ˜ ìˆë‹¤. ì‹œìŠ¤í…œ ë¶€ë‹´ì´ ë˜ëŠ” ìƒí™© ë°œìƒ ê°€ëŠ¥
	- time complexity : nì¸ ë¬¸ì œë¥¼ í‘¸ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„
	- space complexity : ë¬¸ì œ í‘¸ëŠ”ë° ê±¸ë¦¬ëŠ” ë©”ëª¨ë¦¬
		- ë¬¸ì œ ì‚¬ì´ì¦ˆ nì— ëŒ€í•´ì„œ $n^4$
	- 

### Maximum Sum Subrectangle: Kadane Algo.-Based


> ğŸ’¡ n^3ì— í•´ë³´ì

- ë¶„ëª…íˆ MSSì¸ rectangleì´ ì¡´ì¬í•˜ëŠ”ë°, iì—ì„œ ì‹œì‘í•´ì„œ jë¡œ ëë‚¨ : ê·¸ëŸ¬ë©´ ì´ì œ ì–´ë–¤ ì‹ìœ¼ë¡œ ë¬¸ì œë¥¼ ë°”ë¼ë³¼ ê²ƒì´ëƒ : $0 \leq i \leq j \leq n-1$ì´ ê°€ëŠ¥í•œ pair
	- ië²ˆì§¸ ì—´ì—ì„œ jë²ˆì§¸ë¡œ ëë‚˜ëŠ” ëª¨ë“  ê°€ëŠ¥í•œ rectangleì„ ì‚´í´ë³´ì.
	- ê°€ëŠ¥í•œ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” i,j â†’ n^2ë§Œí¼ ì¡´ì¬í•¨.
	- ëª¨ë“  ê°€ëŠ¥í•œ i, jì— ëŒ€í•´ì„œ ií–‰ì—ì„œ ì‹œì‘í•˜ê³  jì—´ì—ì„œ ëë‚˜ëŠ” mssë¥¼ ì°¾ì•„ë³´ì.
	- columnì´ i, jë²ˆì§¸ì— ëë‚˜ëŠ” : í•©ì´ ì œì¼ í° ê²ƒì„ ì°¾ì. ë¼ê³  ì ‘ê·¼
	- ë§Œì•½
		- temp arrayë¥¼ ë§Œë“¤ì–´ì„œ ì„ì˜ì˜ ì£¼ì–´ì§„ i, jì— ëŒ€í•´ì„œ ì²« ë²ˆì¬ ì›ì†ŒëŠ” 1 í–‰, 2ë²ˆì§¸ ì›ì†ŒëŠ” 2í–‰, â€¦ ì„ ëª¨ë‘ ì €ì¥í•´ ë†“ì€ ê°’ì„ ì €ì¥í•´ ë‘ì—ˆë‹¤ê³  í•˜ì.
		- ì£¼ì–´ì§„ i, jì— ëŒ€í•´ì„œ í–‰ ì—´ì´ iì—ì„œ ì‹œì‘í•´ì„œ jë¡œ ëë‚˜ëŠ” subrectangle ì¤‘ ì œì¼ í° ê²ƒì€ ì–´ë–»ê²Œ ì°¾ì„ ìˆ˜ ìˆì„ê¹Œ.
		- 1ì°¨ì› sequenceì—ì„œ í•©ì„ ì œì¼ í¬ê²Œ í•˜ëŠ” mssë¥¼ ì°¾ìœ¼ë©´ ëœë‹¤.

	> ğŸ’¡ ëª¨ë“  ê°€ëŠ¥í•œ (i,j) pairì— ëŒ€í•´ì„œ ë³¼ ê²ƒì´ë‹¤.  
	> ë°”ê¹¥ì—ì„œ for loopì´ ëŒ ë•Œ ì €ë§Œí¼ ì¡´ì¬í•œë‹¤.  
	> ê° í–‰ì— ìˆëŠ” ê²ƒë“¤ì„ ë‹¤ ë”í•´ë‘ë©´ (temp) â†’ iì—´ì—ì„œ ì‹œì‘í•´ì„œ jë¡œ ëë‚˜ëŠ” ê°€ëŠ¥í•œ rectangleì„ ë§Œë“ ë‹¤. í•©ì´ ì œì¼ í° ê²ƒì€ tempê°€ ìˆê¸° ë•Œë¬¸ì—, linear timeì— í•©ì´ ì œì¼ í° subsequenceë¥¼ ì°¾ìœ¼ë©´ ë°”ë¡œ kí–‰ë¶€í„° lí–‰ê¹Œì§€ ì •ì˜ë˜ëŠ” ì‚¬ê°í˜•ì´ Maximum sumì´ ë˜ë”ë¼.

	- ë‹¤ì‹œ ì´ì–‘ê¸°í•˜ì§€ë§Œ, ì¡°ê±´ ë§Œì¡±í•˜ëŠ” ìŒì´ i,jê°œ ì¡´ì¬í•˜ë‹ˆê¹Œ linear timeì— ê³„ì‚°í•  ìˆ˜ ìˆìœ¼ë©´
	- ê°ê°ì„ nì— ëŒ€í•´ì„œ ê³„ì‚°í•˜ë©´ $n^3$ì´ ë‚˜ì˜¨ë‹¤.
- Idea
	- ref.Â [geeksforgeeks](https://www.geeksforgeeks.org/maximum-sum-rectangle-in-a-2d-matrix-dp-27/)
	- MSS(2D)ì˜ í•´ë‹¹ ì—´ì€ ì–´ë””ì´ê±´ iì—ì„œ jê¹Œì§€ ì„.
	- ê°€ëŠ¥í•œ ëª¨ë“  (i, j) ì¡°í•©ì— ëŒ€í•˜ì—¬ MSS(1D)ë¥¼ Kadane ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ì°¾ìŒ.
	- ê·¸ë ‡ê²Œ í•˜ê¸° ìœ„í•˜ì—¬, ...

		![24](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/24.png)

- ì–´ë–¤ ì‹ìœ¼ë¡œ êµ¬í˜„í• ì§€ ë³´ì—¬ì•¼ êµ¬í˜„í•  ê²ƒì¸ë° ìê¾¸ ê²½í—˜ì„ í†µí•´ì„œ ëª¸ì— ë°°ë©´ êµ¬êµ¬ë‹¨ ì™¸ìš°ë“¯ì´ ê°„ë‹¤.
- C Implementation
	- left, right : $n^2$ë§Œí¼ ëˆë‹¤

		| 1  | 2  | -1 | -4 | -20 |
		| -- | -- | -- | -- | --- |
		| -8 | -3 | 4  | 2  | 1   |
		| 3  | 8  | 10 | 1  | 3   |
		| -4 | -1 | 1  | 7  | -6  |

undefined
	```c
	// Program to find maximum sum subarray
	// in a given 2D array
	#include <stdio.h>
	#include <iostream>
	#include <string.h>
	using namespace std;
	#define INT_MAX 2147483647
	#define INT_MIN 2147483648
	#define ROW 4
	#define COL 5
	
	// Implementation of Kadane's algorithm for
	// 1D array. The function returns the maximum
	// sum and stores starting and ending indexes
	// of the maximum sum subarray at addresses
	// pointed by start and finish pointers
	// respectively.
	int kadane(int *arr, int *start, int *finish, int n)
	{
	    // initialize sum, maxSum and
	    int sum = 0, maxSum = INT_MIN, i;
	
	    // Just some initial value to check
	    // for all negative values case
	    *finish = -1;
	
	    // local variableint
	    local_start = 0;
	
	    for (i = 0; i < n; ++i)
	    {
	        sum += arr[i];
	        if (sum < 0)
	        {
	            sum = 0;
	            local_start = i + 1;
	        }
	        else if (sum > maxSum)
	        {
	            maxSum = sum;
	            *start = local_start;
	            *finish = i;
	        }
	    }
	
	    // There is at-least one
	    // non-negative number
	    if (*finish != -1)
	        return maxSum;
	
	    // Special Case: When all numbers
	    // in arr[] are negative
	    maxSum = arr[0];
	    *start = *finish = 0;
	
	    // Find the maximum element in array
	    for (i = 1; i < n; i++)
	    {
	        if (arr[i] > maxSum)
	        {
	            maxSum = arr[i];
	            *start = *finish = i;
	        }
	    }
	    return maxSum;
	}
	
	// The main function that finds
	// maximum sum rectangle in M[][]
	void findMaxSum(int M[][COL])
	{
	    // Variables to store the final output
	    int maxSum = INT_MIN,
	        finalLeft,
	        finalRight,
	        finalTop,
	        finalBottom;
	
	    int left, right, i;
	    int temp[ROW], sum, start, finish;
	
	    // Set the left column
	    for (left = 0; left < COL; ++left)
	    {
	        // Initialize all elements of temp as 0
	        memset(temp, 0, sizeof(temp));
	
	        // Set the right column for the left
	        // column set by outer loop
	        for (right = left; right < COL; ++right)
	        {
	
	            // Calculate sum between current left
	            // and right for every row 'i'
	            for (i = 0; i < ROW; ++i)
	                temp[i] += M[i][right];
	
	            // Find the maximum sum subarray in temp[].
	            // The kadane() function also sets values
	            // of start and finish. So 'sum' is sum of
	            // rectangle between (start, left) and
	            // (finish, right) which is the maximum sum
	            // with boundary columns strictly as left
	            // and right.
	            sum = kadane(temp, &start, &finish, ROW);
	
	            // Compare sum with maximum sum so far.
	            // If sum is more, then update maxSum and// other output values
	            if (sum > maxSum)
	            {
	                maxSum = sum;
	                finalLeft = left;
	                finalRight = right;
	                finalTop = start;
	                finalBottom = finish;
	            }
	        }
	    }
	
	    // Print final values
	    cout << "(Top, Left) ("
	         << finalTop << ", "
	         << finalLeft
	         << ")" << endl;
	    cout << "(Bottom, Right) ("
	         << finalBottom << ", "
	         << finalRight << ")" << endl;
	    cout << "Max sum is: " << maxSum << endl;
	}
	
	// Driver Codeint
	main()
	{
	    int M[ROW][COL];
	
	    // Function call
	    findMaxSum(M);
	
	    return 0;
	}
	```

- ê²°ê³¼ëŠ” ì•„ë˜ì™€ ê°™ë‹¤.

	```c
	(Top, Left) (1, 1)
	(Bottom, Right) (3, 3)
	Max sum is: 29
	```


## Mathematical Induction & Proof of Correctness

- Proof by Induction

	![25](/assets/img/2022-09-02-[ALG]-1.-Introduction.md/25.png)

- Proof of Correctness : MSS (1D)

	```c
	int ThisSum = MaxSum = 0;
	
	for (j = 0; j < N; j++)
	{
	    ThisSum += A[j];
	
	    if (ThisSum > MaxSum)
	        MaxSum = ThisSum;
	    else if (ThisSum < 0)
	        ThisSum = 0;
	}
	
	return MaxSum;
	```

	- P(j)Â : for-loopê°€ jë²ˆ ìˆ˜í–‰í•œ ì§í›„ì— ThisSum ë³€ìˆ˜ëŠ” ( )ê°’ì„, MaxSum ë³€ìˆ˜ëŠ” ( )ê°’ì„ ê°€ì§€ê³  ìˆë‹¤.

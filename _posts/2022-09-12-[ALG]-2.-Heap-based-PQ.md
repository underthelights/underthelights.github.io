---
layout: post
date: 2022-09-12
title: "[ALG] 2. Heap-based PQ"
tags: [Algorithm, ]
categories: [Notes, ]
use_math: true
---


Heap-based Priority Queue, Heap Sort


# A Variety of Priority Queue Implementations

- Heapì´ë¼ëŠ” ê°œë… - ë§¤ìš° ì „ê³µì—ì„œ ì¤‘ìš”í•œ ìë£Œêµ¬ì¡°. ì‹¤ì œë¡œ ì»´í“¨í„° systemì—ì„œ ë©”ëª¨ë¦¬ë¥´ ë‹¤ë£¨ëŠ” ë° ì“°ì´ëŠ” í•µì‹¬ì ì¸ êµ¬ì¡°ì¤‘ í•˜ë‚˜
- Insert, delete : ì›ì†Œë¥¼ ì§‘ì–´ë„£ê³  ë¹¼ê³  - queue
- Push, Pop : ë°ì´í„°ë¥¼ ì§‘ì–´ë„£ì—ˆë‹¤ê°€ ë¹¼ê³  - stack
- dataë¥¼ ë„£ì—ˆë‹¤ê°€ ëºë‹¤ê°€ ì´ëŸ°ê²ƒì„ ë°˜ë³µí•˜ëŠ” ê²ƒë“¤. êµ¬í˜„ì´ ì í•©í•œ stack
	- â†’ queue, stackì€ êµ‰ì¥íˆ íŠ¹ì • í˜•íƒœë¥¼ ê°–ëŠ” ë°©ì‹ìœ¼ë¡œ ë°ì´í„°ë¥¼ ë„£ê³  ë¹¼ëŠ” ì‘ì—…
- [Priority Queue 1: Max(Min) Heap]
- [Priority Queue 2: Min-Max Heap]
- [Priority Queue 3: Heap and Hashing]
- [Priority Queue 4: Deap]
- [Priority Queue 5: Leftist Tree]
- [Priority Queue 6: Binomial Heap]
- [Priority Queue 7: Fibonacci Heap]
- 

	![0](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/0.png)


# [Job Scheduling Example: Priority Queue]

- Consider the following sequence of requests in an operating system:
- multiprocessingì„ í•  ë•Œ ì—¬ëŸ¬ processê°€ ë„ëŠ”ë°,
	- ì˜ˆë¥¼ ë“¤ì–´ ë°”ì´ëŸ¬ìŠ¤ê°€ ì¹¨ì…í–ˆê³  ì´ë¥¼ ë§‰ê¸° ìœ„í•œ processê°€ ì œì¼ ë¨¼ì €
	- ì œí•œëœ rsrcë¥¼ ì‹œê°„ ìª¼ê°œê°€ë©° ì“´ë‹¤. cpu ì…ì¥ì—ì„œëŠ” ë‹¤ìŒì— ì‹œê°„ì„ ë‚˜ëˆ„ì–´ processë¥¼ ëŒë¦´ ë†ˆì„ ë‚˜ì™€ë¼ í•˜ì—¬ ì²˜ë¦¬í•´ ì£¼ê³  ê·¸ ë‹¤ìŒ ì¤„ ì„œìˆëŠ” ë†ˆë“¤ ì¤‘ process ë²ˆí˜¸, owner , priorityì¼ ë•Œ ì—¬ëŸ¬ policyë¡œ OSë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤.

	![1](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/1.png)

- data ì €ì¥ì†Œì— ì²˜ë¦¬í•´ë‹¬ë¼ëŠ” ê²ƒì´ ë“¤ì–´ê°€ ìˆê³ , data ì €ì¥ì†Œì— ë“¤ì–´ê°”ë‹¤ ë‚˜ì™”ë‹¤ê°€ ê³„ì†ë°˜ë³µë˜ê³  ìˆë‹¤. ê°€ì¥ ë¨¼ì € ë“¤ì–´ì˜¨ ì• ë¥¼ ê°€ì¥ ë¨¼ì € ì²˜ë¦¬í•´ ì£¼ê³ , OSë§ˆë‹¤ ì¸í„°ë„·ì—ì„œ ë™ì˜ìƒ ë³´ëŠ” processë³´ë‹¤ëŠ” ìš´ì˜ì²´ì œë“¤ì´ ë°”ì´ëŸ¬ìŠ¤ ë° ë„¤íŠ¸ì›Œí¬ ì²˜ë¦¬ ë“± priority ë†’ì€ processë“¤ì´ ìˆë‹¤.
- dataì €ì¥ì†Œì— elementê°€ ìˆëŠ”ë° priortyë¥¼ ê°€ì§€ê³  ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ ë†ˆ ë‚˜ì™€, í•˜ëŠ” ê²ƒì´ priority-based
	- ê°ê°ì˜ ì›ì†Œë“¤ì´ ë“¤ì–´ê°ˆ ë•Œ ê³„ì† ë“¤ì–´ê°€ê³  ëº„ ë•ŒëŠ” priorityì— ë”°ë¼ ë‚˜ì˜¤ê²Œ í•¨.
	- ë°ì´í„° ì €ì¥ :ë‚˜ì˜¬ ë•Œ ìš°ì„ ìˆœìœ„ ì„¤ì •

## Requirement 1

- CPU executes the process with the highest priority first.
- Use a heap structure â€“ a simple max heap :)
- 

	![2](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/2.png)


	```c
	typedef struct _process
	{
	    int proc_id;
	    char *owner;
	    int priority;
	} Process;
	
	static Process *_proc_heap;
	static int _proc_heap_size = 0;
	static int _proc_heap_ptr = 0;
	
	int PH_create(int n);
	int PH_full();
	int PH_empty();
	int PH_insert(Process item);
	int PH_delete(Process *item);
	```


## Requirement 2

- The priority of processes can be modified after they are placed in the priority queue.

	```c
	int H_change_priority(int proc_id, int new_priority);
	```

	- This function requires locating a particular process in the heap, but the basic heap operations provide no efficient way to do it.
	- Employ an auxiliary data structure such as a hash table that keeps track of the location of each process in the heap structure.
- Once the two requirements are satisfied, the operating system can process the following basic commands efficiently

	```text
	INSERT  <proc_id>  <owner>  <priority>
	DELETE
	CHANGEPR <proc_id> <new_priority> PRINTHEAP
	END
	```


# [ALG] 2.2. PQ1: Max(Min) Heap (1)


	_ref_.Â [Horowitz 5.6.2] [Neapolitan 7.6]


	# PQ1: Max(Min) Heap

	- Problem
		- The following operations must be performed as mixed in data processing:
			- Store a record with a key in an arbitrary order.
			- Fetch the record with the current largest key.
	- A solution
		- <u>Design a</u>Â <u>**data structure**</u>Â that offers an efficient implementation of the following operations:
	- <u>**Insert an element with an arbitrary key.**</u>
	- <u>**Delete an element with the largest key.**</u>

		![3](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/3.png)

		- key = priority ì˜ë¯¸
			- ë‘ ê°€ì§€ operationì„ íš¨ìœ¨ì ìœ¼ë¡œ êµ¬í˜„í•˜ëŠ” ìë£Œêµ¬ì¡°ë¥¼ ì„¤ê³„í•˜ì—¬ êµ¬í˜„í•˜ë¼
			- insert, delete ë“± ìš©ì–´ëŠ” ì•Œì•„ì„œ ìƒê°í•˜ë©´ ë  ê²ƒ.
	- ë°°ì—´ array ê°€ì§€ê³  êµ¬í˜†í•  ìˆ˜ ìˆëŠ” ë°©ë²•
		- 0, 1, 2, 3. .. ëì—ë‹¤ ê³„ì† ì§‘ì–´ë„£ìœ¼ë©´ ë¨
		- ì œì¼ ëì— ìˆëŠ” ì• ë¥¼ ë³´ë‚´ì£¼ë©´ ëì´ ëœë‹¤.
		- insertí•˜ê³  deleteì˜ ì—°ì‚°ì´ ìˆëŠ”ë°, dataê°€ í˜„ì¬ ë°°ì—´ data ì €ì¥ì†Œì— nê°œ ì›ì†Œê°€ ìˆì„ ë•Œ insert, deleteì˜ ë¹„ìš©ì€
			- insert $O(1)$
			- sequential search â†’ delete $O(n)$
	- system ë“¤ì–´ê°€ëŠ” ê²ƒì€ ëŠë ¤ë„ ìƒê´€ ì—†ëŠ”ë° ë‚˜ì˜¬ ë•ŒëŠ” ë¹¨ë¦¬ ë‚˜ì™€ì•¼ í•œë‹¤ê³  í•˜ë©´ arrayê°€ ë” ì¢‹ì„ìˆ˜ë„ ìˆìŒ
		- ì¼ë°˜ì ìœ¼ë¡œ heapì´ ì„±ëŠ¥ì´ ì¢‹ê¸°ëŠ” í•¨

		![4](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/4.png)


		|        | array | array | heap     |
		| ------ | ----- | ----- | -------- |
		| insert | O(1)  | O(n)  | o(log n) |
		| delete | O(n)  | O(1)  | O(log n) |

undefined
	# An Array Implementation

	- Ref. [Sedgewick 9.2]

		```c
		void PQinit();
		int PQempty();
		void PQinsert(int);
		int PQdelmin();
		void PQdec(int);
		
		#include <stdlib.h>
		static int *pq;
		static int N;
		#define MAX_N 10000;
		
		void PQinit()
		{
		    pq = malloc(MAX_N * sizeof(int));
		    N = 0;
		}
		int PQempty()
		{
		    return N == 0;
		}
		void PQinsert(int v)
		{
		    pq[N++] = v;
		}
		
		int PQdelmin()
		{
		    int j, min = 0;
		    for (j = 1; j < N; j++)
		        if (less(pq[min], pq[j]))
		            min = j;
		    exch(pq[min], pq[N - 1]);
		    return pq[--N];
		}
		
		int less(int i, int j)
		{
		    return **... * *;
		}
		
		void exch(int i, int j)
		{
		    ...
		}
		
		void PQdec(int k)
		{
		    ...
		}
		```

	- What will be the worst-case time complexity of each operation?

	# Max(Min) Heap: Definitions


	![5](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/5.png)

	- tree
		- rooted tree
			- ì¼ë°˜ì ì¸ treeì—ì„œ vertexë¥¼ í•˜ë‚˜ ì¡ì•„ ì˜¬ë ¤ root
			- binary - ìµœëŒ€ ë‘ ê°œ ê¹Œì§€ì˜ childë¥¼ ê°€ì§€ëŠ” tree
			- full binary tree : ëª¨ë‘ ë‘ê°œ childë¥¼ ê°–ëŠ” tree
			- complete binary tree : ì œì¼ ëì˜ leaf ëª‡ ê°œë§Œ ë‚ ì•„ê°„ bt
				- pointerless representation
				- ì™¼ìª½ childëŠ” parentì˜ ë‘ ë°°, ì˜¤ë¥¸ìª½ childëŠ” parentì˜ ë‘ ë°° +1
		- a kind of graph
			- connected + acyclic
			- vertex, edge

	## Definition 1

	- [Horowitz 5.6.2] [Neapolitan 7.6]
	- A max(min) heap is a complete binary tree where the key value in each internal node is no smaller(larger) than the key values in its children.

	## Definition 2

	- A binary tree has the max(min) heap property if and only if
		- The number of nodes of the tree is either 0 or 1, or
		node 0ê°œê±°ë‚˜ 1ê°œë©´ max heap
		- For the tree that has at least two nodes, the key in the root is no smaller(larger) than that in each child and the subtree rooted at the child has the max(min) heap property.
		
		root nodeëŠ” ìì‹ ì˜ childë³´ë‹¤ ê°™ê±°ë‚˜ ì‘ì§€ ì•Šë‹¤ (ê°™ê±°ë‚˜ í¬ë‹¤)
		ê·¸ë¦¬ê³  ê°ê°ì˜ childë¥¼ rootìœ¼ë¡œ í•˜ëŠ” subtree.
		- ë‚˜ë‘ ê°™ì´ ìƒê²¼ëŠ”ë° sizeë§Œ ì‘ì€ ê²ƒì˜ ì„±ì§ˆ : recursion ì„±ì§ˆì„ ì˜ ìƒê°í•´ë³´ë©´ ë°‘ìœ¼ë¡œ ë‚´ë ¤ê°€ë©´ ê²°êµ­ ì–´ë–¤ nodeë“  ê±´ì— parentëŠ” childë³´ë‹¤ í¬ë‹¤.
	- A <u>max(min) heap</u> is a complete binary tree that has the <u>max(min) heap property.</u>
		- max heap : complete BT - max heap propertyë¥¼ ê°–ëŠ”

	![6](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/6.png)


	### Brainstorming on Max Heap Operations

	- Max Heap Example
		- ì„±ì§ˆì„ ì˜ ì´í•´í•  ê²ƒ : ìê¸° ìì‹ ë³´ë‹¤ ê°™ê±°ë‚˜ í¬ë‹ˆê¹Œ 36ì´ ì•„ë‹ˆë¼ 101ì´ì–´ë„ê´œì°®ìŒ
	- Deletion Example 1
		- data ì €ì¥ëœ ê²ƒë“¤ ì¤‘ priority/key ì œì¼ í° ê²ƒ ë‚˜ê°. - 103
		- ê³„ì†í•´ì„œ complete BT ìœ ì§€í•˜ë ¤ê³  í•˜ëŠ”ë° ëŒ€ì¥ 103ì´ ë‚˜ê°€ë²„ë¦¼.
		- ì›ë˜ ìˆë˜ ê²ƒë³´ë‹¤ ì›ì†Œ ê°œìˆ˜ê°€ í•˜ë‚˜ ë” ì¤„ì€, heapì„ ìœ ì§€í•˜ëŠ” ë°©ë²•ì€ ì–´ë–»ê²Œ ë˜ëŠ”ê°€?

			â†’ ìì‹ë³´ë‹¤ ê°™ê±°ë‚˜ í¬ë‹¤ëŠ” ì„±ì§ˆ : 101ì„, 99ë¥¼ ì˜¬ë¦¬ëŠëƒ ê³ ë¯¼í•˜ë©° 101ì´ ì˜¬ë¼ê°€ë©° ë¹ˆ ê³³ì„ ë‹¤ë¥¸ nodeë“¤ì´ ì±„ì›Œ ì¤Œ.


			max heap propertyê°€ ê¹¨ì§€ê¸° ë•Œë¬¸ì— ì•„ë‹˜. ë¬´ì¡°ê±´ í•˜ë‚˜ì”© ìœ„ë¡œ ì˜¬ë¦¬ëŠ” ê²ƒì€ ì•„ë‹˜ì„ í™•ì¸í•  ìˆ˜ ìˆìŒ. 9ë¥¼ ì˜¬ë¦¬ë©´ ë§¨ ë 13ì€ í•´ê²°í•  ìˆ˜ ì—†ìŒ


		![7](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/7.png)

	- Deletion Example 2
		- 13ì„ ì™• ì‹œí‚¤ë©´ í•­ìƒì€ ë¬¸ì œ ìƒê¸°ì§€ ì•ŠìŒ
			- ìš°ì—°íˆ ë°‘ì˜ ì›ì†Œê°€ 13ì¼ ë•ŒëŠ” ë¬¸ì œê°€ ì•ˆìƒê¸°ê² ì§€ë§Œ.
		- childì—ì„œ 101, 99ì¤‘ì— ì´ ë™ë„¤ ì™• í•œë²ˆ í•´ ë³¼ê¹Œ í•˜ê³  ì‚´í´ë³´ëŠ” ê·¸ ìƒí™©ã…‡ìœ¼ë¡œ ë°”ë€Œê²Œ ë¨. 13ì´ ì™• í•´ë³¼ê¹Œ í•˜ëŠ” ìƒí™©ì—ì„œ 101ì„ ì˜¬ë ¤ë³´ëŠ” ìƒí™©ì´ê³  ì™¼ìª½ ì•„ë˜ë¡œ ë‚´ë ¤ê°.
		- ë§ì€ treeì˜ ë¬¸ì œë“¤ì´ recursion ìì²´ë¥¼ ì„œì„œ í™œìš©ê°€ëŠ¥í•¨
		- delete algì˜ ìµœëŒ€ ë¹„ìš©, ì‹œê°„ ë¹„ìš© - ìµœëŒ€ ëª‡ ì¹¸ê¹Œì§€ ë‚´ë ¤ê°€ëŠ”ê°€ (3ì¹¸) - logì ìœ¼ë¡œ ë³´ì—¬ì–— ã…ã…
		- complete btëŠ” ë¨.
		- ê²½ë¡œì— ìˆëŠ” ì• ë“¤ì€ â€˜ë‚´ê°€ ë‚´ childë³´ë‹¤ í¬ë‹¤â€™ë¼ëŠ” heap ì¡°ê±´ì„ ì˜ ì§€ì¼°ìŒ
		- ë‘ childë³´ë‹¤ í° 13 > 9, 6ì˜ í˜•íƒœ - ë‘ childë³´ë‹¤ ê°™ê±°ë‚˜ í¬ë‹¤ëŠ” ì„±ì§ˆì„ ìœ ì§€í•˜ë©° ë‚´ë ¤ì˜´./
	- Insertion Example
		- 50ì„ ì§‘ì–´ë„£ì–´ë¼. ê·¸ëŸ¬ë©´ complete bt ë§Œë“¤ì–´ì•¼ í•˜ë‚˜ã…£ nodeë¥¼ í•˜ë‚˜ ë§Œë“¤ê³  100ì„ ì§‘ì–´ë„£ëŠ”ë‹¤.
		- rootê¹Œì§€ì˜ path ê²½ë¡œì— ìˆëŠ” ê´€ê³„ë§Œ ë”°ì§€ë©´ ë¨ :
			- left familyì—ì„œ 100ì´ ìˆê±´ ì—†ê±´ ì•„ë¬´ ìƒê´€ì—†ìŒ (heapì˜ ì •ë¦¬ì— ì˜í•´ì„œ)
			- í˜•ì œ ê´€ê³„ ì¤‘ì—ì„œë„ ìƒê´€ì—†ê³ , ì¤‘ìš”í•œ ê±´ ë¶€ëª¨ì™€ ë‚˜ì˜ ê´€ê³„ì¼ ë¿
			- ê²½ë¡œë¥¼ ì«“ì•„ ì˜¬ë¼ê°€ë©° ë¶€ëª¨ë¥¼ ë³´ê³  ë¶€ëª¨ë³´ë‹¤ í¬ë©´ ìì‹ ì‰ ë¶€ëª¨ê°€ ë¨. (ë¶€ëª¨ë³´ë‹¤ ì‘ìœ¼ë©´ ê·¸ ì‹œì ì—ì„œ ë©ˆì¶¤. ê°™ì€ ë…¼ë¦¬ë¡œ, ê²½ë¡œë¥¼ max heap ì„±ì§ˆì„ ìœ ì§€í•˜ë©´ì„œ ì™”ê³  + ë‚˜ë¨¸ì§€ëŠ” ìœ ì§€ê°€ ë˜ì–´ ìˆê³  â†’ ì•Œê³ ë¦¬ì¦˜ì˜ í•©ë¦¬ì„± ê²€ì¦
			- ìµœì•…ì˜ ê²½ìš° log(n) time

		![8](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/8.png)

	- $C = \log_2 n$
	- Deletion from a Max Heap
	- ref.Â [Horowitz 5.6.2]

		```c
		#define MAX_ELEMENTS 200
		#define HEAP_FULL(n) (n == MAX_ELEMENTS - 1) #define HEAP_EMPTY(n)(!n)
		typedef struct
		{
		    int key;
		    /* other fields */
		} element;
		element heap[MAX_ELEMENTS];
		int n = 0;
		```


		![9](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/9.png)


		$2^c \leq n < 2^{c+1} \rightarrow c \leq log_2 n <c+1$


		```c
		//ìµœëŒ€ íˆí”„ì— ì‚½ì…
		void insert_max_heap(element item, int *n)
		{
		    int i;
		    if (HEAP_FULL(*n))
		    {
		        fprintf(stderr, "the heap is FULL\n");
		        exit(1);
		    }
		    i = ++(*n);
		    while ((i != 1) && (item.key > heap[i / 2].key))
		    {
		        heap[i] = heap[i / 2];
		        i /= 2;
		    }
		    heap[i] = item;
		}
		
		```


		![10](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/10.png)


		$C \sim log_2n $


		```c
		element delete_max_heap(int *n)
		{
		    int parent, child;
		    element item, temp;
		    if (HEAP_EMPTY(*n))
		    {
		        fprintf(stderr, "The heap is empty\n");
		        exit(EXIT_FAILURE);
		    }
		
		    item = heap[1];
		
		    temp = heap[(*n)--];
		    parent = 1;
		    child = 2;
		    while (child <= *n)
		    {
		
		        if ((child < *n) && (heap[child].key > heap[child + 1].key))
		            child++;
		        if (temp.key <= heap[child].key)
		            break;
		
		        heap[parent] = heap[child];
		        parent = child;
		        child *= 2;
		    }
		    heap[parent] = temp;
		    return item;
		}
		```


		![11](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/11.png)


		![12](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/12.png)


		$O(\log n)$

	- childê°€ ìˆì„ ë•Œê¹Œì§„ ë‚´ë ¤ê°€ì•¼ í•œë‹¤.
		- childê°€ 2ê°œë©´ left , right ì¤‘ í° ê±° ì„ íƒí•´ì„œ ì¤„ì¤„ì¤„ while ë¬¸ì—ì„œ ëˆë‹¤.
	- ì¤‘ê°„ê³ ì‚¬ì—ì„œ ë¹ˆì¹¸ ë§¤ê¾¸ê¸° ë¬¸ì œ ê°€ëŠ¥

		child 2ê°œ : 


	# Another Heap Implementation (Min Heap)

	- _ref_.Â [Sedgewick 9.3]

		```c
		void PQinit(int);
		int PQempty();
		void PQinsert(int);
		int PQdelmin();
		static int *pq;
		static int N;
		void PQinit(int maxN)
		{
		    pq = malloc(maxN * sizeof(int));
		    N = 0;
		}
		
		int PQempty()
		{
		    return N == 0;
		}
		
		void PQinsert(int v)
		{
		    pq[++N] = v;
		    fixUp(pq, N);
		}
		
		Item PQdelmin()
		{
		    exch(pq[1], pq[N]);
		    fixDown(pq, 1, N - 1);
		    return pq[N--];
		}
		
		fixUp(int a[], int k)
		{
		    while (k > 1 && a[k / 2] > a[k])
		    {
		        exch(a[k], a[k / 2]);
		        k = k / 2;
		    }
		}
		
		fixDown(int a[], int k, int N)
		{
		    int j;
		    while (2 * k <= N)
		    {
		        j = 2 * k;
		        if (j < N && a[j] > a[j + 1])
		            j++;
		        if (a[k] <= a[j])
		            break;
		        exch(a[k], a[j]);
		        k = j;
		    }
		}
		```

	- What will be the worst-case time complexity of each operation?

	> ğŸ’¡ sort by comparisoin algorithm. ì›ì†Œ nê°œ ìˆì„ ë•Œ n log n ì†ë„ ë³´ë‹¤ ë¹ ë¥´ê²Œ ë¶ˆê°€ëŠ¥í•˜ë‹¤.


	## Comparisons of Priority Queue Implementations


	![13](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/13.png)


	# Heap Sort


	Horowitz 7.7., Neapolitan 7.6

	- Method
		1. Convert an input array of n unordered items into a max heap.
		2. Extract the items from the heap one at a time to build an ordered array.
	- Sort by comparison : comparisonì„ í†µí•´ ì •ë ¬í•˜ëŠ” ë°©ë²•ì€ input size nì— ëŒ€í•´ì„œ costëŠ” ì•„ë¬´ë¦¬ ì¢‹ì€ ì•Œê³ ë¦¬ì¦˜ì„ ë§Œë“¤ë”ë¼ë„ $O(n \log n)$ë³´ë‹¤ ë” ë¹ ë¥´ê²Œ í•  ìˆ˜ëŠ” ì—†ë‹¤ (optimalì´ë‹¤)
		- ë¶ˆê°€ëŠ¥í•˜ë‹¤ê³  ì¦ëª…ëœ ë°” ìˆìŒ

		> ğŸ’¡ ì›ì†Œì˜ ê°œìˆ˜ nì— ëŒ€í•´ì„œ ì •ë ¬ì´ ì•ˆëœ ì„ì˜ì˜ ë°°ì—´ì— ëŒ€í•´ì„œ min, max heapì€ ilnear timeì— ì ìš©í•  ìˆ˜ ìˆë‹¤. ê·¸ë¦¬ê³  ê·¸ ë‘˜ì€ ìœ ìš©í•œ ìë£Œêµ¬ì¡°

	- max heap : í¬ê¸°ê°€ ê°™ê±°ë‚˜ í° ìˆœì„œëŒ€ë¡œ ë°ì´í„°ë¥¼ ì •ë ¬í•˜ëŠ” ê²ƒì´ ëª©í‘œì¸ë°, max heap ìƒíƒœì—ì„œëŠ” ì •ë ¬ì€ ì •í™•í•˜ê²ŒëŠ” ì•ˆ ë˜ì–´ìˆëŠ” ì–´ì •ì©¡í•œ ìƒíƒœ. ëŒ€ì¶© ì •ë ¬ì€ ëœ ë“¯í•œë° ì¤‘ê°„ì— ì‚ì­‰í•œ, ì •í™•í•˜ê²Œ ë§ì§€ëŠ” ì•Šì€ ìƒíƒœ.
	- unordered dataë¥¼ í¬ê¸° ìˆœì„œëŒ€ë¡œ ì •ë¦¬í•˜ë ¤ê³  í•¨. í•œ ë‹¨ê³„ ì¤‘ê°„ë‹¨ê³„ë¥¼ ê±°ì³ì„œ max heap ìœ¼ë¡œ ë³€ê²½í•œ ë‹¤ìŒ ordered ë‹¨ê³„ë¡œ ë³€í™˜

	![14](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/14.png)

	- 1ë²ˆ ë‹¨ê³„ì˜ ì‹œê°„ ë³µì¡ë„ - nì´ ê±¸ë¦¬ê³  2ë²ˆì—ì„œ nì´ ê±¸ë ¤ì„œ N log n íƒ€ì„ì˜ ë°ì´í„°ë¥¼ ì •ë ¬í•œë‹¤.
	- ì£¼ì–´ì§„ ì •ìˆ˜ë“¤ì„ ë¹„ê°ì†Œ ìˆœì„œ(non-decreasing order)ëŒ€ë¡œ ì •ë ¬í•˜ë¼.
		- nondecreasing â‰  increasing (ë‹¨ì¡°ì¦ê°€ ë“±ì˜ ì°¨ì´)

		```c
		typedef struct
		{
		    int key;
		    /* other fields */
		} element;
		Element list[MAX_SIZE];
		```


		```c
		void heapsort(element list[], int n)
		{
		    /*perform heapsort on the array*/ int i, j;
		    element temp;
		
		    // (1) Make a (max) heap
		    for (i = (n) / 2; i > 0; i--)
		        adjust(list, i, n);
		
		    // (2) Extract items one by one
		    for (i = n - 1; i > 0; i--)
		    {
		        SWAP(list[1], list[i + 1], temp);
		        adjust(list, 1, i);
		    }
		}
		```

		- (1) Make a (max) heap : $O(n)$
		- (2) Extract Items : $O(n \log n)$

	â†’ n log n


	upper bound eã…šë©´ì„œ operationë“¤ì´ ì—†ì–´ì§€ê³  ë‹¤ í•˜ë©´ ê°ê°ì€ tight upper bound


	ì œì¼ í° ê±° ë‚˜ì™€ í•´ì„œ ì§‘ì–´ë„£ì–´ì£¼ê³  n-2ê°œ ëŒ€í•´ì„œ ë˜‘ê°™ì€ê±° ë°˜ë³µí•˜ë‹ˆê¹Œ 


	log n-1


	ì²˜ìŒì— nê°œ ìˆì—ˆëŠ”ë° ë‚˜ë¨¸ì§€ n-1ê°œì— ëŒ€í•´ì„œ ì–´ë–¤ nodeê°€ leafì— ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ”ì§€ ì—†ëŠ”ì§€ í™•ì¸


	$2^c \leq n < 2^{c+1} \rightarrow c \leq \log_2 n <c+1$


	## Make a Max Heap

	1. $O(n\log n) \rightarrow O(n\log n)$
		- Make a (max) heap.

			![15](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/15.png)


			![16](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/16.png)


			![17](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/17.png)


			![18](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/18.png)


			![19](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/19.png)


	## The `adjust()` function


	> ğŸ’¡ ê³¼ê±° ì•Œê³ ë¦¬ì¦˜ ë§Œë“  ì‚¬ëŒì˜ ë…¼ë¦¬ë¥¼ ë¶„ì„í•´ì„œ ì ìš©í•´ë³´ì. ê·¸ëŸ¬ë©´ computatinoal thinking ìƒí™©ì—ì„œ ìì—°ìŠ¤ëŸ½ê²Œ íŒŒì•…í•˜ë©° ì„±ì¥í•  ìˆ˜ ìˆë‹¤!

	- cost : ê°ê°ì— ëŒ€í•´ì„œ í•µì‹¬ì´ ë˜ëŠ” operation
		- rootì—ì„œ ì‹œì‘í•´ì„œ ë‘ childì¤‘ì— í° ê²ƒ (list[child].key <
	- ì–´ë–»ê²Œ ìƒê°í–ˆì„ê¹Œ ì¶”ì í•´ë³´ë©´ : â€˜í˜¹ì‹œ ì •ì˜ì— ì˜í•´ì„œ :
		- ì •ì˜ : root nodeëŠ” ë‘ childë³´ë‹¤ ê°™ê±°ë‚˜ í¬ê³ , ê°ê°ì˜ childë¥¼ rootë¡œ í•˜ëŠ” subtreeê°€ max heapì´ë©´ recursiveí•œ max heapì´ êµ¬ì„±ëœë‹¤
		- ë‘ childë¥¼ rootë¡œ í•˜ëŠ” tree
	- code

		```c
		void adjust(element list[], int root, int n)
		{
		    int child, rootkey;
		    element temp;
		    temp = list[root];
		    rootkey = list[root].key;
		    child = 2 * root;
		    while (child <= n)
		    {
		        if ((child < n) && (list[child].key < list[child + 1].key))
		            child++;
		        if (rootkey >= list[child].key)
		            break;
		        else
		        {
		            list[child / 2] = list[child];
		            child *= 2;
		        }
		    }
		    list[child / 2] = temp;
		}
		```


		![20](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/20.png)

		- Executed d times, where d is the depth of the tree with root i â†’ $O(d)$

	# Cost of Make-Heap


	![21](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/21.png)

	- ExecutedÂ d_d_Â times, whereÂ d_d_Â is the depth of the tree with rootÂ i_i_
		- SoÂ $O(d)$Â time
	- `Output`: a binary tree T adjusted so that the entire binary tree satisfies the heap property
	- `Input`: a binary tree T whose left and right subtrees satisfy the heap property but whose root may not

	## Proof of correctness of Heap Construction Algorithm


	```c
	//make a max heap
	for(i =n/2;i>0;i--)
		adjust(list,i,n);
	```

	- $i = \frac n 2 , \frac n 2 -1, \frac n 2 -2, ... 2, 1$
	- Loop Invariant
		- just before each iteration for the for-loop starts, each node numbered i+1, i+2, â€¦ n is the root of a max heap
	- Proof of correctness by mathematical Induction
		- base step (base case, basis)
			- when $i = \frac n 2 $ (why?)
		- induction step (inductive step)
			- assume that the loop invariant holds for $i=k(k<\frac n 2)$
			- then it also holds for $i = k-1$
				- $k+1, k+2, ... n \rightarrow k, k+1, k+2, ... n$
				- fact 1 : each child node of node k is a max-heap
				- fact 2 : the `adjust()` function makes the node k a root of max-heap
				- fact 3 : it also preserves the property that the nodes k+1, .. n are roots of max-heaps
	- notes
		- when the for-loop terminates, the node 1 is the root of a max-heap

	## Extract items one by one.

	- ê¼¼ê¼¼íˆ ë”°ì ¸ë³´ë©´ì„œ ì„±ì  ë° ì‹œí—˜ì—ì„œ ê·¸ë™ì•ˆ ê¸°ì¶œ ë¬¸ì œë¥¼ ì˜¬ë¦´ ì˜ˆì •ì¸ë°, ì´ë¥¼ ê°•ì¡°í•˜ëŠ” ì´ìœ ê°€ ë‚˜íƒ€ë‚  ë“¯
	- ì œì¼ í° ë†ˆ ë‚˜ì™ˆ í•´ì„œ leafì—ë‹¤ ì§‘ì–´ë„£ê³ ,
		- ë¹„ìš©ì´ n log n : ë§¤ë²ˆ í•´ ì£¼ëŠ” ë¹„ìš©ì„ ìƒê°í•´ë³´ë©´
		- ë§¤ë²ˆ ì œì¼ í° ê²ƒ ë‚˜ì™€ í•´ì„œ ì¤„ì¤„ì¤„ updateë¥¼ ë°˜ë³µí•˜ë‹¤ë³´ë©´ ì œì¼í° ê²ƒ ìˆœì„œëŒ€ë¡œ ìŒ“ì´ê²Œ ë  ê²ƒ.

	![22](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/22.png)

	- Time Complexity Analysis
		- $2^k \leq 2n2kâ‰¤2n, âˆ’k<âˆ’\log2n$
			- $k < -\log_2 n$
		- thenÂ $2kâˆ’kâˆ’1<2nâˆ’\log2nâˆ’1$

			$2^k -k -1 < 2n - log_2n -1$

		- soÂ $C_{MH} = O(n)$
	- $I = -k+ \frac {1 \cdot (2^k-1)}{2-1} = 2^k -k -1I=âˆ’k+2âˆ’11â‹…(2kâˆ’1)=2kâˆ’kâˆ’1$

		$âˆ´ C_{MH} \leq 2^k -k -1$

	- $2I= (k-1)2^1 + (k-2)2^2 + (k-3)2^3 + ...+1 \cdot 2^{k-1}$
		- $\rightarrow 2I-1I= -(k-1) + 2^1+ 2^2 + ... + 2^{k-2}$
	- $I= (k-1)2^0 + (k-2)2^1 + (k-3)2^2 + ...+1 \cdot 2^{k-2}$
	- $C_{MH} \leq (k-1)2^0 + (k-2)2^1 + (k-3)2^2 + ...+1 \cdot 2^{k-2}$

	![23](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/23.png)


	$2^{k-1} \leq n < 2^k$ â†’ $k-1 \leq \log_2 n < k$


	## Complexity of Item Extractions


	![24](/assets/img/2022-09-12-[ALG]-2.-Heap-based-PQ.md/24.png)


	```c
	for (int i = n / 2; i > 0; i--)
	    adjust(list, i, n);
	for (int i = n - 1; i > 0; i--)
	{
	    SWAP(list[1], list[i + 1], temp);
	    adjust(list, 1, i);
	}
	```

	- Heap Sort :Â $C_{MH} +C_{IE} = O(n)+ O(n \log n) = O(n \log n)$
	- $C_{IE}
	\\=âŒŠ\log (n-1)âŒ‹+âŒŠ\log (n-2)âŒ‹+âŒŠ\log (n-3)âŒ‹...+âŒŠ\log2âŒ‹+âŒŠ\log 1âŒ‹\\ \leq \log2 + \log3 + ...+\log {(n-1)} = \log (n-1)!\\=O((n-1)\log (n-1)) = O(n \log n)\\< \sum_{i=2}^n \log_2 n
	\\= O(n \log n)
	\\â‰¤log2+log3+...+log(nâˆ’1)\\<âˆ‘i=2n \log 2n\\ =O(n \log n)$
	- for a givenÂ $n$, the cost (depth) isÂ $c = âŒŠ\log_2nâŒ‹$
	- $O(\log n!) = O(n \log n)$
		- proof

	## Heap Sort in C Implementation

	- ìƒí™©ì— ë§ê²Œ íŒë‹¨í•˜ì—¬ ì ìš©
		- constant time , log ní•˜ê³ ëŠ” ì—„ì²­ë‚œ ì°¨ì´ê°€ ì¡´ì¬í•˜ëŠ” ì‹œê°„ ë³µì¡ë„
		- 2^20ì´ ë°±ë§Œì¸ë° ê·¸ì— ë¹„ë¡€í•˜ëŠ” ì‹œê°„,

	# Priority Queue 2 : Min-Max Heap

	- Problem
		- The following operations must be performed as mixed in data processing:
			- Store a record with a key in an arbitrary order.
			- Fetch the record with the current largest key.
			- Fetch the record with the current smallest key.
	- A solution
		- Design a data structure that offers the efficient implementation of the following operations (Double-Ended Priority Queue):
			- Insert an element with an arbitrary key.
			- Delete an element with the largest key.
			- Delete an element with the smallest key.
			- â†’ ì–´ë–»ê²Œ í’€ ê²ƒì¸ì§€

	O(log n) â†’ 

	- ref._ref_.Â [Horowitz 9.1]

	---


	{êµìœ¡ê³¼ì • ì™¸}


	Priority Queue 3: Heap and Hashing


	Priority Queue 4: Deap


	Priority Queue 5: Leftist Tree


	Priority Queue 6: Binomial Heap


	Priority Queue 7: Fibonacci Heap


---
layout: post
date: 2022-09-19
title: "[ALG] 3.0. Algorithm Design (1)"
tags: [Algorithm, ]
categories: [Notes, ]
use_math: true
---

- Divide-and-Conquer Techniques and Sorting Techniques
	- Divide-and-Conquer Method
	- Dynamic Programming Method
	- Greedy Method
	- Backtracking Method
	- Local Search Method
	- Branch-and-Bound Method
	- Etc.

# The Divide-and-Conquer Approach


ê°ê°ì„ ë‚˜ëˆ„ì–´ conquerí•´ì„œ ì •ë³µí•˜ë‹¤ : ì›ë˜ ë¬¸ì œë¥¼ í‘¸ëŠ” ê²ƒê³¼ ê°™ì€ ë°©ì‹ìœ¼ë¡œ combineí•´ì„œ ì›ë˜ ë¬¸ì œì˜ í•´ë¥¼ ì°¾ëŠ” ë¬¸ì œ í•´ê²° ë°©ì‹. ì—¬ëŸ¬ê°€ì§€ ë¶€ë¥˜ì˜ ë³€í˜•ì´ ì¡´ì¬í•œë‹¤.

- (1) **Divide**Â an instance of a problem into one or more smaller instances
	- ë¬¸ì œì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ í•˜ë‚˜ ì´ìƒì˜ ì‘ì€ ì¸ìŠ¤í„´ìŠ¤ë¡œ ë‚˜ëˆ•ë‹ˆë‹¤.
- (2) **Conquer**Â (Solve) each of the smaller instances. Unless a smaller instance is sufficiently small, use recursion to do this.
	- ê° ì‘ì€ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì •ë³µí•©ë‹ˆë‹¤. ì‘ì€ ì¸ìŠ¤í„´ìŠ¤ê°€ ì¶©ë¶„íˆ ì‘ì§€ ì•Šìœ¼ë©´ ì¬ê·€ì ì„ ì‚¬ìš©í•˜ì—¬ ì´ ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
- (3) If necessary,Â **combine**Â the solutions to the smaller instances to obtain the solution to the original instance.
	- í•„ìš”í•œ ê²½ìš° ì‘ì€ ì¸ìŠ¤í„´ìŠ¤ì— ëŒ€í•œ ì†”ë£¨ì…˜ì„ ê²°í•©í•˜ì—¬ ì›ë˜ ì¸ìŠ¤í„´ìŠ¤ì— ëŒ€í•œ ì†”ë£¨ì…˜ì„ í™•ë³´í•©ë‹ˆë‹¤.

![0](/assets/img/2022-09-19-[ALG]-3.0.-Algorithm-Design-(1).md/0.png)


# Recursion

- Tower of Hanoi
	- [Geeksforgeeks](https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/)
	- ì‘ì€ê±° ìœ„ì— í° ê±° ì˜¬ë¦¬ì§€ ì•ŠëŠ” ì—°ì‚°

		![1](/assets/img/2022-09-19-[ALG]-3.0.-Algorithm-Design-(1).md/1.png)

- $T(n) = 2T(n-1) +1, n>1$
- $T(1)=1$
- Recursive thinking!
	- [princeton](https://introcs.cs.princeton.edu/java/23recursion/)

![2](/assets/img/2022-09-19-[ALG]-3.0.-Algorithm-Design-(1).md/2.png)

- recursionì˜ ë¬˜ë¯¸ - compactí•˜ê²Œ recursioní•˜ê²Œ í‘œí˜„
	- 3ê°œ ì˜®ê¸°ëŠ” ë°ë„ ë³µì¡í•˜ê²Œ ê°€ì§€ë§Œ ì´ë¥¼ compactí•˜ê²Œ ë°”ê¾¸ì–´ì£¼ëŠ” ì‘ì—…
- ì „ì²´ë¥¼ ì˜®ê¸°ëŠ”ë° í•˜ë‚˜ë¥¼ ì˜®ê¸´ë‹¤ : nê°œì˜ diskë¥¼ ì˜®ê¸°ëŠ” ë¹„ìš©
	- nê°œì˜ ë¹„ìš©ì€ ì–´ë–»ê²Œ ë ê¹Œ : $T(n) = 2 T(n-1) + 1 (n \geq 2)$
	- ì‘ì€ ê²ƒ ë‘ ë²ˆ ì˜®ê¸°ê³  ë§ˆì§€ë§‰ í•˜ë‚˜ ê°€ì•¼í•˜ë¯€ë¡œ â†’ ì •í™•í•˜ê²ŒëŠ” $1 (n=1)$

	â†’ $O(2^n)$

- $T(n) = $
	- $a_n = 2a_{n-1} +1 (n \geq 2), a_1 = 1$ â†’ $a_n = ?$
- recursionì„ ì˜ ë‹¤ë£¨ë©´ ë§¤ìš° íš¨ìœ¨ì ìœ¼ë¡œ ë˜ê³ , ëŒ€í‘œì ìœ¼ë¡œ divide and conquer ë°©ë²•ë¡ 

# Sorting


> ğŸ’¡ A sorting algorithm is said to be stable if two items with equal keys appear in the same order in sorted output as they appear in the input array to be sorted.  
> Sorting Algorithmì˜ Stability : ì •ë ¬ë˜ì§€ ì•Šì€ ìƒíƒœì—ì„œ ê°™ì€ key ê°’ì„ ê°€ì§„ ì›ì†Œì˜ ìˆœì„œê°€ ì •ë ¬ í›„ì—ë„ ìœ ì§€í•˜ëŠëƒ  
>   
> ì¼ë¶€ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì€ ì‚½ì… ì •ë ¬, ë³‘í•© ì •ë ¬, ë²„ë¸” ì •ë ¬ ë“±ê³¼ ê°™ì´ ë³¸ì§ˆì ìœ¼ë¡œ ì•ˆì •ì ì…ë‹ˆë‹¤. (ì •ë ¬ í›„ì—ë„ ì›ë˜ì˜ ìˆœì„œê°€ ìœ ì§€ë¨)


	Sorting Algorithmì˜ Stability : ì •ë ¬ë˜ì§€ ì•Šì€ ìƒíƒœì—ì„œ ê°™ì€ key ê°’ì„ ê°€ì§„ ì›ì†Œì˜ ìˆœì„œê°€ ì •ë ¬ í›„ì—ë„ ìœ ì§€í•˜ëŠëƒ


	ì¼ë¶€ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì€ ì‚½ì… ì •ë ¬, ë³‘í•© ì •ë ¬, ë²„ë¸” ì •ë ¬ ë“±ê³¼ ê°™ì´ ë³¸ì§ˆì ìœ¼ë¡œ ì•ˆì •ì ì…ë‹ˆë‹¤. (ì •ë ¬ í›„ì—ë„ ì›ë˜ì˜ ìˆœì„œê°€ ìœ ì§€ë¨)

- Problem:
	- Given a list of n items, arrange themÂ **in a certain order.**
		- Ex: non-increasing, non-decreasing, or etc. : í¬ê¸°ìˆœì„œëŒ€ë¡œ ì •ë ¬í•œë‹¤
		- ì´ë¡ ì , ì•Œê³ ë¦¬ì¦˜ì ìœ¼ë¡œ ë¬¸ì œ í•´ê²°í•˜ëŠ” ì¸¡ë©´ì´ ìˆê³ , practicalí•˜ê²Œ í•˜ëŠ”ê±°ë‘
- Some criteria for choosing a sorting algorithm
	- How many items will you be sorting? ì–¼ë§ˆë‚˜ ë§ì€ ì›ì†Œë¥¼ ì •ë ¬í•  ê²ƒì¸ê°€?
	- Will there be duplicate items in the data? ë°ì´í„°ì— ì¤‘ë³µ í•­ëª©ì´ ìˆìŠµë‹ˆê¹Œ?
	- What do you know about the data? ë°ì´í„°ì— ëŒ€í•´ ì•Œê³  ê³„ì‹­ë‹ˆê¹Œ?
		- Is the data already partially sorted?ë°ì´í„°ëŠ” ì´ë¯¸ ë¶€ë¶„ì ìœ¼ë¡œ ì •ë ¬ë˜ì–´ ìˆëŠ”ê°€?
		- Do you know the distribution of the items?í’ˆëª©ì˜ ë¶„í¬ë¥¼ ì•Œê³  ìˆìŠµë‹ˆê¹Œ?
		- Are the keys of items very long or hard to compare?í•­ëª© í‚¤ê°€ ë§¤ìš° ê¸¸ê±°ë‚˜ ë¹„êµí•˜ê¸° ì–´ë µìŠµë‹ˆê¹Œ?
			- ì •ìˆ˜ ë°ì´í„°ë¥¼ sortingí•˜ëŠ” ê±´ê°€, ì—¬ëŸ¬ stringì„ ë¹„êµí•˜ëŠ”ê²ƒì¸ê°€ì— ë”°ë¼ ì‚¬ìš©í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ ì ‘ê·¼ ë°©ì‹ì´ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆë‹¤.
			- ì´ì— ê´˜ë…ì¹˜ ì•Šê³  sorting algë¥¼ ì¢‹ë‹¤ë”ë‹ˆ ì“°ì í•˜ë©´ ë²„ë²…ë˜ëŠ” ê¼´ì´ ì¼ì–´ë‚  ê²ƒ.
		- Is the range of possible keys very small? ê°€ëŠ¥í•œ í‚¤ì˜ ë²”ìœ„ê°€ ë§¤ìš° ì‘ìŠµë‹ˆê¹Œ?
	- Do you have to worry about disk accesses? ë””ìŠ¤í¬ ì•¡ì„¸ìŠ¤ì— ëŒ€í•´ ì—¼ë ¤í•´ì•¼ í•©ë‹ˆê¹Œ?
	- Do you need a <u>**stable**</u> sorting algorithm? ì•ˆì •ì ì¸ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì´ í•„ìš”í•œê°€?
		- stableí•œ ì•Œê³ ë¦¬ì¦˜ 15 31 2 7 6 7 9 â‡’ 2 6 7 7 9 15 13
		- ê°™ì€ ê°’ì´ ìˆì„ ë•Œ ê·¸ ìˆœì„œê°€ ìœ ì§€ - ê°™ì€ 7, 7ì˜ ìˆœì„œê°€ ë³€í•˜ì§€ ì•ŠìŒ (stable soritng alg)
	- How much time do you have to write and debug your routine? ë£¨í‹´ì„ ì‘ì„±í•˜ê³  ë””ë²„ê¹…í•˜ëŠ” ë° ì–¼ë§ˆë‚˜ ë§ì€ ì‹œê°„ì´ í•„ìš”í•©ë‹ˆê¹Œ?
- ref.Â [Skiena, Steven S. The Algorithm Design Manual: The CD-ROM. 2 June 1997. 7 Dec. 2005](https://drive.google.com/drive/u/0/folders/1IyehEF9hz96cFu5js6ZWyfR4_Mvk1xb8),
	- ì›ë˜Â [ë§í¬](http://www2.toki.or.id/book/AlgDesignManual/BOOK/BOOK4/NODE148.HTM)Â ê¹¨ì§
- ì •ìˆ˜ì²˜ëŸ¼ 4byte ì €ì¥ë˜ëŠ”ê±´ì§€ ë“± ì–´ë–¤ dataë¥¼ ì •ë ¬í•˜ëŠëƒì— ë”°ë¼ì„œ sw ê°œë°œìë¡œì„œì˜ approachê°€ ì²œì°¨ë§Œë³„ : divide and conquer ì´í•´ê°€ ã…ëª©ì 
- GPU Parallel Sorting

### A Formal Definition of Sorting

- AÂ **partial order**Â on a set S is a relation R such that for each a, b, and c in S:
	- $aRa$Â is true (R is reflexive).
	- $aRb$Â andÂ $bRc$Â implyÂ $aRc$Â (R is transitive)
	- $aRb$Â andÂ $bRa$Â implyÂ $a=b$Â (R is antisymmetric)
- A Linear Order or Total Older on a setÂ _S_Â is a partial order R on S such that for every pair of elements a, b, either aRb or bRa.
- The sorting problem
	- Given a sequence ofÂ _n_Â elementsÂ $a_1, a_2, ..., a_n$ drawn from a set having a linear orderÂ $\preceq$
	- find a permutationÂ $Î =(Ï€_1,Ï€_2,...,Ï€_n) $ofÂ $(1,2,...,n)$Â that will map the sequence into a nondecreasing sequenceÂ $a_{\pi_1}, a_{\pi_2},...,a_{\pi_n}$, Â such thatÂ $a_{\pi_1} \preceq a_{\pi_i+1}$, Â forÂ $1 \leq i < n$
undefined- Ex:Â â‰¤Â onÂ $\mathbb{Z}, \subseteq$ on sets
undefined- Sorting on data with partial order?

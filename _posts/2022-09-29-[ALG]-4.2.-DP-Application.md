---
layout: post
date: 2022-09-29
title: "[ALG] 4.2. DP Application"
tags: [Algorithm, ]
categories: [Notes, ]
use_math: true
---


# [ALG] 4.5. [ì‘ìš©1] Longest Common Subsequence (LCS) (1)


# Longest Common Subsequences LCS


> ğŸ’¡ ê³µë™ìœ¼ë¡œ ê°–ëŠ” common subsequenceì˜ ê¸¸ì´ê°€ ì–¼ë§ˆë‚˜ ê¸´ê°€

- **[T. Cormen et al., Introduction to Algorithms (3rd ed.), The MIT Press, 2009. 16.3]**
- Definitions
	- Given a sequenceÂ $X = <x_1, x_2, ..., xm >$Â another sequenceÂ $Z = <z_1, z_2, ..., zk >$ is aÂ **subsequence**Â of X if there exists a strictly increasing sequenceÂ $<i_1, i_2, ..., i_k >$Â of indices ofÂ _X_Â such thatÂ $\forall j = 1, 2, ..., k$, we haveÂ $x_{ij} = z_j$
		- A subsequence of a given sequence is just the given sequence with some elements (possibly none) left out.
		- sequence : ë‚˜ì—´í•œ ê²ƒ / subsequence : í•´ë‹¹ sequenceì—ì„œ ìˆœì„œë¥¼ ìœ ì§€í•˜ë©° ë½‘ì•„ë‚¸ í˜•íƒœ
			- Ex. ABCDEFGHI â†’ ABD, AEFGH, AFI, â€¦ ë“±ì´ ìˆë‹¤.
				- (ë‹¨, ì•ì—ì„œë¶€í„°ê°€ ì•„ë‹ˆë¼ ìˆœì„œê°€ ë’¤ë°”ë€ IHE, BIDEHF ì™€ ê°™ì€ ë¬¸ìì—´ì€ ë¶€ë¶„ ë¬¸ìì—´ì´ ë  ìˆ˜ ì—†ë‹¤)
		- empty sequence : 0ê°œì˜ elementë¡œ êµ¬ì„±ëœ ê²ƒ
		- Ex: $\\ X=<A,B,C,B,D,A,B>, \\ Z=<B,C,D,B>(<2,3,5,7>)$
undefined	- Given two sequencesÂ _X_Â andÂ _Y_, we say that a sequenceÂ _Z_Â is aÂ **common subsequence**Â ofÂ _X_Â andÂ _Y_Â ifÂ _Z_Â is a subsequence of bothÂ _X_Â andÂ _Y_.
		- Ex:

			$X = <A, B, C, B, D, A, B>, \\ Y = <B, D, C, A, B, A>,\\ Z_1 = <B, C, A>,\\ Z_2 = <B, C, B, A>,\\ Z_3 = <B, D, A, B>$

	- Given a sequenceÂ $X = <x_1, x_2, ..., x_m >, X_i = <x_1, x_2, ..., x_i >$Â is the ithÂ **prefix**Â ofÂ _X_, forÂ $i = 0, 1, ..., m$
		- prefix ì ‘ë‘ì‚¬ :
			- sequenceê°€ ìˆì„ ë•Œ ì•ì—ì„œ ë„¤ê°œ ë½‘ì€ X4ê°€ prefix of sequence
		- Ex:Â $X = <A, B, C, B, D, A, B>, \\ X_4 = <A, B, C, B>,\\ X_0 =$null sequence
		- empty vs null : ë‘ ìš©ì–´ ëª¨ë‘ ê°™ì€ ë§¥ë½ìœ¼ë¡œ í™œìš©ë¨
undefined- Problem
	- ìƒë¬¼ DNA ì—¼ê¸°ì„œì—´ : ì–¼ë§ˆë‚˜ ë‘˜ì´ ìœ ì‚¬í•œê°€ ë¹„êµí•œë‹¤
		- metric ì •ì˜ : ë¬¸ì œì— ë”°ë¼ì„œ, ìƒí™©ì— ë”°ë¼ì„œ ì–´ë–»ê²Œ ê²°ì •í•˜ëŠëƒì— ë”°ë¼ì„œ ì•Œê³ ë¦¬ì¦˜ì„ ë§Œë“¤ì–´ ë¬¸ì œë¥¼ í•´ê²°í•œë‹¤.
		- Longest common subsequenceë¥¼ ì°¾ì•„ì„œ, ì–¼ë§ˆë‚˜ ê¸´ê°€ í™•ì¸í•˜ëŠ” ë¬¸ì œ
	- Given two sequencesÂ $X = <x_1, x_2, ..., x_m >$Â andÂ $Y = <y_1, y_2, ..., y_n >$
		- m, në§Œí¼ì˜ ë‘ ê°œ sequenceê°€ ì£¼ì–´ì¡Œì„ ë•Œ ê°€ì¥ ê¸´ common sequenceë¥¼ ì°¾ì•„ì„œ ì–¼ë§ˆë‚˜ ê¸´ê°€ë¥¼ ê°€ì§€ê³  íŒë‹¨í•  ê²ƒì´ë‹¤.
	- find aÂ **longest common subsequence**Â ofÂ _X_Â andÂ _Y_.

		![0](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/0.png)

		- optimal substructure : ì–´ë–»ê²Œë“ ì§€ ë¬¸ì œ í•˜ë‚˜ ì‚¬ì´ì¦ˆë¥¼ ì¡°ê¸ˆì”© ì¤„ì—¬ì„œ, optimal solutionì„ ì°¾ëŠ”ë‹¤. ê°€ì¥ ê¸´ ê²ƒ - maximization problemì™€ ì¼ë§¥ ìƒí†µ
		- problem input size : $(m,n)$
			- m : X sequenceì˜ ê¸¸ì´, n : Y Sequenceì˜ ê¸¸ì´
- NaÃ¯ve approach
	- xì˜ ëª¨ë“  Subsequenceì— ëŒ€í•˜ì—¬ yì˜ subsequenceì¸ì§€ í™•ì¸
	- Enumerate all subsequences of X and check each subsequence to see if it is also a subsequence of Y, keeping track of the longest subsequence found.
		- â†’ Exponential algorithm!
			- $\Theta(n \cdot 2^m)$ :  xì˜ ì›ì†Œê°œìˆ˜ m, y ì›ì†Œê°œìˆ˜ n
				- $2^m$ : xì˜ ëª¨ë“  Subsequence ê°œìˆ˜
				- $\Theta(n)$ : nê°œì˜ Element check time
	- The LCS problem can be solved efficiently using dynamic programming.

> ğŸ’¡ ì¤‘ìš”í•œ ë‚´ìš© !!

- **Optimal substructure of the LCS**
	- LetÂ $X = <x_1, x_2, ..., x_m >$Â and $Y = <y_1, y_2, ..., y_n >$ be sequences, and letÂ $Z = <z_1, z_2, ..., z_k >$Â be any LCS ofÂ _X_Â andÂ _Y_.
		1. IfÂ $x_m = y_n$, thenÂ $z_k = x_m = y_n$, andÂ $Z_{k-1}$ is an LCS ofÂ $X_{m-1}, Y_{n-1}$
		2. IfÂ $x_m \neq y_n$, then an LCS ofÂ _X_Â andÂ _Y_Â is
			1. either an LCS ofÂ $X_{m-1}$Â andÂ _Y_
			2. or an LCS ofÂ _X_Â andÂ $Y_{n-1}$
		- â†’ pink the longer sequence!

ì•ì˜ ê²ƒì„ í•˜ë‚˜ ë¹¼ë˜ì§€, ë’¤ì—ì„œ í•˜ë‚˜ ë¹¼ë˜ì§€, ì• ë’¤ì—ì„œ ê°ê° í•˜ë‚˜ ë¹¼ë˜ì§€


	![1](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/1.png)

- LetÂ _c_[_i_,_j_]Â be the length of an LCS of the sequencesÂ _Xi_Â andÂ _Yj_
- Optimal substructure for computingÂ $c[i, j]$
	- base case : 0 (empty sequence)

	![2](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/2.png)


```python
LCS(X,Y,m,n)
  if m==0 or n==0
    return 0
  else if X[m]==Y[n]
    return LCS(X,Y,m-1,n-1) + 1
  else 
    retrun max(LCS(X,Y,m-1,n),LCS(X,Y,m,n-1))
```


## 4.5.1.Â $O(mn)$Â Algorithm

- Filling the table
	- b, c table ê³„ì‚° : $\Theta(mn)$

	![3](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/3.png)

- Printing the LCS
	- $\Theta(m+n)$

	![4](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/4.png)


![5](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/5.png)


![6](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/6.png)


## 4.5.2. C Implementation

- Courtesy ofÂ [link](http://www.bioalgorithms.info/downloads/code/)

	```c
	/** Copyright (C) 2005 Neil Jones. **/
	#include <stdio.h>
	char *LCS(char *a, char *b);
	#define NEITHER 0
	#define UP 1
	#define LEFT 2
	#define UP_AND_LEFT 3
	int main(int argc, char *argv[])
	{
	    printf("%s\n", LCS(argv[1], argv[2]));
	}
	
	char *LCS(char *a, char *b)
	{
	    int n = strlen(a);
	    int m = strlen(b);
	    int **S;
	    int **R;
	    int ii;
	    int jj;
	    int pos;
	    char *lcs;
	
	    S = (int **)malloc((n + 1) * sizeof(int *));
	    R = (int **)malloc((n + 1) * sizeof(int *));
	    for (ii = 0; ii <= n; ++ii)
	    {
	        S[ii] = (int *)malloc((m + 1) * sizeof(int));
	        R[ii] = (int *)malloc((m + 1) * sizeof(int));
	    }
	    for (ii = 0; ii <= n; ++ii)
	    {
	        S[ii][0] = 0;
	        R[ii][0] = UP;
	    }
	    for (jj = 0; jj <= m; ++jj)
	    {
	        S[0][jj] = 0;
	        R[0][jj] = LEFT;
	    }
	    for (ii = 1; ii <= n; ++ii)
	    {
	        for (jj = 1; jj <= m; ++jj)
	        {
	            if (a[ii - 1] == b[jj - 1])
	            {
	                S[ii][jj] = S[ii - 1][jj - 1] + 1;
	                R[ii][jj] = UP_AND_LEFT;
	            }
	            else
	            {
	
	                S[ii][jj] = S[ii - 1][jj - 1] + 0;
	                R[ii][jj] = NEITHER;
	            }
	            if (S[ii - 1][jj] >= S[ii][jj])
	            {
	                S[ii][jj] = S[ii - 1][jj];
	                R[ii][jj] = UP;
	            }
	
	            if (S[ii][jj - 1] >= S[ii][jj])
	            {
	                S[ii][jj] = S[ii][jj - 1];
	                R[ii][jj] = LEFT;
	            }
	        }
	    }
	
	    ii = n;
	    jj = m;
	    pos = S[ii][jj];
	    lcs = (char *)malloc((pos + 1) * sizeof(char));
	    lcs[pos--] = (char)NULL;
	
	    while (ii > 0 || jj > 0)
	    {
	        if (R[ii][jj] == UP_AND_LEFT)
	        {
	
	            ii--;
	            jj--;
	
	            lcs[pos--] = a[ii];
	        }
	        else if (R[ii][jj] == UP)
	        {
	            ii--;
	        }
	        else if (R[ii][jj] == LEFT)
	        {
	
	            jj--;
	        }
	    }
	    for (ii = 0; ii <= n; ++ii)
	    {
	        free(S[ii]);
	        free(R[ii]);
	    }
	
	    free(S);
	    free(R);
	    return lcs;
	}
	
	```


# [ALG] 4.6. [ì‘ìš©2] The Gapped Alignment Problem (1)


# Gapped Alignment Problem

- Problem
	- Given two sequences, find a gapped alignment that maximize the score!
	- Compare two sequences if they are similar (related).
	- Gapped alignment
		- Example:
			- ì‹¤í—˜ì„ í•˜ë‹¤ë³´ë©´ ë¶ˆì™„ì „í•˜ê¸° ë•Œë¬¸ì— Gapì„ ë„£ëŠ” ê²ƒì„ í—ˆìš©í•˜ê³  aligní•˜ì.
			- ìˆ˜ì¹˜ì ìœ¼ë¡œ ì–¼ë§ˆë‚˜ ìœ ì‚¬í•œì§€ ë°íˆê¸° : mismatchê°€ ì¼ì–´ë‚˜ë©´ ì•ˆë˜ë‹ˆê¹Œ
			- Gapì— ëŒ€í•´ì„œëŠ” penaltyë¥¼ í¬ê²Œ ì¤€ë‹¤

				![7](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/7.png)

		- A possible alignment scoring scheme
			- Ex: match score = 2, mismatch penalty = -1, gap penalty = -2
			- ì´ëŸ¬í•œ ì ìˆ˜ ê¸°ì¤€ìœ¼ ë“¤ì–´ê°”ì„ ë•Œ, ì ìˆ˜ë¥¼ ìµœëŒ€í™”í•´ì£¼ëŠ” Gap Alignmentë¥¼ ì°¾ì•„ë¼
				- Ex. ê°ê° Gapì„ ì§‘ì–´ë„£ìœ¼ë©´ 1ì , 7ì ì¸ë° ì´ëŸ¬í•œ ì ìˆ˜ë¥¼ ìµœëŒ€í™”í•´ì£¼ëŠ” Gap ì •ë ¬ë°©ë²• ì°¾ê¸°
	- 

		![8](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/8.png)

	- case : ìœ„ì¹˜ë¥¼ ì¼ì¹˜ì‹œí‚¤ê³  / Aì—ë‹¤ Gapì„ ì§‘ì–´ë„£ì–´ ì •ë ¬/ Bì—ë‹¤ Gapì„ ì§‘ì–´ë„£ì–´ ì •ë ¬

		![9](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/9.png)

- ê²½ìš°ì— ë”°ë¼ ë¬¸ì œ ì‚¬ì´ì¦ˆ ì¤„ì´ê¸°
	- $A = a_1 a_2 a_3 ... a_m$, $B = b_1 b_2 b_3 ... b_m$
	- recursiveí•œ êµ¬ì¡° êµ¬ì¶• : ì œì¼ ë ë¶€ë¶„ì˜ characterê°€ $a_i b_j$
	- ë‘ sequenceì˜ ê°€ì¥ ëˆ ë¶€ë¶„ì„ ì–´ë–»ê²Œ ì²˜ë¦¬í•  ê²ƒì¸ê°€
- Optimal substructure
	- 

		![10](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/10.png)

	- $S(i, j)$ : maximizeí–ˆì„ ë•Œì˜ score
	- basis :
		- $i=0$ â†’ bì˜ ê¸¸ì´ì—ë‹¤ê°€ -2ë°°
		- $j=0Â $ â†’ aì˜ ê¸¸ì´ì—ë‹¤ê°€ -2ë°°
	- aìª½ì—ë‹¤ê°€ gapì„ ì§‘ì–´ë„£ì„ ìˆ˜ë°–ì— ì—†ë‹¤.
	- $S(i,j-1)-2Â $
		- Gapì„ ë„£ì–´ - ì´ì  ë°›ê³  b i-1ë¡œ maximizeí•˜ì
	- $S(i-1,j)-2$
		- Gapì„ ë„£ì–´ - ì´ì  ë°›ê³  a i-1ë¡œ maximizeí•˜ì
	- $s(a_i, b_j)Â $
		- a_i, b_j ë„£ì—ˆì„ ë•Œ ë‚˜ì˜¤ëŠ” score
		- ê°™ìœ¼ë©´ 2ì , mismatchí•˜ë©´ -1ì , gap penalty -2ì 
- DP
	- recursive top downì´ë©´ ë‹µì„ ëª»ë³´ê³  ë¬¸ì œ ì‘ì€ ê²ƒë¶€í„° ì°¨ê·¼ì°¨ê·¼ í’€ì–´ë‚´ë©´ ì–»ì–´ë‚¼ ìˆ˜ ìˆìŒ
	- table êµ¬ì„±, ì´ˆê¸°í™”, table fill ì„ í†µí•´ í° ë¬¸ì œì˜ ì •ë‹µ ì°¾ê¸°,
		- ì–´ë””ì—ë‹¤ê°€ Gapì„ ë„£ì–´ ì •ë³´ë¥¼ ì •ë ¬í•  ê²ƒì¸ì§€ : ì ìˆ˜ tableì´ í•„ìš”í•˜ê³ , maximum êµ¬í–ˆì„ ë•Œ max(S, S,S)ì—ì„œ ì •ë³´ë¥¼ ì·¨í–ˆëŠ”ì§€ ì €ì¥í•˜ê³  ì–´ë””ì— ëª‡ë²ˆì§¸ì— gapì„ ì €ì¥í–ˆëŠ”ì§€ ì¶œë ¥í•˜ê¸°

# [ALG] 4.7. [ì‘ìš©3] Longest Increasing Subsequence (LIS) (1)


# Problem

- Given a sequenceÂ $A=(a[0], a[1],...,a[n-1])$, find the length of the longest subsequence such that all elements of the subsequence are sorted increasing order.
	- ìˆœì„œë¥¼ ìœ ì§€í•œ subsequence : ê°’ì´ ì¦ê°€í•˜ëŠ” ì†ì„±ì„ ê°€ì§„
- Example
	- $(10, 22, 9, 33, 21, 50, 41, 60, 80)â†’(10, 22, 33, 50, 60, 80)$
		- (22, 9, 50, 41)ì€ increasing subsequenceê°€ ì•„ë‹˜
		- 80ìœ¼ë¡œ ëë‚˜ëŠ” LIS
		- â†’ ì§ì „ìœ¼ë¡œ ëë‚˜ëŠ”ê²Œ 60ì´ì—ˆê³ , ë‹¤ì‹œ 60ìœ¼ë¡œ ëë‚˜ëŠ” LIS
		- â†’ ..
	- $(0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15)\\â†’(0, 2, 6, 9, 11, 15), \\(0, 4, 6, 9, 11, 15) ...$
- Algorithm
	- LetÂ $d[i]$Â be the length of the LIS that ends in the element at indexÂ _i_. Then, the answer to the LIS problem is the maximum value ofÂ $d[i], i=0,1,...,n-1$
		- (a[1], a[2] â€¦ a[i]) ê¹Œì§€ë§Œ ìƒê°í–ˆì„ ë•Œ a[i]ë¡œ ëë‚˜ëŠ” LIS ë¥¼ ìƒê°í•´ë³´ì
	- increasing subsequenceì¤‘ ê°€ì¥ ê¸¸ì´ê°€ ê¸´ ê²ƒì„ ì°¾ì•„ë¼

# Optimal substructure


	$$
	d[i] = \max(1, \max_{j=0,...,n-1/ a[j]<a[i]}{(d[j]+1)})
	$$


	$i=0,1,..., n-1$

	- ê°€ì¥ í° ê²ƒ : ê·¸ ê¸¸ì´ê°€ ê°€ì¥ ê¸´ ê²ƒì´ ì¢‹ìŒ
	- d[i] : 5ë¡œ ëë‚˜ëŠ” longest increasing subsequenceì˜ ê¸¸ì´ë¡œ ì •ì˜ â†’ ê°ê°ì˜ ìœ„ì¹˜ì—ì„œ í•´ë‹¹í•˜ëŠ” d[i]ì˜ ê¸¸ì´ë¥¼ ì •ì˜í•œ ë‹¤ìŒ maximumì„ ì·¨í•œë‹¤. ëª¨ë“  d[i]ë¥¼ êµ¬í•´ maximumì„ êµ¬í•˜ëŠ”ë° ê·¸ lis ê¸¸ì´ êµ¬í•˜ê¸°
	- $(0, 8, 4, 12, 2, 10, 6, 14, 1, 9)$
		- a[i]ë¡œ ëë‚˜ëŠ” lisì˜ ë°”ë¡œ ì „ì— ì˜¤ëŠ” ì• ê°€ ë˜ë ¤ë©´ 1ì€ 9ë³´ë‹¤ ê°’ì´ ì‘ì•„ì•¼ í•¨.
		- ë‚˜ë³´ë‹¤ ì•ì—ìˆëŠ” ì• ë“¤ ì¤‘ì— ë‚˜ë³´ë‹¤ ì‘ì€ ì• ë“¤ë§Œ ê³ ë ¤í•´ì•¼ í•¨ : 9ë¡œ ëë‚˜ëŠ” LISê°€ ìˆì„ ë•Œ ë°”ë¡œ ì•ì— ìˆëŠ” ì• ëŠ”
		- ê±°ê¸°ì— ìˆëŠ” ì• ë“¤ ì¤‘ì— ë‚˜ë³´ë‹¤ ê°’ì´ ì‘ì€ ì• ë“¤ì´ ê·¸ ì•ì— ì˜¬ ëŒ€ìƒì´ ë˜ì–´ì•¼ í•¨
			- 9ë³´ë‹¤ ì‘ì€ 0, 8, 4, 2, 6, 1
			- ~~~ 4, 9 / ~~~~ 0, 9 / ~~~ 1, 9
			- ë³µì¡í•´ ë³´ì´ì§€ë§Œ ê²½ìš°ì˜ ìˆ˜ë¥¼ ì°¾ë‹¤ë³´ë©´ ìì—°ìŠ¤ëŸ½ê²Œ ë‚˜ì˜¤ëŠ” ê³¼ì •
		- recursiveí•˜ê²Œ 1ë¡œ ëë‚˜ëŠ” LISë¥¼ ê³„ì‚°í•œ ë‹¤ìŒ, 1ì„ ë”í•´ ìœ„ì¹˜ë¥¼ ì˜®ê¸°ë©´ 9ë¡œ ëë‚˜ëŠ” ìœ„ì¹˜ê°€ ë¨.
- base step : 1
	- d[i]ë¥¼ i=0~n-1ì—ì„œ ê³„ì‚°í•˜ëŠ”ë° max(d[j]+1)ì„ ê³„ì‚°í•˜ê¸° ìœ„í•œ for loop
- table êµ¬ì„±
	- 2dim tableì„ ë§ì´ ë´¤ì§€ë§Œ ì´ ë¬¸ì œì—ì„œëŠ” 1dim tableë¡œ ì •ì˜
	- 1 dim table ì›ì†Œ nê°œ : d[0] - d[1] - â€¦ d[n-1]
- ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œê°„ë³µì¡ë„ ì¶”ì •
	- ê°ê°ì˜ d[i]ì— ëŒ€í•´ì„œ ê°’ì„ ê³„ì‚°í•  ê²ƒì¸ë°, tableì„ ì±„ìš¸ time complexityëŠ” input size n
	- $O(n^2)$
	- ë‚˜ë³´ë‹¤ ì‘ì€ ì•„ì´ë“¤ê°€ì§€ê³  í›‘ê¸° : a[i]ë³´ë‹¤ ì‘ì€ ì• ë“¤ì„ ê°€ì§€ê³  í›‘ìŒ. ê·¸ëŸ¼ í•´ë‹¹ elementì˜ ë¹„ìš©ì€ ë‚˜ë³´ë‹¤ ì•ì— ì‡ëŠ” ì• ë“¤ì´ê³  ëª¨ë“  elementì— ëŒ€í•´ì„œ ê³„ì‚°í•˜ëŠ” ê²ƒì´ë¯€ë¡œ
- code

	```c
	int LIS(int *a, int N)
	{
	
	    int *best, *prev, i, j, max = 0;
	
	    best = (int *)malloc(sizeof(int) * N);
	    prev = (int *)malloc(sizeof(int) * N);
	    for (i = 0; i < N; i++)
	        best[i] = 1, prev[i] = i;
	
	    for (i = 1; i < N; i++)
	        for (j = 0; j < i; j++)
	            if (a[i] > a[j] && best[i] < best[j] + 1)
	                best[i] = best[j] + 1, prev[i] = j;
	    for (i = 0; i < N; i++)
	        if (max < best[i])
	            max = best[i];
	
			// Print the LIS using prev[] here. 
			free( best ); 
			free( prev );
			return max;
	}
	```

- best array
	- = d table
- prev array
	- = e table : ê°™ì€ size
	- ì°¾ì•„ê°€ëŠ” table
	- LISì˜ ê¸¸ì´ê°€ ì–¼ë§ˆì¸ê°€ ì¶œë ¥
- ì£¼ì–´ì§„ input sequenceê°€ ìˆì„ ë•Œ, ê¸¸ì´ê°€ ê°™ì€ë° ì„œë¡œ ë‹¤ë¥¸ê²Œ ìˆì„ ìˆ˜ ìˆìŒ
	- ê°™ì€ ê¸¸ì´ì¸ë° ì„œë¡œ ë‹¤ë¥¸ increasing sequence
	- â†’ uniqueí•˜ì§„ ì•Šë”ë¼ë„, ë¶„ëª…íˆ ìµœì†Œ í•˜ë‚˜ëŠ” ì¡´ì¬í•œë‹¤.

LISì˜ ì§ì „ì˜ elementë¥¼ ì°¾ì•„ê°€ë©´ í•´ë‹¹ ë‚˜ë¨¸ì§€ subsequenceì—ì„œ optimal substructureë¥¼ ì°¾ì•„ë¼. ì§€ê¸ˆê¹Œì§€ í•œ ê±°ë‘ì€ ì•½ê°„ ë‹¬ë¼ì„œ í™• ì™€ë‹¿ì§€ ì•Šê² ì§€ë§Œ ë°˜ë³µì ìœ¼ë¡œ ì´í•´í•´ë³´ì


# Minimal Triangulation

- **[A. Aho, J. Hopcroft, and J. Ullman, Data Structures and Algorithms, Addison-Wesley, 1983. 10.2]**
- Problem
	- Given a set ofÂ _n_Â vertices forÂ **convex**Â polygon, find a triangulation such that no two chords cross each other, and the total length of the chords selected is a minimum.
- Counting all possible selections of chords in an inefficient way results in an exponential algorithm.

	![11](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/11.png)


	![12](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/12.png)


# [ALG] 4.8. [ì‘ìš©4] The 0-1 Knapsack Problem (1)

- Problem
	- Given two sets of positive integersÂ $\{w_1, w_2, ..., w_n\}$Â andÂ $\{p_1, p_2, ..., p_n\}$ of sizeÂ _n_Â and a positive integerÂ _W_, find a subsetÂ _A_Â ofÂ $\{1,2,...,n\}$ that maximizesÂ $\Sigma_{i \in A} p_i$Â subject toÂ $\Sigma_{i \in A} w_i \leq W$
		- ì´ëŸ¬í•œ index ì§‘í•©ì˜ ë¶€ë¶„ì§‘í•©ì„ ì„ íƒí•˜ë¼, ì´ ì¤‘ì— ëª‡ ê°œë¥¼ ë½‘ì•„ë¼
		- $\Sigma_{i \in A} p_i$Â ì„ ìµœëŒ€í™”í•˜ë©´ì„œ, Â $\Sigma_{i \in A} w_i \leq W$ì˜ ì¡°ê±´ ë§Œì¡±
			- í›”ì¹œ ë¬¼ê±´ë“¤ì˜ ë¬´ê²Œë¥¼ ê°€ë°©ì´ í—ˆìš©í•´ì•¼ í•˜ê³ , ì¡°ê±´ í•˜ì— ë¬¼ê±´ì„ í›”ì³ì„œ ë²Œ ìˆ˜ ìˆëŠ” ë¬¼ê±´ë“¤ì˜ ê°€ê²©ë“¤ì„ maximize
	- $\{w_1, w_2, ..., w_n\}$Â - 0-1 : binary - í›”ì¹˜ì§€ ì•Šì„ ê²ƒì¸ì§€, í›”ì¹  ê²ƒì¸ì§€
	- $\{p_1, p_2, ..., p_n\}$ - ì„ íƒí•  ê²ƒì¸ì§€, ë§ ê²ƒì¸ì§€
	- fractional : ë¬¼ê±´ì„ í›”ì¹  ê²ƒì¸ì§€ ì•ˆ í›”ì¹  ê²ƒì¸ì§€
- 

ë¬¸ì œê°€ ì´í•´ê°€ ë˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ì´í•´í•œ í›„ ë‹¤ì‹œ ë“¤ì–´ë³¼ ê²ƒì„ ì¶”ì²œ.

- Example
	- $\{w_1, w_2, ..., w_5\} = \{6,5,10,3,4\}$
		- 1, 2, 5 weightì˜ í•©ì€ 15
	- $\{p_1, p_2, ..., p_5\} = \{9,7,11,6,8\}, W=15$
	- $\rightarrow \{1,2,5\}$
		- ê°ê° 1ë²ˆ, 2ë²ˆ, .. , 5ë²ˆ ë¶€ë¶„ì§‘í•©ì„ ì„ íƒí•˜ë©´ 1,2,5 ë½‘íŒê²ƒì˜ wí•©ì€
- An intuitive interpretation
	- There areÂ _n_Â items in a store. ê°€ ê²Œì— Nê°œì˜ ë¬¼ê±´ì´ ìˆëŠ”ë°
	- TheÂ _i_Â th item weighsÂ _wi_Â kilograms and is worthÂ _pi_Â wons, whereÂ _wi_Â andÂ _pi_Â are positive integers.
		- ië²ˆì§¸ ë¬¼ê±´ì€ Wi kgì´ê³  Piì›ì´ë‹¤.
	- A thief has a knapsack that can carry at mostÂ _W_Â kilograms, whereÂ _W_Â is a positive integer.
		- ë„ë‘‘ì´ Wê¹Œì§€ë§Œ ë‹´ì„ ìˆ˜ ìˆëŠ” ë°°ë‚­ì„ ê°€ì§€ê³  ì™”ë‹¤.
	- What items should the thief take to maximize his â€œprofitâ€?
		- ìµœëŒ€í•œ ì´ìœ¤ì„ ì–»ì„ ìˆ˜ ìˆê²Œ ë¬¼ê±´ì„ í›”ì¹˜ëŠ” ë°©ë²•

# 0. A 0-1 Knapsack Problem in Real Life


[ref](http://standardwisdom.com/softwarejournal/2010/03/bang-for-the-buck-knapsacks-in-real-life/)

- Problem
	- Given two sets of positive integersÂ $\{w_1, w_2, ..., w_n\}$Â andÂ $\{p_1, p_2, ..., p_n\}$ of sizeÂ _n_Â and a positive integerÂ _W_, find a subsetÂ _A_Â ofÂ $\{1,2,...,n\}$ that maximizesÂ $\Sigma_{i \in A} p_i$Â subject toÂ $\Sigma_{i \in A} w_i \leq W$

		ê°ê°ì˜ ë‹¤ë¥¸ value, weightë¥¼ ê°–ëŠ” item ì—¬ëŸ¬ ê°œê¸° ìˆë‹¤. knapsackì€ W kgê¹Œì§€ ìˆ˜ìš© ê°€ëŠ¥í• ë•Œ, knapsackì— ë‹´ì„ ìµœëŒ€ valueëŠ” ì–¼ë§ˆì¸ê°€


		 

	- You have a marketing budget of 5 million dollars. (500ë§Œ ë¶ˆì´ë¼ëŠ” í™ë³´ë¹„)
	- You have the following marketing options and their paybacks in new potential customers:
- Which marketing campaigns would you choose toÂ **maximize the total expected reach**Â under the condition that, for each of these marketing campaigns, you either select it or you donâ€™t?
	- ë§ì€ ì‚¬ëŒë“¤ì—ê²Œ ë…¸ì¶œ
	- ë‚´ê°€ ì§€ë¶ˆí•œ ë¹„ìš©ì˜ í•©ì´ 500ë§Œë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ê²Œ : 1,2,3, â€¦, Në²ˆ

![13](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/13.png)

- cost (dollar) - expected reach (people)
	- ë…¸ì¶œë˜ëŠ” ì‚¬ëŒë“¤ì˜ ìˆ˜

# 1. How to Solve the 0-1 Knapsack Problem

- NaÃ¯ve approach
	- There areÂ $2^n$Â subsets ofÂ $\{1, 2, ..., n\}!$
	- ì•„ì´í…œì¤‘ì— ì„ íƒí•  ìˆ˜ ìˆëŠ” ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ëŠ” 2^n : ê° ê²½ìš°ì— ëŒ€í•´ì„œ profitë“¤ì˜ í•©ì´ ì œì¼ í° ê²ƒ ì„ íƒ
	- ëª¨ë“  ê²½ìš°ë¥¼ ë”°ì ¸ë³´ëŠ” ê²½ìš° - ìˆœì„œëŒ€ë¡œ ë„£ì„ì§€ ë§ì§€ë¥¼ ê²°ì •í•˜ê¸° ë•Œë¬¸ì—
- Dynamic programming approach
	- LetÂ $P(i,w)$ be theÂ **maximized profit**Â obtained when choosing items *_only from the firstÂ ii_Â items under the restriction thatÂ **the total weight cannot exceedÂ w**_**w**_.
		- parameter 2ê°œ :
			- i : 1ë²ˆë¶€í„° 2ë²ˆ, 3ë²ˆ, â€¦ ië²ˆê¹Œì§€ë§Œ ì•ì˜ iê°œ itemì¤‘ì— ì„ íƒ
			- w : í˜„ì¬ ë‚¨ì€ ê°€ë°©ì˜ í—ˆìš©í•˜ëŠ” ë¬´ê²Œ - ë‚˜í•œí…Œ ë‚¨ì€ ê°€ë°©ì˜ ìš©ëŸ‰ì´ wë§Œí¼ ë‚¨ì•˜ë‹¤.
		- 1ë²ˆë¶€í„° ië²ˆê¹Œì§€ ì„ íƒí•œ ê²ƒë“¤ ì¤‘ weight í•©ì´ Wë³´ë‹¤ ê°™ê±°ë‚˜ ì‘ê²Œ í•˜ëŠ” ì¡°ê±´ì—ì„œ ìµœëŒ€ profitì˜ ê°’
	- If we letÂ _A_âˆ—Â be an optimal subset ofÂ $\{1, 2, ..., n\}$
		1. $n \in A* : P(n,W) = p_n + P(n-1, W-w_n)$
			1. dynamic programming ë‚´ìš© ì§‘ì–´ë„£ê¸° : ì¸ì ë‘ê°œë¥¼ ì§‘ì–´ë„£ì–´ì„œ ë¬¸ì œ ì‚¬ì´ì¦ˆë¥¼ ì¤„ì—¬ì•¼ í•¨
			2. ì´ ê°’ì„ ê³„ì‚°í•´ì•¼í•˜ëŠ”ë°, ê°’ì„ ì„ íƒí–ˆì„ ë•Œ profitë“¤ì˜ í•©ì„ maximize
				- ì„ íƒ ê°ê°ê°€ì¥ ë¯¸ì§€ë§‰ ië²ˆ ì˜ ë¬´ê²Œ
			- ë¶„ëª…íˆ ê°’ì„ maximizeí•˜ëŠ” ìµœì ì˜ ì„ íƒì´ ìˆëŠ”ë°, ê°€ì¥ ë§ˆì§€ë§‰ì˜ në²ˆ Itemì„ ì„ íƒí•˜ë˜ì§€ ì•ˆí•˜ë˜ì§€
			- $P(n,W)$ : në²ˆ ë¬¼ì²´ë¥¼ ì„ íƒí–ˆë‹¤ë©´
				- $p_n $ : në²ˆ itemì˜ Profitì´ ë”í•´ì§€ê³ 
				- $P(n-1, W-w_n)$ :
					- ë‚˜ë¨¸ì§€ ìƒí™©ì—ì„œ maximize : ê³ ë ¤í•  Itemì€ n-1ê°œ, ìµœëŒ€ Wê¹Œì§€ ë‹´ì„ ìˆ˜ ìˆëŠ”ë° wnì„ ëº€ ë‚¨ì€ ìš©ëŸ‰
		2. $n \notin A* : P(n,W) = P(n-1, W)$
			1. në²ˆ ë¬¼ì²´ëŠ” ì„ íƒí•˜ë©´ ì•ˆ ë˜ë‹ˆê¹Œ P(n-1,W)
			2. recursion : ê°™ì€ í˜•íƒœë¡œ í‘œí˜„í•˜ëŠ”ë° ë¬¸ì œ ì‚¬ì´ì¦ˆê°€ ì‘ì•„ì§
				1. në²ˆ itemì„ ì„ íƒí•˜ë“ ì§€, ë§ë“ ì§€ + í•œ ë¬¼ì²´ì— ëŒ€í•´ì„œ ë‚˜ë¨¸ì§€ itemì„ ê³ ë ¤
				2. (ì‘ì•„ì§„ ë¬¸ì œ ì‚¬ì´ì¦ˆ) recursive formulation
	- Optimal substructure
		- $P(i,w)=$
			- ì„ì˜ì˜ i : 0ë¶€í„° nê¹Œì§€ ê°„ë‹¤
				- 0 : ë‚´ê°€ ì„ íƒí•  ìˆ˜ ìˆëŠ” itemì´ í•˜ë‚˜ë„ ì—†ì„ ë•Œ
				- i : ë‚´ê°€ ì„ íƒí•  ìˆ˜ ìˆëŠ” itemì´ 1ë²ˆë¶€í„° ië²ˆê¹Œì§€ ì•ì˜ iê°œ
					- i=3 â†’1,2,3ì¤‘ì— ì„ íƒí•  ìˆ˜ ìˆë‹¤.
					- i=0 â†’ ì„ íƒí•  ì•„ì´í…œì´ ì—†ë‹¤
				- w: ë‚¨ì€ ìš©ëŸ‰ - 0ë¶€í„° ëŒ€ë¬¸ì Wê¹Œì§€, ëŒ€ë¬¸ì WëŠ” ì•„ì§ ì•„ë¬´ê²ƒë„ ì•ˆë“¤ì–´ê°”ì„ ë•Œ
			- 0Â ifÂ $i=0 || w = 0$
				- ì„ íƒí•  ì•„ì´í…œì´ ì—†ë‹¤
				- or ê°€ë°©ì— ë‹´ì„ ìˆ˜ ì—†ë‹¤ (ìš©ëŸ‰ì´ 0)
			- $P(iâˆ’1,w)$
				- ifÂ $i>0 || w_i >w$
				- ê°€ì¥ ë§ˆì§€ë§‰ ë¬¼ê±´ì˜ ë¬´ê²Œì¸ w_iê°€ wë³´ë‹¤ ë¬´ê±°ìš´ ê²½ìš° ìê²© ë¯¸ë‹¬ (ë‹´ì„ ìˆ˜ ì—†ìŒ)
				- iê°œ ë¬¼ì²´ê¹Œì§€ ì„ íƒí•˜ëŠ” ê²ƒì— ëŒ€í•´ì„œ ë§ˆì§€ë§‰ ê²ƒì„ ì„ íƒí• ê²ƒì¸ì§€
					- ë‚¨ì•„ìˆëŠ” ê°€ë°© ë¬´ê²Œì— ëŒ€í•´ì„œ : Ië²ˆì§¸ ë¬¼ì²´ëŠ” ì„ íƒí•  ìš”ê±´ì´ ì•ˆëœë‹¤
			- $\max \{(P(i-1,w), p_i+P(i-1,w-w_i))\}$
				- I>0 : 1,2,â€¦ië²ˆ item ì¤‘ì— ì„ íƒ
					- ië²ˆì§¸ itemì„ ë‹´ì§€ ì•Šì„ ê²½ìš° i-1ê°œì¤‘ì— ì˜ ì„ íƒí•œ ,
					- p_ië¥¼ ì–»ê³  ë‚˜ë¨¸ì§€ i-1ê°œì— ëŒ€í•´ì„œ ë§¨ ë§ˆì§€ë§‰ itemì„ ì œì™¸í•œ ë¬´ê²Œ
				- ë‹´ì„ ìˆ˜ ìˆëŠ”ë°, ì•ˆ ë‹´ì„ê±´ì§€ vs ë‹´ì„ ê²ƒì¸ì§€ì— ëŒ€í•œ ì°¨ì´
					- ìš”ê±´ì€ ë˜ëŠ”ë° ië²ˆì§¸ ë¬¼í’ˆì„ ì„ íƒí•˜ì§€ ì•ŠëŠ”ê²Œ ì¢‹ë‹¤
					- ië²ˆ Itemì„ ì„ íƒí•˜ëŠ” ê²Œ ì´ìœ¤ ê·¹ëŒ€í™”ì— ë” ì¢‹ë‹¤.
				- $i>0 || w_i \geq w$
- Example
	- i : 0~4
	- w : 0~W(6)
	- $\{w_1, w_2, ..., w_4\} = \{4,3,2,3\}$
	- $\{p_1, p_2, ..., p_4\} = \{3,2,4,4\}, W=6$
	- ì–´ë–¤ ìˆœìœ¼ë¡œ ë°©ë¬¸í•´ì„œ ì±„ìš¸ ê²ƒì¸ê°€
		- ê°’ì„ ê³„ì‚°í•˜ëŠ”ë° í•„ìš”í•œ ê²Œ ì–¼ë§ˆë‚˜ ë§ì€ì§€
		- iê°€ í•˜ë‚˜ ë¹ ì§€ê³ , í•˜ë‚˜ë¥¼ ê³„ì‚°í•˜ê¸° ìœ„í•´ì„œëŠ” ìœ„ì— ê²ƒì´ ê³„ì‚°ë˜ë©´ ë¨
			- i-1ì˜ ì‹ì´ í•µì‹¬ì ìœ¼ë¡œ ì‘ìš©í•˜ë‹ˆê¹Œ

![14](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/14.png)

- 0ë¶€í„° Nê¹Œì§€ : ì²« ë²ˆì§¸ í–‰ê³¼ ì—´ì€ ë‹¤ 0ìœ¼ë¡œ settingí•˜ê³  ì¢Œì—ì„œ ìš°ë¡œ ê°€ë©´ì„œ setting
- Ex.
	- $P(2,4) = \max{(P(1,4), p_2 + P(1, 4-w_2))} = \max{(P(1,4), 2+P(1,1))}=3$
		- 2 : 1,2ì¤‘ì— ì„ íƒí•¨, 2ë²ˆì„ ë‹´ì„ ìê²©ì´ ë˜ëŠ”ì§€, ì•ˆ ë˜ëŠ”ì§€
		- w2=3ì´ë‹ˆê¹Œ ê°€ë°© ìš©ëŸ‰ì—ëŠ” 4ë‹ˆê¹Œ ë‹´ì„ ìˆ˜ ìˆìŒ â†’ (iii)
		- P(1,4) : 2ë²ˆ ë¬¼ì²´ë¥¼ ë‹´ì§€ ì•Šìœ¼ë©´ ê°’ì´ ë” ì»¤ì§ˆ ê²ƒì´ë‹¤
			- P(2,4) ìœ„ì˜ ì¤„ : 3
		- p2+ : 2ë²ˆì„ ë‹´ê² ë‹¤ + 2ë²ˆì„ ë‹´ì„ ê²½ìš° 1ë²ˆì„ ì„ íƒí•˜ëŠ” ìƒí™©ì—ì„œ w2ë¥¼ ì œì™¸í•œ ê²ƒ = P(1,1)
			- P(1,1) = 3
			- P_2 = 2
		- 2ë²ˆì„ ë‹´ì§€ ì•Šê² ë‹¤.
	- $P(4,2) = P(3,2) = 4$
		- 1,2,3,4ì¤‘ì— ì„ íƒí•˜ëŠ” ê²ƒì¸ë° 4ë²ˆì€ ì„ íƒí• ì§€ë§ì§€ optimal substructure ì¤‘ ì„ íƒ
		- ë‚¨ì•„ìˆëŠ” ìš©ëŸ‰ 2 : 4ë²ˆì€ ê³ ë ¤ ëŒ€ìƒë„ ì•„ë‹˜ â†’ 4ë²ˆì€ ë¹¼ë²„ë¦¬ê³  1,2,3ì¤‘ì— ì„ íƒí•˜ì
	- $P(3,5) = \max{(P(2,5), p_3 + P(2,5-w_3))} = 6$
		- 3ë²ˆ Itemì˜ Weightê°€ 2ì´ë‹ˆê¹Œ ë‹´ì„ ìˆ˜ëŠ” ìˆëŠ”ë° ì§„ì§œ ë‹´ì„ ê²ƒì¸ì§€, ì•ˆ ë‹´ì„ê±´ì§€
		- p3 =4, P(2, 5-w3) = P(2,3) = 2ì´ë¯€ë¡œ 6
		- ë‘ ê°œì¤‘ì— ë’¤ì— ê²ƒì´ í¬ë‹¤ : 3ë²ˆì„ ì„ íƒí•  ê²ƒì´ë‹¤ë¼ëŠ” ì˜ë¯¸

# 3. How to Reconstruct the Solution

- $\{w_1, w_2, ..., w_4\} = \{4,3,2,3\}$
- $\{p_1, p_2, ..., p_4\} = \{3,2,4,4\}, W=6$

ië²ˆì§¸ itemì„ ì„ íƒí•  ìê²©ë„ ì•ˆë¨ : Weightê°€ ë” í° ê²½ìš°


ië²ˆì§¸ itemì„ ì„ íƒí•  ìê²©ì€ ë˜ì§€ë§Œ: ë¹„êµ

- $P(4,6) = \max{(P(3,6), p_4 + P(3, 6-w_4))} = 8$
	- 4ë²ˆì˜ weightê°€ 3ì´ê¸° ë•Œë¬¸ì— ì„ íƒí•  ìê²©ì€ ë¨ â†’ 4ë²ˆ ì„ íƒ
	- ì´ëŸ¬í•œ ê³„ì‚°ì„ í†µí•´ì„œ 8ì´ ë‚˜ì˜´
- $P(3,3) = \max{(P(2,3), p_3 + P(2, 3-w_3))} = 4$
	- 3ë²ˆì˜ itemì€ Weight=2ë¼ì„œ ì„ íƒí• ìˆ˜ ìˆìŒ
	- P(2,3-2) = P(2,1) = P(1,1) = P(0,1) = 0 â†’ iëŠ” í•œ ì¹¸ì”© ì˜¬ë¼ê°€ë©´ì„œ ì„ íƒí–ˆëŠ”ì§€ ì•„ë‹Œì§€ì— ëŒ€í•œ ë²ˆí˜¸ë¥¼ ì¶œë ¥í•¨
- $P(2,1) = P(1,1) = 0$
	- 2 X
- $P(1,1) = P(0,1) = 0$
	- 1 X

![15](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/15.png)


![16](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/16.png)


![17](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/17.png)


# 4. Implementation and Time Complexity

- $O(nW)$Â Time

	```c
	int zero_one_knapsack(int *p, int *w, int n, int W)
	{
	    int i, ww, tmp;
	    for (ww = 0; ww <= W; ww++) P[0][ww] = 0;
	    for (i = 1; i <= n; i++)
	    {
	        P[i][0] = 0;
	        for (ww = 1; ww <= W; ww++) //bottleneck - Wë²ˆ ìˆ˜í–‰
	        {
	            if (w[i] <= ww)
	            {
	                if ((tmp = p[i] + P[i - 1][ww - w[i]])
	 > P[i - 1][ww])
	                    P[i][ww] = tmp;
	                else
	                    P[i][ww] = P[i - 1][ww];
	            }
	            else P[i][ww] = P[i - 1][ww];
	        }
	    }
	    return P[n][W];
	}
	
	
	```

	- ì–´ë–¤ ê°’ì´ ìƒìˆ˜ì¸ì§€ ì•„ë‹Œì§€ì˜ íŒë‹¨ ê·¼ê±°ëŠ” Nì´ ì»¤ì§€ê±´ ì‘ì•„ì§€ê±´ ê³ ì •ë˜ëŠ”ê²Œ ìƒìˆ˜
	- ì§€ê¸ˆ time complexityê°€ nWê°€ ë¨ì€ ëª…í™•í•œë° ì´ëŠ” linear timeì¸ê°€?
		- table í•˜ë‚˜ë‹¹ $\Theta (1)$ì”© ê³„ì‚°
		- $(n+1) (w+1)$ table : $\Theta(nw)$
		- ìµœì¢… solutionì€ table ë§¨ ë°‘ í–‰ë¶€í„° í•˜ë‚˜ì”© íƒìƒ‰ : $\Theta (n)$
		- â†’ Theta(nw)
		- 

# 5. 0-1 Knapsack Ex. 1:Â n = 6, W = 10_n_=6,_W_=10


![18](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/18.png)

- ì«“ì•„ê°€ëŠ” ë°©ë²• ìƒê°í•´ë³´ê¸°
- Selected items: i = 2, 3, 4, 6
- Obtained profit: 19
- Is the time-complexityÂ $O(nW)$ an efficient one?
	- efficient : polynomial ì‹œê°„ì— bound ë  ë•Œ íš¨ìœ¨ì .
		- inefficient : exponential, factorial, // n^4, n^3ì€ ë¹„íš¨ìœ¨ì  practicalí•˜ê²Œ
	- This is not a linear-time algorithm!
		- variable :
			- n : ë„ë‘‘ì´ ë¬¼ê±´ì„ í›”ì¹  ë•Œ í›”ì¹  ìˆ˜ ìˆëŠ” ë¬¼ê±´ ê°œìˆ˜
			- W: ë„ë‘‘ì˜ ê°€ë°©ì´ í—ˆìš©í•˜ëŠ” ê°€ë°©ì˜ ì´ ìš©ëŸ‰
		- â†’ Nì— ëŒ€í•´ì„œ ìƒìˆ˜ë¼ë©´,wë¥¼ ì œê±°í•˜ë©´ ì´ ì•Œê³ ë¦¬ì¦˜ì€ linear time - polynomialì´ë¯€ë¡œ íš¨ìœ¨ì 
			- nì˜ í¬ê¸°ê°€ ì–¼ë§ˆë“ ì§€ ì»¤ì ¸ë„ wê°€ ë¶ˆë³€?
			- nê³¼ wëŠ” ë…ë¦½ì  : wê°€ nì— ëŒ€í•´ì„œ boundê°€ ë˜ì–´ì•¼ í•˜ëŠ”ë°, ì—¬ê¸°ì„œëŠ” ë…ë¦½ì ì´ë¼ê³  ë³¼ ìˆ˜ ìˆë‹¤. Në„ wë„ ë¬¸ì œ ìƒí™©ì— ë”°ë¼ ì§€ì •ëœë‹¤.
		- A problem is thatÂ _W_Â is not bounded with respect toÂ _n_.
			- Ex. What ifÂ _n_=20Â andÂ _W_=20!? â†’Â $O(nâˆ—n!)$
				- factorial time algorithm : ë” ë¹„íš¨ìœ¨ì ìœ¼ë¡œ ë§Œë“¤ ìˆ˜ ìˆìŒ.
			- WhenÂ _W_Â is extremely large in comparison withÂ _n_, this algorithm is worse than the brute-force algorithm that simply considers all subsets.
				- nì— ëŒ€í•´ì„œë„ linear, wì— ëŒ€í•´ì„œë„ linear. nì— ëŒ€í•´ì„œ Polynomialí•˜ì§€ ì•Šë‹¤.
			- This algorithm can be improved so that the worst-case number of entries computed isÂ $O(2^n)$
	- No one has ever found an algorithm for the 0-1 Knapsack problem whose worst-case time complexity is better than exponential, yet no one has proven that such an algorithm is not possible!
		- polynomial time alg ëŠ” ì–»ì§€ë„ ëª»í–ˆê³ , ì¦ëª…ë„ ëª»í•¨
		- ë¬¸ì œ size nì— ëŒ€í•´ì„œ ì¦ëª…ë„ ì°¾ì§€ë„ ëª»í•¨ â€” ì•„ë§ˆ Polynomial solutionì´ ì—†ì„ ê²ƒì´ë‹¤.
- np complete, np hard, â€¦
	- ì•„ë¬´ë„ ì¦ëª…í•˜ì§€ ëª»í•œ ë¬¸ì œ
	- nì˜ ëª‡ìŠ¹ì´ë¼ëŠ” poly solë„ ëª» ì°¾ì•˜ê³ ,

# 6. A Variation of the 0-1 Knapsack Problem

- Problem
	- Decision Problem
	- GivenÂ _n_Â items of lengthÂ $l_1, l_2, ..., l_n$, is there a subset of these items with total length exactlyÂ _L_?
undefined- Example
	- $\{ 1, 2, 7, 14, 49, 98, 343, 686, 2409, 2793, 16808, 17206, 117705, 117993 \}, \\ L = 138457{1,2,7,14,49,98,343,686,2409,2793,16808,17206,117705,117993},L=138457 â†’ \{1, 2, 7, 98, 343, 686, 2409, 17206, 117705\}{1,2,7,98,343,686,2409,17206,117705}$
- Dynamic programming approach
	- LetÂ $P(i,w)$Â be theÂ **maximized profit**Â obtained when choosing items *_only from the firstÂ ii_Â items under the restriction thatÂ **the total weight cannot exceedÂ w**_**w**_.
undefined	- If we letÂ _A_âˆ—Â be an optimal subset ofÂ $\{1, 2, ..., n\}$
		1. $n \in A* : P(n,W) = p_n + P(n-1, W-w_n)$
		2. $n \notin A* : P(n,W) = P(n-1, W)$
			- $\rightarrow fill (i, j)$

# 7. A Divide-and-Conquer Approach

- LetÂ `fill(i,j)`Â return TRUEÂ âŸºÂ âˆƒÂ subset of the firstÂ _i_Â items that has total lengthÂ _j_.

	WhenÂ `fill(i,j)`Â returns TRUE,

		1. If the ith item is used, `fill(i - 1, j -`Â _`li`_`)` must return TRUE.
		2. If the ith item is not used,Â `fill(i - 1, j)`Â must return TRUE.
- To solveÂ `fill(int n, int L)`,
	- $T(n)â‰¥cÂ $if $n=0$
	- $T(n) \geq 2T(n-1) +d$ if $n>0$
	- $\rightarrow T(n) = \Theta(2^n)$

```c
int fill(int i, int j) {
// l[i]: global variable 
if (i == 0)
  {
    if(j == 0) return TRUE;
    else return FALSE;
  }

if (fill(i-1, j))
  return TRUE;
else if (l[i] <= j)
  return fill(i-1, j-l[i]);
}
```


## A Dynamic Programming Approach

- The optimal substructure :
	- F(i,j)=_F_(_i_,_j_)=Â `FALSE`Â ifÂ _i_=0,_j_!=0
	- F(i,j)=_F_(_i_,_j_)=Â `TRUE`Â ifÂ _i_=0,_j_=0
	- $F(i,j)= F(i-1,j) || ((l_i \geq j) || F(i-1, j-l_i))$ ifÂ _i_>0
- O(nL)Â time implementation

	```c
	...
	F[0][0] = TRUE;
	for (ll = 1; ll <= L; ll++)
	  F[0][ll] =FALSE;
	for (i = 1; i <= n; i++) {
	  for (ll = 0; ll <= L; ll++) {
	    F[i][ll] = F[i-1][ll];
	    if (ll â€“ l[i] >= 0)
	      F[i][ll] = F[i][ll] || F[i-1][ll-l[i]];
	  }
	}
	return (F[n][L]);
	
	
	```

- Example

	![19](/assets/img/2022-09-29-[ALG]-4.2.-DP-Application.md/19.png)


# 8. Subset Sum


nì— ëŒ€í•´ì„œ polynomial solë„ ì°¾ì§€ ëª»í•¨

- Problem
	- Given a set of positive integersÂ $\{w_1, w_2, ..., w_n\}$ of sizeÂ _n_Â and a postivie integerÂ _W_, Find a subsetÂ _A_Â ofÂ $\{1,2,...,n\}$Â that maximizesÂ $\Sigma_{i\in A}{w_i}$ subject toÂ $\Sigma_{i\in A}{w_i} \leq W$
	- ì–‘ì˜ ì •ìˆ˜ nê°œ, ì–´ë–¤ ì–‘ì˜ ì •ìˆ˜ Wê°€ ì£¼ì–´ì¡Œì„ ë•Œ ëª‡ ê°œë¥¼ ë½‘ì„ ê²ƒì´ë‹¤. aë¼ëŠ” ì§‘í•©ì´ ë½‘ì€ ì• ë“¤ì˜ index ì§‘í•©ì´ë‹¤. ë½‘ì€ ì• ë“¤ì˜ í•©ì„ maximizeí•˜ë¼.
- Example
	- $\{w_1, ..., w_9\} = \{20,30,14,70,40,50,15,25,80,60,10,95\}, W=99 \\\rightarrow \{20,14,40,25\}$
- Application
	- There areÂ _n_Â jobs, each of which takesÂ _wi_Â time.
	- Now we have a CPU withÂ _W_Â free cycles, and want to choose the set of jobs that minimizes the number of idle cycles.
		- w cycleë™ì•ˆì— ë‚´ê°€ schedulingí•´ ì£¼ì–´ CPUë¥¼ ì˜ í™œìš©í•´ì•¼ í•œë‹¤.
		- ì—¬ëŸ¬ userë“¤ì´ ë“¤ì–´ì™”ì„ ë•Œ, w1 cycleë§Œí¼ ì†Œìš”ë˜ê³ , 2ë²ˆ userì—ì„œ ë“¤ì–´ì˜¤ë©´ w2ë§Œí¼ì˜ cycleì´ í•„ìš”í•˜ê³  â€¦ në²ˆ userì—ì„œ jobì„ schedulingí•˜ë©´ wn cycleì´ í•„ìš”í•¨
		- systemì„ ê°€ì¥ ìµœì ìœ¼ë¡œ í™œìš©í•˜ê¸° ìœ„í•´, w1,, wn ì¤‘ ëª‡ ê°œë¥¼ ë½‘ì•„ì„œ scheduling ì§„í–‰í•  ê²ƒ
		- ë½‘ì€ ì• ë“¤ì˜ í•©ì´ Wë³´ë‹¤ ì‘ìœ¼ë©´ì„œ maximize : ëª‡ë²ˆ, ëª‡ë²ˆ, ëª‡ë²ˆ í•´ì„œ ëì— ë¬´ìˆ˜ë¦¬ê°€ ë‚¨ì„ ê²ƒì¸ë° ì´ ê³³ì—ì„œëŠ” CPUê°€ idleí•˜ëŠ” cycle ë°œìƒ : minimizeê°€ ëª©í‘œ
	- â†’ CPU Cycleì´ë¼ëŠ” ê·€í•œ resourceë¥¼ ë‚­ë¹„í•˜ì§€ ì•Šë„ë¡ minimizeí•˜ì
	- ë…¼ì™¸) exact algorithmëŠ” ì•„ë¬´ë„ í’€ì§€ ëª»í–ˆë‹¤. â†’ approximation algorithm, heuristic algorithm
- Relation to the 0-1 Knapsack problem
	- Given two sets of positive integersÂ $\{w_1, w_2, ..., w_n\}$ andÂ $\{p_1, p_2, ..., p_n\}$ of sizeÂ _n_Â and a positive integerÂ _W_, find a subsetÂ _A_Â ofÂ $\{1,2,...,n\}$Â that maximizesÂ $\Sigma_{i \in A} p_i$Â subject toÂ $\Sigma_{i \in A} w_i \geq W$
	- âŸº
		- Given a set of positive integersÂ $\{w_1, w_2, ..., w_n\}$Â of sizeÂ _n_Â and a postivie integerÂ _W_, Find a subsetÂ _A_Â ofÂ $\{1,2,...,n\}$Â that maximizesÂ $\Sigma_{i\in A}{w_i}$ subject toÂ $\Sigma_{i\in A}{w_i} \geq W$
	- 0-1 knapsackì„ polynomial timeì— í’€ ìˆ˜ ìˆìœ¼ë©´, subset sumë„ í’€ ìˆ˜ ìˆë‹¤
- ì°¸ê³ 
	- If it is possible to solve theÂ **0-1 knapsack**Â problem inÂ **polynomial time**, theÂ **subset sum**Â problem can be solved inÂ **polynomial time**Â too.
	- Somebody has already proven that the subset sum problem is very hard.
	- In other words, the subset sum problem isÂ **NP**complete.Â â†’Â Hence, the 0-1 knapsack problem is also a very hard problem. In other words, the 0-1 knapsack problem is alsoÂ **NP**complete.
undefined